(* Content-type: application/vnd.wolfram.mathematica *)

(*** Wolfram Notebook File ***)
(* http://www.wolfram.com/nb *)

(* CreatedBy='Mathematica 10.0' *)

(*CacheID: 234*)
(* Internal cache information:
NotebookFileLineBreakTest
NotebookFileLineBreakTest
NotebookDataPosition[       158,          7]
NotebookDataLength[    396883,       9245]
NotebookOptionsPosition[    386148,       8917]
NotebookOutlinePosition[    386860,       8942]
CellTagsIndexPosition[    386817,       8939]
WindowFrame->Normal*)

(* Beginning of Notebook Content *)
Notebook[{

Cell[CellGroupData[{
Cell[BoxData["Today"], "Input",
 CellChangeTimes->{{3.73279634913824*^9, 3.732796351862769*^9}, 
   3.732800493320031*^9, {3.733048870739476*^9, 3.733048877267962*^9}, {
   3.733269864488125*^9, 3.73326986576749*^9}, {3.733270990938971*^9, 
   3.733270991318811*^9}}],

Cell[BoxData[
 TemplateBox[{RowBox[{"\"Sat 21 Apr 2018\""}],RowBox[{"DateObject", "[", 
     RowBox[{"{", 
       RowBox[{"2018", ",", "4", ",", "21"}], "}"}], "]"}]},
  "DateObject",
  Editable->False]], "Output",
 CellChangeTimes->{
  3.7327963524456987`*^9, 3.7327988146073503`*^9, 3.732800496874042*^9, 
   3.732801372125017*^9, 3.732823456956298*^9, 3.7329704256210613`*^9, 
   3.733048877735165*^9, 3.733050796302861*^9, 3.7330512148570766`*^9, 
   3.7330577948371572`*^9, 3.73306577680892*^9, 3.733073981551526*^9, 
   3.733074149010796*^9, 3.7330799624885187`*^9, 3.733125359554858*^9, 
   3.7331282284863567`*^9, 3.733133300114868*^9, 3.7332108372466917`*^9, 
   3.733211535417728*^9, 3.7332125525177917`*^9, 3.733212752415169*^9, {
   3.733212822324748*^9, 3.733212848177206*^9}, 3.7332159636484222`*^9, 
   3.733216118586319*^9, 3.7332217374188557`*^9, 3.733221796739285*^9, 
   3.733269886381727*^9, 3.733277690053195*^9}]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["Solving all lab exercises of an Introductory Java course with ",
  FontSize->36],
 StyleBox["Mathematica",
  FontSize->36,
  FontSlant->"Italic"],
 " "
}], "Title",
 CellChangeTimes->{{3.7327963739455347`*^9, 3.732796402168004*^9}, {
   3.7327984592813587`*^9, 3.7327984659055033`*^9}, {3.732971174845151*^9, 
   3.732971175181555*^9}, {3.733040541201063*^9, 3.733040561485742*^9}, 
   3.733270101690648*^9},
 FontSize->14],

Cell[TextData[{
 StyleBox["Ilkka Kokkarinen",
  FontSlant->"Italic"],
 ", ",
 StyleBox["ilkka.kokkarinen@gmail.com",
  FontFamily->"Courier New"],
 "\n\n",
 StyleBox["Introduction", "Chapter"],
 "\n\nThe author has taught an introductory Java course ",
 ButtonBox["CCPS 109 Computer Science I",
  BaseStyle->"Hyperlink",
  ButtonData->{
    URL["https://docs.google.com/document/d/1JTbx-Nm16GNwTxHnujq4APC_gztz-\
VgqJTVu4jkx4M0/edit?usp=sharing"], None},
  ButtonNote->
   "https://docs.google.com/document/d/1JTbx-Nm16GNwTxHnujq4APC_gztz-\
VgqJTVu4jkx4M0/edit?usp=sharing"],
 " at the Ryerson Chang School continuously for the past sixteen years, \
basically developing all his own material along the way. Over this time span, \
the Java language itself has evolved tremendously, from the introduction of \
",
 StyleBox["generics",
  FontSlant->"Italic"],
 " in Java 5 to the move towards more functional programming spirit with \
techniques such as ",
 StyleBox["computation streams",
  FontSlant->"Italic"],
 " and ",
 StyleBox["lambdas",
  FontSlant->"Italic"],
 " in Java 8. As this course nears the end of its lifetime, as the department \
has chosen to follow the universal trend of switching the introductory \
programming course to Python, a move enthusiastically 100% endorsed by this \
author, it is time to take this idea one step further. This document was \
inspired from the question of how difficult it would be to solve ",
 ButtonBox["the instructor\[CloseCurlyQuote]s current set of ten weekly labs",
  
  BaseStyle->"Hyperlink",
  ButtonData->{
    URL["https://docs.google.com/document/d/1l9IeT9brVc1Hwbip5rpTNEvIje3rfet_\
j37DgoVUyUI/edit?usp=sharing"], None},
  ButtonNote->
   "https://docs.google.com/document/d/1l9IeT9brVc1Hwbip5rpTNEvIje3rfet_\
j37DgoVUyUI/edit?usp=sharing"],
 ", each lab consisting of four method writing problems, using ",
 StyleBox["Mathematica ",
  FontSlant->"Italic"],
 "instead of Java",
 StyleBox[". ",
  FontSlant->"Italic"],
 "Along the way, we see what these exercises, originally designed to teach \
the imperative programming thinking of Java to rank beginners, can teach us \
about the fundamental similarities and differences between these two \
languages.\nOver these sixteen years, these weekly labs and their exercises \
also evolved significantly. Usually after each semester, some poorly \
performing and uninteresting lab problem was replaced by some sparkly new \
problem. Over time, most of the lab problems eventually fell on the wayside, \
and of course, a couple of lofty ideas with high hopes turned out to be utter \
failures with students and were quickly replaced by something that turned out \
to work better in practice. Pretty much all the remaining problems that have \
survived this gauntlet of unnatural selection really do have some important \
and educational point in them that justifies their existence. None of the \
problems is there as some make-work drudgery to fill that week\
\[CloseCurlyQuote]s mandatory work quota.\nThe target audience of this \
document is mainly intended to be motivated students of all ages who have \
taken the first year or two of computer science so that they know the basics \
of imperative programming and the object oriented thinking and style, and who \
are curious about functional programming languages and their different, often \
more concise style of thinking and problem solving. Many students gain such \
motivation after taking the author\[CloseCurlyQuote]s second course of \
programming where they get to try their hands on Java 8 computation streams \
to learn what a handy way they are to solve many problems in a way that is \
completely different from the usual way of solving problems with loops. \
(Streams also have the additional advantage of being naturally ",
 StyleBox["parallelizable",
  FontSlant->"Italic"],
 " without any extra effort from the part of the programmer, leading to an \
interesting class dicussion in the second programming course about that topic \
and other advantages of expressing computations in functional style.)\n\
Traditionally, the imperative and functional programming languages have been \
taught to form a strict duality of opposites that shall never meet. But \
surely it would be more accurate to say that these paradigms form a continuum \
on which almost all programming languages then fall depending on to what \
extent they allow functions and code to be treated and manipulated as \
first-class citizens of that language. Since the Nineties, languages from \
both the C family tree and the scripting language paradigm have steadfastly \
inched towards the functional programming end of this continuum, not trying \
to reach all the way to the very end but aiming towards that unknown sweet \
spot that would be the perfect compromise of clarity and power for working \
programmers to solve actual problems. The examples implemented in this \
document teach such people how to take the ideas that they would normally \
implement with loops and mutable arrays, and express these same ideas in \
functional programming form.\nFor this level of beginning programmer, the \
material that teaches functional programming available online is rather \
lacking, compared to the torrent of material readily available for every \
imperative and object oriented programming language. Most of such material is \
just far too simplistic so that it does not explain how to actually ",
 StyleBox["do",
  FontSlant->"Italic"],
 " anything using a functional programming approach. The other  alternative \
is that the material is way too high level so that you would basically need \
to already be a computer science Ph.D. to even begin to read it, written for \
people who write compilers and interpreters for fun and who do their thinking \
in category theory while juggling monads the way us boring normos write loops \
and conditions. This document aims to fill in this gap with at least a little \
bit of, if you pardon the pun, ",
 StyleBox["concrete",
  FontSlant->"Italic"],
 ". Solving these 42 problems will give the reader a grand tour of pretty \
much all of the important functions and techniques that make up the ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " core language, so this document works as a practical introduction to ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ".\nThe secondary audience of this article are other computer science \
instructors looking for inspiration for lab exercises either in the \
imperative or functional programming spirit, or who would just simply enjoy \
an \[OpenCurlyDoubleQuote]over the shoulder\[CloseCurlyDoubleQuote] read \
about the overall thought process that goes into the design of an \
introductory programming course and its individual labs.\n\n",
 StyleBox["Lab One: Classes and objects", "Chapter"],
 "\nThe most fundamental difference between Java and ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " is the forced program structure of classes and methods of the former, \
versus the functional and pattern matching programming style of the latter. \
This first lab of the Java course, intended to familiarize the student with \
the concepts of classes and objects (no main method is needed at this point, \
because the course uses the BlueJ environment that allows Java classes and \
objects to be manipulated with an interactive graphical GUI to try them out), \
asks the student to define a simple ",
 StyleBox["Rectangle",
  FontWeight->"Bold"],
 " class whose instances have an individual ",
 StyleBox["width",
  FontWeight->"Bold"],
 " and ",
 StyleBox["height",
  FontWeight->"Bold"],
 ", from which the derived virtual properties of ",
 StyleBox["area",
  FontWeight->"Bold"],
 " and ",
 StyleBox["perimeter",
  FontWeight->"Bold"],
 " can then be computed.\n",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " already contains all our familiar and unfamiliar geometric shapes as first \
class citizens of the symbolics language, so that  the mathematical pattern \
matching engine can compute their arbitrary properties and transformations. \
But let us ignore those for the moment, and solve this problem using the \
basic pattern matching operations of ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ". Since everything in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " is an expression for which we can define arbitrary transformation rules of \
our own choosing, a rectangle can be encoded as an expression of the form ",
 StyleBox["rectangle(width, height)",
  FontWeight->"Bold"],
 " for which we define appropriate substitution rules. Of course, \
\[OpenCurlyDoubleQuote]rectangle\[CloseCurlyDoubleQuote], \
\[OpenCurlyDoubleQuote]width\[CloseCurlyDoubleQuote] and \
\[OpenCurlyDoubleQuote]height\[CloseCurlyDoubleQuote] are just names that \
mean nothing to the computer. But when naming things, it is important to give \
them names that ring the correct bell inside the human reader\
\[CloseCurlyQuote]s brain and allow him to make reasonable inferences based \
on the semantic associations of those names. (On the other hand, we should \
not fall into the famous fallacy of artificial intelligence and hallucinate \
that our chosen names themselves have magical properties that somehow have \
the power to affect the operation of that program, so that a program that \
encodes a triple ",
 StyleBox["(is, love, emotion)",
  FontWeight->"Bold"],
 " would be somehow different from an identical program that encodes a triple \
",
 StyleBox["(x98, foo\[Pi]bar, QQQ)",
  FontWeight->"Bold"],
 ". Any program will still work exactly the same after you consistently \
renamed all its identifiers throughout that program.)"
}], "Text",
 CellChangeTimes->{{3.7327964204649563`*^9, 3.73279675484359*^9}, {
   3.732796935834816*^9, 3.732797072087311*^9}, {3.732797109642292*^9, 
   3.732797415995082*^9}, {3.732797514512808*^9, 3.732797622096161*^9}, {
   3.732797713062183*^9, 3.7327977919331007`*^9}, {3.73279791414694*^9, 
   3.732797917865099*^9}, {3.7327987728860273`*^9, 3.732798787470323*^9}, {
   3.732971087322248*^9, 3.732971141631958*^9}, {3.732971182398868*^9, 
   3.7329717152161093`*^9}, {3.732971765706108*^9, 3.73297177312733*^9}, {
   3.733043418159894*^9, 3.73304373365084*^9}, {3.733047092598217*^9, 
   3.733047117312434*^9}, {3.7330488995812893`*^9, 3.733048949225789*^9}, {
   3.733048980407762*^9, 3.733049226069482*^9}, {3.733049752650333*^9, 
   3.733049987537429*^9}, 3.733058352852895*^9, {3.733071437507064*^9, 
   3.7330716823649387`*^9}, {3.733123899266214*^9, 3.733124098316934*^9}, {
   3.7331248328808117`*^9, 3.733124911849532*^9}, {3.733125707991702*^9, 
   3.73312570941538*^9}, {3.733126754483507*^9, 3.7331270019585*^9}, {
   3.733127066674748*^9, 3.733127078806126*^9}, {3.733127114162244*^9, 
   3.733127332065813*^9}, {3.733212764659501*^9, 3.733212788412902*^9}, {
   3.73321698187635*^9, 3.733217176833932*^9}, {3.733217287874159*^9, 
   3.733217507538066*^9}, {3.733217551135755*^9, 3.733217606742793*^9}, {
   3.7332217157394133`*^9, 3.7332217171192636`*^9}, {3.7332227147457113`*^9, 
   3.733222777237756*^9}, {3.733250604648847*^9, 3.733250607239285*^9}, {
   3.733251134751848*^9, 3.733251153438324*^9}, {3.73326990546765*^9, 
   3.7332699060519342`*^9}, 3.733270286431634*^9, {3.7332710399636393`*^9, 
   3.733271063059705*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"width", "[", 
    RowBox[{"rectangle", "[", 
     RowBox[{"w_", ",", "h_"}], "]"}], "]"}], " ", ":=", " ", "w"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"height", "[", 
    RowBox[{"rectangle", "[", 
     RowBox[{"w_", ",", "h_"}], "]"}], "]"}], " ", ":=", " ", "h"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"area", "[", 
    RowBox[{"rectangle", "[", 
     RowBox[{"w_", ",", "h_"}], "]"}], "]"}], " ", ":=", " ", 
   RowBox[{"w", " ", "*", " ", "h"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"perimeter", "[", 
    RowBox[{"rectangle", "[", 
     RowBox[{"w_", ",", "h_"}], "]"}], "]"}], " ", ":=", " ", 
   RowBox[{"2", 
    RowBox[{"(", 
     RowBox[{"w", " ", "+", " ", "h"}], ")"}]}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"flip", "[", 
    RowBox[{"rectangle", "[", 
     RowBox[{"w_", ",", "h_"}], "]"}], "]"}], " ", ":=", " ", 
   RowBox[{"rectangle", "[", 
    RowBox[{"h", ",", "w"}], "]"}]}], ";"}]}], "Input",
 CellChangeTimes->{{3.732797400562686*^9, 3.732797430273752*^9}, {
   3.7327974658090467`*^9, 3.7327974737148743`*^9}, {3.732797567304819*^9, 
   3.732797580296527*^9}, {3.7327976283738737`*^9, 3.732797727596902*^9}, {
   3.732797800483687*^9, 3.732797823355256*^9}, 3.73279794608652*^9, {
   3.732798790508864*^9, 3.732798808965816*^9}},
 FontSize->14],

Cell[TextData[{
 "These five definitions provide the functionality required in the first lab. \
Each of the ten labs of the course comes with a ",
 StyleBox["JUnit tester class",
  FontSlant->"Italic"],
 " that separately tests each of the four methods required in that lab. To \
guarantee the appropriate test coverage, the tester for each method generates \
a large number of random inputs that are individually given to the method \
currently under testing, and calculates the Adler-32 checksum of the answers \
returned by the method implementation. (Using some cryptographically stronger \
but slower checksum would be pointless, since any student able to crack the \
current scheme would still get off easier simply by honestly writing the \
specified methods as asked.) This checksum is then compared to the checksum \
that was produced by the instructor\[CloseCurlyQuote]s private model \
solution, hardcoded inside the JUnit tester. If these two checksums agree, \
the student gets the green checkmark in the BlueJ tester interface and 0.5 \
marks added towards his or her total course grade, these ten labs together \
accounting for 20 marks of the total course grade of 100.\nThe Java language \
guarantees that all possible computations done using the four primitive \
integer types ",
 StyleBox["byte",
  FontWeight->"Bold"],
 ", ",
 StyleBox["short",
  FontWeight->"Bold"],
 ", ",
 StyleBox["int",
  FontWeight->"Bold"],
 " and ",
 StyleBox["long",
  FontWeight->"Bold"],
 " will yield the exact same results in all environments. Since the Java \
standard random number generator class ",
 StyleBox["java.util.Random",
  FontWeight->"Bold"],
 " is also similarly guaranteed to always and everywhere produce the exact \
same random number stream from the same fixed seed that is hardcoded in the \
JUnit testers, this approach of testing student code submissions makes \
reaching good test coverage quite easy for instructors. This scheme works \
better also for the students who, while working on the lab problems usually \
at home at whatever time of the week is convenient for them, especially in \
the case of adult students who have actual real lives and corresponding adult \
life responsibilities rather than the ",
 StyleBox["wandervogel",
  FontSlant->"Italic"],
 " freedom to slouch your behind into the computer lab (which, not unlike the \
Java language itself, are just another silly relic from a simpler and poorer \
time when computing power was not as cheap and ubiquitous as it is today) \
every Friday night, instantly knowing if their method works or not by one \
mouse click of the green JUnit tester class. Since each lab solution is \
submitted as a complete BlueJ project folder that includes that JUnit tester, \
the instructor can also verify and grade the submission in literally ten \
seconds flat with just a couple of mouse clicks, instead of having to pore \
through the code and reason whether some particularly novel construction that \
is different from the instructor\[CloseCurlyQuote]s own model solution would \
produce some off-by-one error in some corner case. This is why we have \
machines in the first place, to do this tedious work for us. \nOne big \
downside of this randomized testing is that this process cannot tell the \
student which particular test cases and how many of them the code failed. The \
",
 StyleBox["CodingBat",
  FontSlant->"Italic"],
 " interactive Java training website, also used in this course to drill in \
the Java syntax and thinking, is much better in this sense that its \
submission process makes the particular failed tests explicit to help the \
student reason about the exact nature of the bug in his code. This can be \
ameliorated slightly by having the tester to also compute additional \
information about the answers returned method, such as the total number of ",
 StyleBox["true",
  FontWeight->"Bold"],
 " answers over the test cases when testing some classifier method. If this \
number differs from the expected result, the fact of whether this count is \
too high (false positives) or too low (false negatives) guides the student in \
reasoning and finding the bug. However, in place of a larger programming \
project, the instructor prefers to serve his students CodingBat for \
breakfast, lunch and dinner, to really drill in the language syntax and the \
process of solving problems with the language.\nIn ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", the same way as in symbolic mathematics in general, we are content to \
observe that our definitions are mathematically correct. We can still quickly \
try them out by hand as a simple sanity check, of course."
}], "Text",
 CellChangeTimes->{{3.732797952065847*^9, 3.73279845253925*^9}, {
  3.732798502954035*^9, 3.732798623169012*^9}, {3.7327986545678864`*^9, 
  3.7327986589201717`*^9}, {3.732798760446876*^9, 3.732798761940493*^9}, {
  3.732799027866582*^9, 3.732799172078607*^9}, {3.732799282197022*^9, 
  3.732799342268371*^9}, {3.7329718009093733`*^9, 3.732971802269824*^9}, {
  3.733050032989768*^9, 3.7330500347106667`*^9}, {3.7330716941939497`*^9, 
  3.733072070570993*^9}, {3.733217182188315*^9, 3.733217275587124*^9}, {
  3.733219306771763*^9, 3.733219492855632*^9}, {3.733250614927743*^9, 
  3.73325076225074*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"height", "[", 
    RowBox[{"flip", "[", 
     RowBox[{"rectangle", "[", 
      RowBox[{"3", ",", "6"}], "]"}], "]"}], "]"}], ",", 
   RowBox[{"area", "[", 
    RowBox[{"rectangle", "[", 
     RowBox[{"4", ",", " ", "5"}], "]"}], "]"}], ",", 
   RowBox[{"perimeter", "[", 
    RowBox[{"rectangle", "[", 
     RowBox[{"10", ",", "20"}], "]"}], "]"}]}], "}"}]], "Input",
 CellChangeTimes->{{3.732797400562686*^9, 3.732797430273752*^9}, {
   3.7327974658090467`*^9, 3.7327974737148743`*^9}, {3.732797567304819*^9, 
   3.732797580296527*^9}, {3.7327976283738737`*^9, 3.732797727596902*^9}, {
   3.732797800483687*^9, 3.732797823355256*^9}, 3.73279794608652*^9, {
   3.732798629758914*^9, 3.732798647870905*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"3", ",", "20", ",", "60"}], "}"}]], "Output",
 CellChangeTimes->{{3.732797466116315*^9, 3.7327974709877043`*^9}, 
   3.7327978255894613`*^9, 3.732798648486508*^9, 3.732798814706311*^9, 
   3.7328004969658318`*^9, 3.732801372265132*^9, 3.732823457173131*^9, 
   3.732970425853854*^9, 3.733050796544178*^9, 3.733051215067272*^9, 
   3.7330577950601797`*^9, 3.733065777042532*^9, 3.733073981800529*^9, 
   3.7330741492983913`*^9, 3.733079962745092*^9, 3.733125359765689*^9, 
   3.733128228731277*^9, 3.733133300333075*^9, 3.733210837679652*^9, 
   3.7332115355936947`*^9, 3.733212552663126*^9, 3.733212752570581*^9, {
   3.7332128224621363`*^9, 3.733212848330276*^9}, 3.7332159638603*^9, 
   3.733216118739868*^9, 3.733221737609026*^9, 3.733221796952072*^9, 
   3.7332698866759567`*^9, 3.7332776901908503`*^9},
 FontSize->14]
}, Open  ]],

Cell["\<\
We can also define pattern matching rules for decisions that were not part of \
this first lab, since the Java if-else statement has not been taught at this \
point of the course.\
\>", "Text",
 CellChangeTimes->{{3.732797482073166*^9, 3.732797502681439*^9}, {
  3.732797853963399*^9, 3.732797910721717*^9}, {3.7327984726114283`*^9, 
  3.732798497937146*^9}, {3.732798702136331*^9, 3.732798749381544*^9}, {
  3.732798868609207*^9, 3.73279897116788*^9}, {3.7327991783807096`*^9, 
  3.7327992713398237`*^9}, {3.73279934490631*^9, 3.732799376056983*^9}, {
  3.732799427082857*^9, 3.73279946777708*^9}, {3.732800359178419*^9, 
  3.73280035936281*^9}, {3.732971818852201*^9, 3.732971949011118*^9}, {
  3.733040608597472*^9, 3.7330406602608957`*^9}, {3.7330500115638*^9, 
  3.733050021468852*^9}, {3.733072082400552*^9, 3.733072087386346*^9}, {
  3.733271342800768*^9, 3.733271343213872*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"isSquare", "[", 
    RowBox[{"rectangle", "[", 
     RowBox[{"x_", ",", "x_"}], "]"}], "]"}], " ", ":=", " ", "True"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"isSquare", "[", "_", "]"}], " ", ":=", " ", "False"}], ";"}], 
  "\[IndentingNewLine]"}], "\[IndentingNewLine]", 
 RowBox[{"{", 
  RowBox[{
   RowBox[{"isSquare", "[", 
    RowBox[{"rectangle", "[", 
     RowBox[{"4", ",", "4"}], "]"}], "]"}], ",", " ", 
   RowBox[{"isSquare", "[", 
    RowBox[{"rectangle", "[", 
     RowBox[{"3", ",", "8"}], "]"}], "]"}]}], "}"}]}], "Input",
 CellChangeTimes->{{3.733040674501939*^9, 3.733040726116042*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"True", ",", "False"}], "}"}]], "Output",
 CellChangeTimes->{{3.733040713011043*^9, 3.733040727436584*^9}, 
   3.7330507966138163`*^9, 3.733051215136593*^9, 3.733057795135075*^9, 
   3.733065777143858*^9, 3.7330739818817377`*^9, 3.7330741493887978`*^9, 
   3.733079962850775*^9, 3.733125359853557*^9, 3.733128228831614*^9, 
   3.733133300440402*^9, 3.733210837798011*^9, 3.733211535667242*^9, 
   3.733212552752743*^9, 3.7332127526462317`*^9, {3.733212822537129*^9, 
   3.7332128484136143`*^9}, 3.733215963960677*^9, 3.73321611883669*^9, 
   3.733221737705132*^9, 3.7332217970481586`*^9, 3.7332698867625923`*^9, 
   3.733277690269019*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "In ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", all geometric shapes are first class citizens of the entire language same \
way as all other mathematical objects, with arbitrary symbolic computations \
and transformation being possible for them. In a formalism where pretty much \
everything is an expression that consists of a head and some number of \
arguments, pattern matching rules and other transformations can be liberally \
applied to everything, and the front end will then render the resulting \
expressions with a particular head in some more human friendly visual form. \
Expressions whose head is ",
 StyleBox["Graphics",
  FontWeight->"Bold"],
 " are rendered as the graphical shapes that they symbolically represent. But \
despite how fancy some result looks when rendered on screen, everything is \
still internally an expression tree, as can always be revealed by applying \
either function ",
 StyleBox["FullForm",
  FontWeight->"Bold"],
 " or ",
 StyleBox["TreeForm",
  FontWeight->"Bold"],
 " to any expression to reveal the bare bones of this underlying reality."
}], "Text",
 CellChangeTimes->CompressedData["
1:eJxTTMoPSmViYGCQAGIQnRDuxLr//GvHyHNX2UG01pV9xiDaT+K6FYi+NEG4
EURL/bVtAdGXY47MBdFzTNcsBtEL6iZvAtFu8an7QfQxPZ+bIPra/VdPQHQd
g+w7EH3uEuMnEH1kWdIPEH39bsVfsDlbn+YcANIqc16DaWvXaFWRC68dRaIX
mILoOjnhPaZA2imy4xCIFvqV8cUSSGukfWCzAtI9XhURIHpJ+68oEB0RXtkG
olfNae8E0953poPoaX6bZoLo6drLNoJo/8nlm0F0zYSH20G0+1P+HSC6PSci
2wVIr/h6ogREL+tU3x8PpJf7XjgCovdcUJJMAIn/X6QAotsKP97oBNKLeFvu
gGjLxMwN3SD3MApvAtHfFxaI9QLpsGuXxUH0IaPT6cuAdMZ5gwIQDQCOKNwj

  "],
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"s1", " ", "=", 
   RowBox[{"Rectangle", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"0", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "2"}], "}"}]}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"s2", " ", "=", " ", 
   RowBox[{"Disk", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"2", ",", "2"}], "}"}], ",", "1"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"s3", " ", "=", " ", 
   RowBox[{"RegionIntersection", "[", 
    RowBox[{"s1", ",", " ", "s2"}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"ClearAll", "[", 
   RowBox[{"x", ",", "y"}], "]"}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"{", 
  RowBox[{
   RowBox[{"Area", "[", "s1", "]"}], ",", " ", 
   RowBox[{"Area", "[", "s2", "]"}], ",", " ", 
   RowBox[{"Area", "[", "s3", "]"}], ",", " ", 
   RowBox[{"Integrate", "[", 
    RowBox[{
     RowBox[{
      RowBox[{"x", "^", "2"}], "+", "y"}], ",", " ", 
     RowBox[{
      RowBox[{"{", 
       RowBox[{"x", ",", "y"}], "}"}], " ", "\[Element]", " ", "s3"}]}], 
    "]"}]}], "}"}], "\[IndentingNewLine]", 
 RowBox[{"Graphics", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{"EdgeForm", "[", 
      RowBox[{"{", 
       RowBox[{"Thick", ",", " ", "Black"}], "}"}], "]"}], ",", "Red", ",", 
     " ", "s1", ",", " ", 
     RowBox[{"Opacity", "[", ".5", "]"}], ",", "Green", ",", " ", "s2"}], 
    "}"}], ",", " ", 
   RowBox[{"ImageSize", " ", "\[Rule]", " ", "Small"}]}], "]"}]}], "Input",
 CellChangeTimes->{{3.7330500866204348`*^9, 3.733050209083714*^9}, {
  3.733050240107102*^9, 3.7330502479849577`*^9}, {3.73305029649769*^9, 
  3.7330503006423903`*^9}, {3.7330503396727858`*^9, 3.733050412907413*^9}, {
  3.7330504480708237`*^9, 3.733050546885775*^9}, {3.73305057783733*^9, 
  3.73305063072335*^9}, {3.733050669732189*^9, 3.733050669874494*^9}, {
  3.7330507085905323`*^9, 3.7330507430586576`*^9}, {3.733072098694427*^9, 
  3.733072100254237*^9}, {3.7331266309961777`*^9, 3.733126633519623*^9}, {
  3.7332217217370377`*^9, 3.7332217218490562`*^9}, {3.7332217799388227`*^9, 
  3.733221782456421*^9}, {3.733251180793741*^9, 3.733251184840847*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"4", ",", "\[Pi]", ",", 
   FractionBox["\[Pi]", "4"], ",", 
   RowBox[{
    FractionBox["5", "48"], " ", 
    RowBox[{"(", 
     RowBox[{
      RowBox[{"-", "16"}], "+", 
      RowBox[{"15", " ", "\[Pi]"}]}], ")"}]}]}], "}"}]], "Output",
 CellChangeTimes->{
  3.733050631838379*^9, 3.733050670523735*^9, {3.73305071337084*^9, 
   3.7330507477000732`*^9}, 3.733050800208445*^9, 3.733051218593081*^9, 
   3.733057798323743*^9, 3.7330657803224154`*^9, 3.733072105296195*^9, 
   3.733073986648593*^9, 3.733074153758664*^9, 3.733079966943808*^9, 
   3.7331253639260607`*^9, 3.733126638238584*^9, 3.733128233415642*^9, 
   3.733133304311599*^9, 3.73321084177735*^9, 3.73321153979275*^9, 
   3.733212556621264*^9, 3.7332127565084457`*^9, {3.733212826410871*^9, 
   3.7332128522102633`*^9}, 3.7332159682282124`*^9, 3.733216122820221*^9, {
   3.733221775805081*^9, 3.73322179857648*^9}, 3.733269888545657*^9, 
   3.733277691950946*^9},
 FontSize->14],

Cell[BoxData[
 GraphicsBox[
  {RGBColor[1, 0, 0], EdgeForm[{GrayLevel[0], Thickness[Large]}], 
   RectangleBox[{0, 0}, {2, 2}], 
   {RGBColor[0, 1, 0], Opacity[0.5], DiskBox[{2, 2}]}},
  ImageSize->Small]], "Output",
 CellChangeTimes->{
  3.733050631838379*^9, 3.733050670523735*^9, {3.73305071337084*^9, 
   3.7330507477000732`*^9}, 3.733050800208445*^9, 3.733051218593081*^9, 
   3.733057798323743*^9, 3.7330657803224154`*^9, 3.733072105296195*^9, 
   3.733073986648593*^9, 3.733074153758664*^9, 3.733079966943808*^9, 
   3.7331253639260607`*^9, 3.733126638238584*^9, 3.733128233415642*^9, 
   3.733133304311599*^9, 3.73321084177735*^9, 3.73321153979275*^9, 
   3.733212556621264*^9, 3.7332127565084457`*^9, {3.733212826410871*^9, 
   3.7332128522102633`*^9}, 3.7332159682282124`*^9, 3.733216122820221*^9, {
   3.733221775805081*^9, 3.73322179857648*^9}, 3.733269888545657*^9, 
   3.733277691964099*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "The previous example uses ",
 StyleBox["x",
  FontWeight->"Bold"],
 " and ",
 StyleBox["y",
  FontWeight->"Bold"],
 " as symbols that are assumed to be uninitialized when used inside ",
 StyleBox["Integrate",
  FontWeight->"Bold"],
 ". Whenever symbols are used this way, it is a good idea to use ",
 StyleBox["ClearAll",
  FontWeight->"Bold"],
 " to ensure that their names don\[CloseCurlyQuote]t have any values \
associated with them but remain as pure symbols. This avoids tricky bugs that \
can easily occur especially if several ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " documents are simultaneously open using the same computation kernel. If \
evaluating another document assigns some values to these symbols, these \
values get silently substituted in their place inside ",
 StyleBox["Integrate",
  FontWeight->"Bold"],
 ", causing the entire computation to do something very different than was \
originally intended."
}], "Text",
 CellChangeTimes->{{3.7332512069361877`*^9, 3.7332513714773893`*^9}, {
  3.733269932973502*^9, 3.733269961805265*^9}, {3.733271445695674*^9, 
  3.733271459172535*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[TextData[{
 StyleBox["Lab Two: Conditions\n", "Chapter"],
 "The second lab of this introductory Java course teaches the students to use \
the basic ",
 StyleBox["if-else conditions",
  FontSlant->"Italic"],
 " to solve decision problems. Nearly every adult is familiar with the \
ordinary 52 playing cards and how their combinations create virtually \
infinite possibilities for endless variety of play, which makes playing cards \
an immediately familiar problem domain for the students to practice \
programming in both this and the following week's labs. (As Mark Twain noted \
back in his day, every educated person should at least know that a flush \
beats a straight.) The four  methods required this week each receive a hand \
of playing cards as arguments, from which these methods then have to \
determine whether that hand of cards satisfies the given interesting property \
such as being a poker ",
 StyleBox["flush",
  FontSlant->"Italic"],
 " or a ",
 StyleBox["four-of-a-kind",
  FontSlant->"Italic"],
 ". Given a poker hand known to contain exactly five cards, these conditions \
can be written without any loops, since those have not yet been taught at \
this point in the course, merely by looking at the five cards and the pairs \
that they form one at the time inside an ",
 StyleBox["if-else ladder",
  FontSlant->"Italic"],
 ". However, the stealthy idea between the lines in all of this week\
\[CloseCurlyQuote]s problems is preparing the student for the need for loops \
in the future labs where the string can contain any number of cards, or for \
that matter, anything at all.\nAt this point of the Java course, the students \
have not yet seen arrays, but the previous lecture that covered all the basic \
data types and their properties and operations has familiarized them with the \
",
 StyleBox["String",
  FontWeight->"Bold"],
 " class with its basic operations ",
 StyleBox["charAt",
  FontWeight->"Bold"],
 ", ",
 StyleBox["length",
  FontWeight->"Bold"],
 " and ",
 StyleBox["substring",
  FontWeight->"Bold"],
 ", from which all other ",
 StyleBox["String",
  FontWeight->"Bold"],
 " operations could in principle be built from ground up. In ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", lists are naturally taught from day one, so in a programming course that \
uses ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", the five card poker hand would be given as a list of cards. The fully \
symbolic nature of the ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " language would even allow us to represent ranks and suits directly as \
these symbols, using the Unicode symbols within the language itself to denote \
the suits. "
}], "Text",
 CellChangeTimes->{{3.732797482073166*^9, 3.732797502681439*^9}, {
  3.732797853963399*^9, 3.732797910721717*^9}, {3.7327984726114283`*^9, 
  3.732798497937146*^9}, {3.732798702136331*^9, 3.732798749381544*^9}, {
  3.732798868609207*^9, 3.73279897116788*^9}, {3.7327991783807096`*^9, 
  3.7327992713398237`*^9}, {3.73279934490631*^9, 3.732799376056983*^9}, {
  3.732799427082857*^9, 3.73279946777708*^9}, {3.732800359178419*^9, 
  3.73280035936281*^9}, {3.732971818852201*^9, 3.732971949011118*^9}, {
  3.733040608597472*^9, 3.7330406602608957`*^9}, {3.733049251280526*^9, 
  3.7330493995124702`*^9}, {3.7330500517591*^9, 3.733050074836355*^9}, {
  3.733072132642799*^9, 3.733072143219222*^9}, {3.7331266122143307`*^9, 
  3.7331266156134043`*^9}, {3.733212909577549*^9, 3.7332129919585133`*^9}, {
  3.733219528585815*^9, 3.73321968730682*^9}, {3.73327148097476*^9, 
  3.733271703282097*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"suitChars", " ", "=", " ", 
  RowBox[{"FromCharacterCode", "[", 
   RowBox[{"Map", "[", 
    RowBox[{
     RowBox[{
      RowBox[{"FromDigits", "[", 
       RowBox[{"#", ",", "16"}], "]"}], "&"}], ",", 
     RowBox[{"{", 
      RowBox[{
      "\"\<2663\>\"", ",", "\"\<2666\>\"", ",", " ", "\"\<2660\>\"", ",", 
       " ", "\"\<2665\>\""}], "  ", "}"}]}], "]"}], "]"}]}]], "Input",
 CellChangeTimes->{{3.7327994691994457`*^9, 3.732799543945075*^9}, {
  3.732799586751647*^9, 3.7327996737116756`*^9}, {3.732807489404282*^9, 
  3.7328074897684317`*^9}},
 FontSize->14],

Cell[BoxData["\<\"\[ClubSuit]\:2666\[SpadeSuit]\:2665\"\>"], "Output",
 CellChangeTimes->{
  3.732799544872333*^9, {3.73279963268165*^9, 3.7327996740221786`*^9}, 
   3.732800497015486*^9, 3.732801372308345*^9, 3.732823457274132*^9, 
   3.732970425941112*^9, 3.733050800476921*^9, 3.733051218864806*^9, 
   3.733057798597784*^9, 3.733065780619285*^9, 3.733073987023608*^9, 
   3.733074154056733*^9, 3.7330799672301292`*^9, 3.733125364237546*^9, 
   3.7331282336912603`*^9, 3.733133304597505*^9, 3.733210842192443*^9, 
   3.7332115400111113`*^9, 3.733212556837895*^9, 3.73321275670061*^9, {
   3.733212826615267*^9, 3.733212852407598*^9}, 3.73321596847361*^9, 
   3.733216123066085*^9, 3.7332217987819853`*^9, 3.73326988881809*^9, 
   3.733277692123331*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "However, we can use this opportunity to solve these problems with ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " string processing techniques, so that following the specification of the \
original Java lab, the arguments given to these functions are text strings \
where each card is encoded as two characters. The first character represents \
the rank from ",
 StyleBox["23456789TJQKA",
  FontSlant->"Italic"],
 ", followed by the second character representing the suit from ",
 StyleBox["cdhs",
  FontSlant->"Italic"],
 ". A hand that consists of ",
 StyleBox["n",
  FontSlant->"Italic"],
 " playing cards will then be encoded as a string of precisely the length ",
 StyleBox["2n",
  FontSlant->"Italic"],
 ", with no separator characters inserted between the cards.\nThe very first \
lab problem within the previous setup asks for a method that takes the rank \
given as a character and converts it to its nominal integer value. For \
simplicity, and following the lightweight spirit of the ",
 StyleBox["design by contract",
  FontSlant->"Italic"],
 " software engineering philosophy, in all the labs in the course the method \
implementations may assume that their argument values are legal as promised \
in the method specification. These methods therefore don\[CloseCurlyQuote]t \
need to perform any error detection, let alone error recovery that would be a \
topic better left for a more advanced course. (The author\[CloseCurlyQuote]s \
second course of programming, of course, covers the concept of ",
 StyleBox["method pre- and postconditions",
  FontSlant->"Italic"],
 " and how ",
 StyleBox["exceptions",
  FontSlant->"Italic"],
 " are used to terminate a method that can only throw its hands up in the air \
in frustration and give up as soon as it realizes that it has been asked to \
do something that was logically impossible to begin with.)"
}], "Text",
 CellChangeTimes->{{3.7327996866450167`*^9, 3.7327999119604588`*^9}, {
  3.73297197580206*^9, 3.732972048721084*^9}, {3.732972096906045*^9, 
  3.732972141735405*^9}, {3.733072149152166*^9, 3.7330722431204977`*^9}, {
  3.733219697797144*^9, 3.7332198673513203`*^9}, {3.733222698539114*^9, 
  3.733222701841579*^9}, {3.733271728395788*^9, 3.733271808535548*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"ranks", " ", "=", " ", 
   RowBox[{"{", 
    RowBox[{
    "\"\<2\>\"", ",", "\"\<3\>\"", ",", "\"\<4\>\"", ",", "\"\<5\>\"", ",", 
     "\"\<6\>\"", ",", "\"\<7\>\"", ",", "\"\<8\>\"", ",", "\"\<9\>\"", ",", 
     "\"\<T\>\"", ",", "\"\<J\>\"", ",", "\"\<Q\>\"", ",", "\"\<K\>\"", ",", 
     "\"\<A\>\""}], "}"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"numericalRank", "[", "r_", "]"}], " ", ":=", " ", 
   RowBox[{"First", "[", 
    RowBox[{"First", "[", 
     RowBox[{"1", " ", "+", " ", 
      RowBox[{"Position", "[", 
       RowBox[{"ranks", ",", " ", "r"}], "]"}]}], "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"Map", "[", 
  RowBox[{"numericalRank", ",", " ", "ranks"}], "]"}]}], "Input",
 CellChangeTimes->{{3.732799918121694*^9, 3.732800030263535*^9}, {
  3.732800667662332*^9, 3.732800676380962*^9}, {3.7329720711952333`*^9, 
  3.732972089200919*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
  "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", ",", "9", 
   ",", "10", ",", "11", ",", "12", ",", "13", ",", "14"}], "}"}]], "Output",
 CellChangeTimes->{{3.732799982164116*^9, 3.732800031304603*^9}, 
   3.732800497065687*^9, 3.73280067700156*^9, 3.7328013723592854`*^9, 
   3.7328234573571253`*^9, 3.732970426024562*^9, 3.7329720907000847`*^9, 
   3.7330508005402203`*^9, 3.7330512189654016`*^9, 3.733057798678691*^9, 
   3.7330657809448233`*^9, 3.7330739871446047`*^9, 3.733074154152975*^9, 
   3.733079967330142*^9, 3.733125364333164*^9, 3.7331282338011017`*^9, 
   3.733133304702488*^9, 3.733210842308474*^9, 3.733211540092121*^9, 
   3.733212556932829*^9, 3.733212756775001*^9, {3.733212826699765*^9, 
   3.73321285249305*^9}, 3.733215968573908*^9, 3.733216123149415*^9, 
   3.73322179886333*^9, 3.733269888901651*^9, 3.73327769220862*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "Given a five-card poker hand encoded as a string of ten characters, the \
second lab problem of this week asks the method to determine whether that \
hand is a ",
 StyleBox["flush",
  FontSlant->"Italic"],
 ", that is, all of its five cards are of the same suit. In Java, this \
becomes a straightforward conjunction of equality comparisons between the \
five suit characters extracted from the hand. The students will hopefully \
realize at this point that only four equality comparisons suffice, since it \
is necessary to compare each suit character only to the suit of the first \
card, due to the ",
 StyleBox["transitivity",
  FontSlant->"Italic"],
 " of equality.\nIn ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", determining whether the hand is a flush can be achieved in a more \
abstract manner by checking whether the string matches the pattern whose \
characters on the odd positions we don\[CloseCurlyQuote]t care about, whereas \
all five characters in the even positions must be the exact same character, \
whichever suit character that one might be. One very important difference \
between Java and ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " also illustrated in this problem is that Java uses the programmer-style \
zero-based indexing throughout, whereas ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " consistently uses normal people style one-based indexing throughout. (The \
zeroth index of a list or an arbitrary expression gives the head of that \
expression, which can cause weird results for somebody who, due to an \
ingrained habit, accidentally uses zero-based indexing with ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ".) We can write this function to work with hands on any length ",
 StyleBox["n",
  FontSlant->"Italic"],
 " by building the pattern used for string matching to consist of ",
 StyleBox["n",
  FontSlant->"Italic"],
 " separate pieces that are combined together with ",
 StyleBox["Nest",
  FontWeight->"Bold"],
 "."
}], "Text",
 CellChangeTimes->{{3.732800050400955*^9, 3.732800078550231*^9}, {
  3.732800170612006*^9, 3.732800220427393*^9}, {3.732800340322835*^9, 
  3.732800390601242*^9}, {3.7328024576589737`*^9, 3.7328024970105762`*^9}, {
  3.732803416419623*^9, 3.732803478834983*^9}, {3.732972157944769*^9, 
  3.732972245797879*^9}, {3.7330407866273537`*^9, 3.733040825138817*^9}, {
  3.7330722531981907`*^9, 3.733072365511232*^9}, {3.7332198823460703`*^9, 
  3.733219932142069*^9}, {3.733271319075571*^9, 3.7332713268716183`*^9}, {
  3.733271816090487*^9, 3.733271912173009*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"isFlush", "[", "hand_", "]"}], " ", ":=", " ", 
   RowBox[{"With", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"n", " ", "=", " ", 
       RowBox[{"Ceiling", "[", 
        RowBox[{
         RowBox[{"StringLength", "[", "hand", "]"}], "/", "2"}], "]"}]}], 
      "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{"With", "[", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"pat", " ", "=", " ", 
         RowBox[{"Nest", "[", 
          RowBox[{
           RowBox[{
            RowBox[{"(", 
             RowBox[{
             "#", " ", "~~", " ", "_", " ", "~~", " ", "suitInFlush_"}], 
             ")"}], "&"}], ",", "StartOfString", ",", " ", "n"}], "]"}]}], 
        "}"}], ",", "\[IndentingNewLine]", 
       RowBox[{"StringMatchQ", "[", 
        RowBox[{"hand", ",", " ", "pat"}], "]"}]}], "]"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"SetAttributes", "[", 
   RowBox[{"isFlush", ",", " ", "Listable"}], "]"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"isFlush", "[", 
  RowBox[{"{", 
   RowBox[{
   "\"\<Kh7h2hTh3h\>\"", ",", " ", "\"\<Qh7s2hTh3h\>\"", ",", " ", 
    "\"\<7hAh4h\>\""}], "}"}], "]"}]}], "Input",
 CellChangeTimes->{{3.732800087918878*^9, 3.732800166669567*^9}, 
   3.732800407467168*^9, {3.732800476219584*^9, 3.73280049007157*^9}, {
   3.7328014784763308`*^9, 3.732801506152872*^9}, {3.732801554564928*^9, 
   3.732801646834787*^9}, {3.732801678671895*^9, 3.7328017502483788`*^9}, {
   3.732801817875804*^9, 3.732801866521743*^9}, {3.73280191793819*^9, 
   3.732801926275405*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"True", ",", "False", ",", "True"}], "}"}]], "Output",
 CellChangeTimes->{{3.7328016218539553`*^9, 3.73280164863787*^9}, 
   3.732801684848732*^9, {3.7328017199407387`*^9, 3.732801751212059*^9}, {
   3.732801819047936*^9, 3.732801825386066*^9}, 3.732801868767962*^9, 
   3.73282345744101*^9, 3.732970426108699*^9, 3.7330508006073627`*^9, 
   3.733051219050344*^9, 3.733057798761043*^9, 3.733065781036717*^9, 
   3.733073987267465*^9, 3.733074154260998*^9, 3.7330799674301577`*^9, 
   3.733125364433515*^9, 3.733128233918*^9, 3.733133304802718*^9, 
   3.733210842445362*^9, 3.733211540180094*^9, 3.733212557032123*^9, 
   3.7332127568589373`*^9, {3.7332128267828283`*^9, 3.733212852576701*^9}, 
   3.733215968674247*^9, 3.7332161232346277`*^9, 3.7332217989620867`*^9, 
   3.733269888985095*^9, 3.733277692292213*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "To test out this function, we can use ",
 StyleBox["Table",
  FontWeight->"Bold"],
 " to generate the list of all 52 playing cards, for which basic \
combinatorics will generate all possible hands of given length. It is more \
efficient to ",
 StyleBox["Subsets",
  FontWeight->"Bold"],
 " instead of ",
 StyleBox["Permutations",
  FontWeight->"Bold"],
 " to ensure that every possible hand is produced in exactly one sorted \
permutation where the cards appear in the same order as they appear in the \
original deck. The following series of statements then tells us that, \
ignoring the order in which the cards are in the hand, there are exactly 5148 \
ways to choose five different cards so that all five have the same suit. \
However, 40 of these single-suited hands are actually ",
 StyleBox["straight flushes. ",
  FontSlant->"Italic"],
 "(Precisely forty, because a straight is identified by its lowest card that \
can be from 1 to 10, ace here serving as a one in the ",
 StyleBox["bicycle straight",
  FontSlant->"Italic"],
 ", and each straight flush can then be made from any one of the four \
possible suits.) Recognizing a straight would be a pretty difficult problem \
at this point of the course, especially when an ace can be counted as either \
1 or 14,  so we simply ignore straight flushes for the purposes of this \
problem."
}], "Text",
 CellChangeTimes->{{3.732800412473201*^9, 3.732800415768709*^9}, {
  3.7328005824627447`*^9, 3.732800635861335*^9}, {3.732801901759815*^9, 
  3.732801914282901*^9}, {3.732801950644504*^9, 3.732801970624508*^9}, {
  3.7328020200183764`*^9, 3.732802065784631*^9}, {3.7328021433537683`*^9, 
  3.732802266128447*^9}, {3.7328024120605707`*^9, 3.7328024185077868`*^9}, {
  3.732803372151716*^9, 3.7328033727163687`*^9}, {3.732972268390172*^9, 
  3.732972385130052*^9}, {3.73304943300904*^9, 3.73304944994184*^9}, {
  3.7330578471836777`*^9, 3.7330578662623253`*^9}, {3.733072389957106*^9, 
  3.733072441773858*^9}, {3.733271927192981*^9, 3.733271962668941*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"suits", " ", "=", " ", 
   RowBox[{"{", 
    RowBox[{
    "\"\<s\>\"", ",", "\"\<h\>\"", ",", "\"\<d\>\"", ",", "\"\<c\>\""}], 
    "}"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"deck", " ", "=", " ", 
   RowBox[{"Flatten", "[", 
    RowBox[{"Table", "[", 
     RowBox[{
      RowBox[{"r", " ", "<>", " ", "s"}], ",", " ", 
      RowBox[{"{", 
       RowBox[{"s", ",", " ", "suits"}], "}"}], ",", " ", 
      RowBox[{"{", 
       RowBox[{"r", ",", " ", "ranks"}], "}"}]}], "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"flushes", " ", "=", " ", 
   RowBox[{"Select", "[", 
    RowBox[{
     RowBox[{"Map", "[", 
      RowBox[{"StringJoin", ",", 
       RowBox[{"Subsets", "[", 
        RowBox[{"deck", ",", " ", 
         RowBox[{"{", "5", "}"}]}], "]"}]}], "]"}], ",", " ", "isFlush"}], 
    "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"Length", "[", "flushes", "]"}]}], "Input",
 CellChangeTimes->{{3.7328006415020657`*^9, 3.7328007332202063`*^9}, {
  3.732800784772459*^9, 3.732800945399935*^9}, {3.732801283131349*^9, 
  3.7328012898307657`*^9}, {3.732801329223913*^9, 3.732801412075787*^9}, {
  3.7328018786273127`*^9, 3.73280187908961*^9}, {3.732801965460693*^9, 
  3.732801965511427*^9}, {3.732802010853198*^9, 3.732802011849455*^9}, {
  3.732802067025845*^9, 3.732802088561174*^9}, {3.732807428705905*^9, 
  3.732807432761572*^9}},
 FontSize->14],

Cell[BoxData["5148"], "Output",
 CellChangeTimes->{{3.732800709859446*^9, 3.732800716748337*^9}, {
   3.73280136589895*^9, 3.732801403324689*^9}, 3.732801607704653*^9, 
   3.732801875816835*^9, {3.7328019613551826`*^9, 3.7328019660272512`*^9}, 
   3.732802012647015*^9, {3.732802075867959*^9, 3.732802085731757*^9}, 
   3.732802128574664*^9, 3.7328074220604763`*^9, 3.732807534691177*^9, 
   3.732823511341213*^9, 3.732970468961824*^9, 3.733050838468256*^9, 
   3.7330512577221727`*^9, 3.733057837726367*^9, 3.733065821111541*^9, 
   3.7330740307825603`*^9, 3.733074197545146*^9, 3.733080006498481*^9, 
   3.733125401698545*^9, 3.733128276996797*^9, 3.733133341678544*^9, 
   3.73321088068908*^9, 3.7332115805784597`*^9, 3.7332125955736027`*^9, 
   3.73321279544051*^9, 3.733212829893332*^9, 3.733212890793435*^9, 
   3.733216006774145*^9, 3.733216162005307*^9, 3.733221843301302*^9, 
   3.733269927933264*^9, 3.733277738069152*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "The next question asks the student to write a similar method to recognize a \
poker hand that is a ",
 StyleBox["four of a kind",
  FontSlant->"Italic"],
 ". This one, like many other problems, is actually a special case of a more \
general problem of computing the general shape of the hand when suits are \
ignored and we only look at the ",
 StyleBox["multiset",
  FontSlant->"Italic"],
 " of ranks. Comparing the rank of every card to the ranks of the cards that \
are placed after it within the hand, and counting how many such ",
 StyleBox["internal pairs",
  FontSlant->"Italic"],
 " of cards have equal ranks, gives an integer result whose value directly \
identifies the poker hand as high card (0), one pair (1), two pair (2), three \
of a kind (3), full house (4) or four of a kind (6). To go above an beyond \
the original Java lab problem, we can in fact easily generate all possible \
five card poker hands, with each permutation of cards produced exactly once, \
and count how many of these hands are of each type of shape."
}], "Text",
 CellChangeTimes->{{3.732802398894088*^9, 3.732802439083083*^9}, {
   3.732802510218246*^9, 3.7328025463456173`*^9}, {3.732802762286837*^9, 
   3.732802763966695*^9}, {3.7328033448842897`*^9, 3.732803366859799*^9}, {
   3.732972402904458*^9, 3.7329724230323687`*^9}, {3.7330724675415363`*^9, 
   3.733072478348687*^9}, {3.733123878420196*^9, 3.7331238830708714`*^9}, {
   3.733124148899791*^9, 3.733124208627915*^9}, {3.733124279121114*^9, 
   3.733124313495557*^9}, {3.7332098327427692`*^9, 3.733209956444726*^9}, {
   3.7332099987638206`*^9, 3.7332101787717524`*^9}, 3.7332107447595167`*^9, {
   3.73321107881336*^9, 3.7332110902594223`*^9}, {3.733219965396575*^9, 
   3.7332200165162582`*^9}, {3.7332719716308804`*^9, 3.733272051218781*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"internalPairCount", "[", "hand_", "]"}], " ", ":=", " ", 
   RowBox[{"With", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"rc", " ", "=", " ", 
       RowBox[{"Characters", "[", "hand", "]"}]}], "}"}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{"Length", "[", 
      RowBox[{"Cases", "[", 
       RowBox[{
        RowBox[{"Subsets", "[", " ", 
         RowBox[{
          RowBox[{"Table", "[", 
           RowBox[{
            RowBox[{"rc", "[", 
             RowBox[{"[", "i", "]"}], "]"}], ",", " ", 
            RowBox[{"{", 
             RowBox[{"i", ",", " ", "1", ",", " ", 
              RowBox[{"Length", "[", "rc", "]"}], ",", " ", "2"}], "}"}]}], 
           "]"}], ",", " ", 
          RowBox[{"{", "2", "}"}]}], "]"}], ",", " ", 
        RowBox[{"{", 
         RowBox[{"rank_", ",", "rank_"}], "}"}]}], "]"}], "]"}]}], 
    "\[IndentingNewLine]", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"shapeConvert", "[", "0", "]"}], " ", ":=", " ", 
   "\"\<no pair\>\""}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"shapeConvert", "[", "1", "]"}], " ", ":=", " ", 
   "\"\<one pair\>\""}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"shapeConvert", "[", "2", "]"}], " ", ":=", " ", 
   "\"\<two pair\>\""}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"shapeConvert", "[", "3", "]"}], " ", ":=", " ", 
   "\"\<three of a kind\>\""}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"shapeConvert", "[", "4", "]"}], " ", ":=", " ", 
   "\"\<full house\>\""}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"shapeConvert", "[", "5", "]"}], " ", ":=", " ", 
   "\"\<impossible\>\""}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"shapeConvert", "[", "6", "]"}], " ", ":=", " ", 
   "\"\<four of a kind\>\""}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"pairCounts", " ", "=", " ", 
   RowBox[{"Map", "[", 
    RowBox[{"internalPairCount", ",", 
     RowBox[{"Map", "[", 
      RowBox[{"StringJoin", ",", " ", 
       RowBox[{"Subsets", "[", 
        RowBox[{"deck", ",", " ", 
         RowBox[{"{", "5", "}"}]}], "]"}]}], "]"}]}], "]"}]}], ";", 
  RowBox[{"Table", "[", 
   RowBox[{
    RowBox[{
     RowBox[{"shapeConvert", "[", "k", "]"}], " ", "\[Rule]", " ", 
     RowBox[{"Count", "[", 
      RowBox[{"pairCounts", ",", " ", "k"}], "]"}]}], ",", " ", 
    RowBox[{"{", 
     RowBox[{"k", " ", ",", " ", "0", ",", " ", "6"}], "}"}]}], 
   "]"}]}]}], "Input",
 CellChangeTimes->{{3.732802551038301*^9, 3.732802555625855*^9}, {
   3.732802636849958*^9, 3.7328028218944693`*^9}, {3.732802868889052*^9, 
   3.732802889806941*^9}, {3.732803051983514*^9, 3.732803237392611*^9}, {
   3.7328033425991917`*^9, 3.732803342935483*^9}, {3.7331242106741457`*^9, 
   3.73312421351657*^9}, {3.733124456212481*^9, 3.733124459572566*^9}, 
   3.733210251046233*^9, {3.733210349278961*^9, 3.733210460302247*^9}, {
   3.733210643138475*^9, 3.733210650586233*^9}, {3.73321096307891*^9, 
   3.733210965433462*^9}, {3.7332110092214813`*^9, 3.7332110571571608`*^9}, {
   3.733211215733129*^9, 3.7332112179275503`*^9}, 3.733212465936655*^9},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"\<\"no pair\"\>", "\[Rule]", "1317888"}], ",", 
   RowBox[{"\<\"one pair\"\>", "\[Rule]", "1098240"}], ",", 
   RowBox[{"\<\"two pair\"\>", "\[Rule]", "123552"}], ",", 
   RowBox[{"\<\"three of a kind\"\>", "\[Rule]", "54912"}], ",", 
   RowBox[{"\<\"full house\"\>", "\[Rule]", "3744"}], ",", 
   RowBox[{"\<\"impossible\"\>", "\[Rule]", "0"}], ",", 
   RowBox[{"\<\"four of a kind\"\>", "\[Rule]", "624"}]}], "}"}]], "Output",
 CellChangeTimes->{3.733211204917995*^9, 3.733211388144368*^9, 
  3.733211919379767*^9, 3.733212654333733*^9, 3.7332128043283663`*^9, 
  3.733212948407243*^9, 3.733216063036281*^9, 3.7332162192544928`*^9, 
  3.7332219081473837`*^9, 3.733269985719241*^9, 3.733277795345083*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "These computed counts agree with the Wikipedia page \[OpenCurlyDoubleQuote]",
 ButtonBox["List of Poker Hands",
  BaseStyle->"Hyperlink",
  ButtonData->{
    URL["https://en.wikipedia.org/wiki/List_of_poker_hands"], None},
  ButtonNote->"https://en.wikipedia.org/wiki/List_of_poker_hands"],
 "\[CloseCurlyDoubleQuote] that say that among all possible five card poker \
hands, there exist precisely 1,098,240 one pair hands, 123,552 two pair \
hands, 54,912 three-of-a-kind hands, 3,744 full houses and 624 four-of-a-kind \
hands. (Derivations of all these counts are elementary exercises for an \
introductory course on combinatorics.) The remaining 1,317,888 hands that \
contain no internal pairs then either are lowly high card hands, or they are \
straights, flushes or straight flushes, none of which can contain any pairs.\n\
As you can also see from the produced list, a five card poker hand cannot \
contain five internal pairs. The reader can, just for fun, try to create a \
five-card poker hand with an internal pair count of five to see why this task \
is logically impossible. This magic number five could be realized in the \
poker variation of ",
 StyleBox["seven card stud",
  FontSlant->"Italic"],
 ", where it would indicate a shape that contains one three of a kind, one \
pair and then another pair. Such deceptively nice-looking hand is a bit \
disappointing due to its redundancy in power, because the extra pair does not \
elevate this hand any higher in the poker hand rankings.\nThe fourth, and \
thus the final, question of this second lab asks for a method that can \
identify whether the given hand of cards is a ",
 StyleBox["badugi ",
  FontSlant->"Italic"],
 "from the exotic poker variation of the same name, that is, its no two cards \
are of the same rank or the same suit. Quick combinatorial counting with our \
fingers reveals that there is a total of 3 + 2 + 1 = 6 comparisons to be made \
between the six internal pairs, and the cards within each internal pair must \
be separately compared with for equality by suit and by rank. Restricted to \
hands of four cards, this method therefore needs to perform exactly 12 \
equality comparisons, unless the student has peeked a couple of weeks ahead \
in the material to be able to simplify this logic with nested loops. This \
problem also indirectly teaches the students the very important ",
 StyleBox["de Morgan\[CloseCurlyQuote]s laws",
  FontSlant->"Italic"],
 " of negating logical expressions, as soon as their first attempt of \
essentially negating the logic of flush identification method mysteriously \
fails to produce the correct answers that would pass the JUnit testers.\n\
Since there exist only four possible suits, a hand can have at most four \
cards and still qualify as a badugi. Since this method once again does not \
need to be prepared for illegal arguments, it can be solved as a one-liner by \
extracting all its characters into a list and then removing the duplicate \
elements using ",
 StyleBox["Union",
  FontWeight->"Bold"],
 ". If this operation does not shorten the length of the list, that means \
that there were no duplicated ranks or suits anywhere in that hand begin \
with, and that hand is therefore a badugi."
}], "Text",
 CellChangeTimes->{{3.7328033903169317`*^9, 3.7328033998836327`*^9}, {
  3.732803485690011*^9, 3.732803509209795*^9}, {3.7328036124883347`*^9, 
  3.732803662279669*^9}, {3.7328044874759197`*^9, 3.732804557050708*^9}, {
  3.7329724312321863`*^9, 3.732972566222657*^9}, {3.7330724853821297`*^9, 
  3.733072573667479*^9}, {3.733124332672771*^9, 3.733124428089138*^9}, {
  3.733210280998481*^9, 3.733210320794389*^9}, {3.733210750603106*^9, 
  3.733210805475465*^9}, {3.733212685421467*^9, 3.7332127190991583`*^9}, {
  3.7332167211577587`*^9, 3.733216944367131*^9}, {3.733220027418054*^9, 
  3.7332201016518784`*^9}, {3.733271294387702*^9, 3.733271294768867*^9}, {
  3.733272072775392*^9, 3.7332722483843203`*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"isBadugi", "[", "hand_", "]"}], " ", ":=", " ", 
   RowBox[{
    RowBox[{"Length", "[", 
     RowBox[{"Union", "[", 
      RowBox[{"Characters", "[", "hand", "]"}], "]"}], "]"}], " ", "\[Equal]",
     " ", 
    RowBox[{"StringLength", "[", "hand", "]"}]}]}], ";"}]], "Input",
 CellChangeTimes->{{3.732803515316636*^9, 3.732803519914234*^9}, {
  3.732803586186434*^9, 3.7328036098662033`*^9}, {3.732803643475272*^9, 
  3.732803671521597*^9}, {3.7328042597370443`*^9, 3.7328042602877913`*^9}},
 FontSize->14],

Cell[TextData[{
 "If we may again take a little sidebar into introductory combinatorics, the \
number of different ",
 StyleBox["k",
  FontSlant->"Italic"],
 "-card badugis can be computed easily by realizing that each badugi is \
simply some way to choose ",
 StyleBox["k",
  FontSlant->"Italic"],
 " different ranks out of 13 possible ranks. These ",
 StyleBox["k",
  FontSlant->"Italic"],
 " cards then also each must be of a different suit, but we can choose those ",
 StyleBox["k",
  FontSlant->"Italic"],
 " suits freely from the four possible suits, and assign our chosen suits to \
go with the chosen ",
 StyleBox["k",
  FontSlant->"Italic"],
 " ranks using an arbitrary permutation from the ",
 StyleBox["k!",
  FontSlant->"Italic"],
 " possibilities."
}], "Text",
 CellChangeTimes->{{3.732803681080473*^9, 3.732803742822318*^9}, {
  3.7328043447194347`*^9, 3.732804364973524*^9}, {3.73280439816641*^9, 
  3.732804468620165*^9}, {3.7329725721285257`*^9, 3.732972620614009*^9}, {
  3.7329726761340523`*^9, 3.732972688092729*^9}, {3.733072580348185*^9, 
  3.733072589667493*^9}, {3.733220128164645*^9, 3.7332201375699673`*^9}, {
  3.7332722567243233`*^9, 3.7332722576887283`*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{"badugis", " ", "=", " ", 
  RowBox[{"Table", "[", 
   RowBox[{
    RowBox[{"Length", "[", 
     RowBox[{"Select", "[", 
      RowBox[{
       RowBox[{"Map", "[", 
        RowBox[{"StringJoin", ",", 
         RowBox[{"Subsets", "[", 
          RowBox[{"deck", ",", " ", 
           RowBox[{"{", "k", "}"}]}], "]"}]}], "]"}], ",", " ", "isBadugi"}], 
      "]"}], "]"}], ",", 
    RowBox[{"{", 
     RowBox[{"k", ",", "1", ",", "4"}], "}"}]}], 
   "]"}]}], "\[IndentingNewLine]", 
 RowBox[{"expected", " ", "=", " ", 
  RowBox[{"Table", "[", 
   RowBox[{
    RowBox[{
     RowBox[{"Binomial", "[", 
      RowBox[{"4", ",", "k"}], "]"}], " ", "*", 
     RowBox[{"k", "!"}], "*", " ", 
     RowBox[{"Binomial", "[", 
      RowBox[{"13", ",", " ", "k"}], "]"}]}], ",", 
    RowBox[{"{", 
     RowBox[{"k", ",", "1", ",", "4"}], "}"}]}], "]"}]}]}], "Input",
 CellChangeTimes->{{3.732803762383939*^9, 3.73280384406135*^9}, {
  3.732804171706406*^9, 3.732804225236065*^9}, {3.732804285936984*^9, 
  3.7328043309988327`*^9}, {3.7328046258107767`*^9, 3.732804626221138*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"52", ",", "936", ",", "6864", ",", "17160"}], "}"}]], "Output",
 CellChangeTimes->{{3.732804209922155*^9, 3.732804227274147*^9}, {
   3.732804264765423*^9, 3.7328043342102957`*^9}, 3.732804646491414*^9, 
   3.732823566663218*^9, 3.732970509259193*^9, 3.73305087871227*^9, 
   3.7330512975146637`*^9, 3.7330578781985073`*^9, 3.733065862673246*^9, 
   3.733074076100148*^9, 3.733074243622497*^9, 3.733080046465534*^9, 
   3.733125442365323*^9, 3.7331283220999517`*^9, 3.733133381050124*^9, 
   3.7332109382383137`*^9, 3.733212656091074*^9, 3.7332129501438217`*^9, 
   3.733216064796114*^9, 3.733216221014352*^9, 3.733221910086104*^9, 
   3.7332699877407846`*^9, 3.733277797083004*^9},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"52", ",", "936", ",", "6864", ",", "17160"}], "}"}]], "Output",
 CellChangeTimes->{{3.732804209922155*^9, 3.732804227274147*^9}, {
   3.732804264765423*^9, 3.7328043342102957`*^9}, 3.732804646491414*^9, 
   3.732823566663218*^9, 3.732970509259193*^9, 3.73305087871227*^9, 
   3.7330512975146637`*^9, 3.7330578781985073`*^9, 3.733065862673246*^9, 
   3.733074076100148*^9, 3.733074243622497*^9, 3.733080046465534*^9, 
   3.733125442365323*^9, 3.7331283220999517`*^9, 3.733133381050124*^9, 
   3.7332109382383137`*^9, 3.733212656091074*^9, 3.7332129501438217`*^9, 
   3.733216064796114*^9, 3.733216221014352*^9, 3.733221910086104*^9, 
   3.7332699877407846`*^9, 3.733277797094708*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "Alternatively, we could have used ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 "\[CloseCurlyQuote]s powerful string pattern matching engine to determine \
whether the given hand is a badugi. Having done so below as a one-liner using \
string pattern matching that looks for any character that is repeated, we can \
quickly verify that both functions return the same answer for all possible \
sorted hands of four or fewer cards."
}], "Text",
 CellChangeTimes->{{3.733040859545176*^9, 3.7330408759528513`*^9}, {
  3.733041002621714*^9, 3.733041028878209*^9}, {3.7330410891735497`*^9, 
  3.733041089428197*^9}, {3.733041180860154*^9, 3.733041237530696*^9}, {
  3.733072611163188*^9, 3.733072631289997*^9}, {3.733220159004116*^9, 
  3.733220175673122*^9}, {3.733272268154735*^9, 3.7332723291736917`*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"isBadugiS", "[", "hand_", "]"}], " ", ":=", " ", 
   RowBox[{"Not", "[", 
    RowBox[{"StringMatchQ", "[", 
     RowBox[{"hand", ",", " ", 
      RowBox[{
      "___", " ", "~~", " ", "x_", " ", "~~", " ", "___", " ", "~~", " ", 
       "x_", " ", "~~", " ", "___"}]}], "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"And", " ", "@@", " ", 
  RowBox[{"Table", "[", 
   RowBox[{
    RowBox[{
     RowBox[{"isBadugi", "[", "hand", "]"}], " ", "\[Equal]", " ", 
     RowBox[{"isBadugiS", "[", "hand", "]"}]}], ",", " ", 
    RowBox[{"{", 
     RowBox[{"hand", ",", " ", 
      RowBox[{"Map", "[", 
       RowBox[{"StringJoin", ",", 
        RowBox[{"Subsets", "[", 
         RowBox[{"deck", ",", " ", "4"}], "]"}]}], "]"}]}], "}"}]}], 
   "]"}]}]}], "Input",
 CellChangeTimes->{{3.733040881345683*^9, 3.733040894177906*^9}, {
  3.733040967592424*^9, 3.733041105037262*^9}, {3.7330411577084913`*^9, 
  3.7330411607753687`*^9}, {3.733041210197151*^9, 3.733041211011306*^9}},
 FontSize->14],

Cell[BoxData["True"], "Output",
 CellChangeTimes->{{3.733041094568684*^9, 3.73304110871808*^9}, 
   3.733041141402211*^9, 3.733041174835348*^9, 3.733041247996951*^9, 
   3.733050882041944*^9, 3.733051300873105*^9, 3.733057881669344*^9, 
   3.73306586622392*^9, 3.733074080137356*^9, 3.733074247452094*^9, 
   3.733080049924481*^9, 3.7331254459394407`*^9, 3.7331283258992453`*^9, 
   3.7331333844165983`*^9, 3.7332109416304483`*^9, 3.733212659467965*^9, 
   3.733212953673205*^9, 3.733216068200254*^9, 3.733216224394293*^9, 
   3.733221913922029*^9, 3.733269991183731*^9, 3.733277800641169*^9},
 FontSize->14]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[StyleBox["Lab Three: Loops",
 FontSize->36]], "Chapter",
 CellChangeTimes->{{3.732804592275136*^9, 3.7328046133777637`*^9}, {
   3.732804651803547*^9, 3.732804897566495*^9}, {3.7328051482540073`*^9, 
   3.732805163874784*^9}, {3.732972633872388*^9, 3.7329726551103888`*^9}, {
   3.732972693634304*^9, 3.732972822764122*^9}, {3.733041255404763*^9, 
   3.73304127170723*^9}, 3.733057218682064*^9},
 FontSize->14],

Cell[TextData[{
 StyleBox["The third lab of this introductory Java course continues on the \
previous week\[CloseCurlyQuote]s theme of hands made up of playing cards that \
are encoded as strings of two characters, one for the rank and one for the \
suit. However, in this week\[CloseCurlyQuote]s lab the hands are too long for \
even the most careful student to encapsulate the entire logic into a giant \
if-else ladder of individual card comparisons, so some sort of loop must \
necessarily be used to solve each problem.\nThe first question moves from the \
seedy and smoke-filled back rooms of poker to the more raffinated air of ", 
  "Text",
  FontSize->14,
  FontColor->GrayLevel[0]],
 StyleBox["contract bridge", "Text",
  FontSize->14,
  FontSlant->"Italic",
  FontColor->GrayLevel[0]],
 StyleBox[" where each player is dealt a hand of thirteen cards, a little bit \
too many to handle without any loops. The ", "Text",
  FontSize->14,
  FontColor->GrayLevel[0]],
 StyleBox["Milton Work point count", "Text",
  FontSize->14,
  FontSlant->"Italic",
  FontColor->GrayLevel[0]],
 StyleBox[", the rudimentary (but surprisingly effective when compared to its \
almost silly simplicity) hand evaluation scheme that every beginning bridge \
player learns during the first couple of introductory bridge lessons, assigns \
each ace a work point value of 4, each king a work point value of 3, each \
queen a work point value of 2, and each jack a work point value of 1. Nothing \
else matters, although some people also count the tens as half points. The \
shape of the hand otherwise does not matter for this point count, since a \
beginning player could not reason anything about the playing potential of the \
hand based on its the shape anyway, especially when this reasoning has to be \
executed in the context of the current bidding so far. The first question of \
this week\[CloseCurlyQuote]s lab asks the student to write a method to \
compute the work point count of the given bridge hand.", "Text",
  FontSize->14,
  FontColor->GrayLevel[0]]
}], "Text",
 CellChangeTimes->{
  3.7330581739446163`*^9, {3.733072640228917*^9, 3.733072727785676*^9}, {
   3.7332201908533983`*^9, 3.733220204769639*^9}, {3.733272349967442*^9, 
   3.733272425133947*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"pointValue", "[", "\"\<A\>\"", "]"}], " ", ":=", " ", "4"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"pointValue", "[", "\"\<K\>\"", "]"}], " ", ":=", " ", "3"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"pointValue", "[", "\"\<Q\>\"", "]"}], " ", ":=", " ", "2"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"pointValue", "[", "\"\<J\>\"", "]"}], " ", ":=", " ", "1"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"pointValue", "[", 
    RowBox[{"r_", " ", "/;", " ", 
     RowBox[{
      RowBox[{"StringLength", "[", "r", "]"}], " ", "\[Equal]", " ", "1"}]}], 
    "]"}], " ", ":=", " ", "0"}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"pointValue", "[", 
    RowBox[{"hand_", " ", "/;", " ", 
     RowBox[{
      RowBox[{"StringLength", "[", "hand", "]"}], " ", ">", " ", "1"}]}], 
    "]"}], " ", ":=", " ", 
   RowBox[{"Plus", " ", "@@", " ", 
    RowBox[{"Map", "[", 
     RowBox[{"pointValue", ",", " ", 
      RowBox[{"Characters", "[", "hand", "]"}]}], "]"}]}]}], ";"}]}], "Input",\

 CellChangeTimes->{{3.732804912486094*^9, 3.732805019886746*^9}, {
   3.732805089107657*^9, 3.732805133100934*^9}, {3.7328052954849777`*^9, 
   3.73280533339501*^9}, {3.732805377302248*^9, 3.7328053866997547`*^9}, 
   3.7328054424276342`*^9, {3.732805523148078*^9, 3.732805525786717*^9}, {
   3.732805624390169*^9, 3.7328056254778833`*^9}},
 FontSize->14],

Cell[TextData[{
 "There are a little bit too many thirteen card hands for us to count through \
them all, but random sampling of 100,000 bridge hands should give us a \
reasonable estimate of the average point count of a bridge hand, which should \
naturally be 10, since the fixed 40 work points in the deck are divided over \
four players. While we are at it, we can also calculate the ",
 StyleBox["standard deviation",
  FontSlant->"Italic"],
 " of this distribution of points, and count how often the player is dealt a ",
 StyleBox["yarborough",
  FontSlant->"Italic"],
 ", that is, a hand without any aces or faces. (Technically, a proper \
yarborough does not contain any tens, but they would not affect our simple \
point count anyway.)"
}], "Text",
 CellChangeTimes->{{3.732805024220941*^9, 3.732805078491115*^9}, {
  3.7328051743220654`*^9, 3.7328051772578173`*^9}, {3.732805695276618*^9, 
  3.7328057765094633`*^9}, {3.7328065389906797`*^9, 3.7328065641341743`*^9}, {
  3.732812487089189*^9, 3.73281251792782*^9}, {3.7329728370042343`*^9, 
  3.732972849361374*^9}, {3.7330728395602913`*^9, 3.7330728739671783`*^9}, {
  3.7332202397304983`*^9, 3.73322024023239*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"bridgeHand", " ", ":=", " ", 
   RowBox[{"StringJoin", "[", 
    RowBox[{"RandomSample", "[", 
     RowBox[{"deck", ",", " ", "13"}], "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"workSamples", " ", "=", " ", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{"pointValue", "[", "bridgeHand", "]"}], ",", " ", 
     RowBox[{"{", 
      RowBox[{"i", ",", " ", "1", ",", "100000"}], "}"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"{", 
  RowBox[{
   RowBox[{"N", "[", 
    RowBox[{
     RowBox[{"Mean", "[", "workSamples", "]"}], ",", "5"}], "]"}], ",", 
   RowBox[{"N", "[", 
    RowBox[{
     RowBox[{"StandardDeviation", "[", "workSamples", "]"}], ",", "5"}], 
    "]"}], ",", 
   RowBox[{"N", "[", 
    RowBox[{
     RowBox[{
      RowBox[{"Count", "[", 
       RowBox[{"workSamples", ",", " ", "0"}], "]"}], " ", "/", " ", 
      "100000"}], ",", "5"}], "]"}]}], "}"}]}], "Input",
 CellChangeTimes->{{3.732805182474616*^9, 3.732805274110655*^9}, {
   3.732805403361833*^9, 3.7328054132435427`*^9}, {3.7328055428477697`*^9, 
   3.7328056066972322`*^9}, {3.732805644799932*^9, 3.7328057225111027`*^9}, 
   3.732805760884379*^9, {3.732806566446907*^9, 3.7328065971261253`*^9}, {
   3.732812472826771*^9, 3.73281247533664*^9}, {3.732812524480349*^9, 
   3.732812533487452*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
  "10.00546`5.", ",", "4.11079301042897876500903554505621290387`5.", ",", 
   "0.00359`5."}], "}"}]], "Output",
 CellChangeTimes->{
  3.732805803909471*^9, {3.732806592342823*^9, 3.732806610190503*^9}, 
   3.732823573154245*^9, 3.7329705142104473`*^9, 3.7330508869534073`*^9, 
   3.733051305879449*^9, 3.73305788662012*^9, 3.733065871379719*^9, 
   3.733074085924425*^9, 3.733074253116143*^9, 3.733080055154468*^9, 
   3.7331254515391417`*^9, 3.733128331529799*^9, 3.733133389372703*^9, 
   3.733210946783556*^9, 3.73321266440974*^9, 3.733212958542362*^9, 
   3.733216073099627*^9, 3.7332162293137407`*^9, 3.73322191963727*^9, 
   3.7332699965166388`*^9, 3.733277805754389*^9},
 FontSize->14]
}, Open  ]],

Cell["\<\
In fact, we can now easily find out from those sample hands what portion of \
them contain some particular number of work points.\
\>", "Text",
 CellChangeTimes->{
  3.73280578367738*^9, {3.73280620642808*^9, 3.732806209499935*^9}, {
   3.732806299995981*^9, 3.732806302490711*^9}, {3.7328064242005672`*^9, 
   3.732806440872087*^9}, {3.7328065229761677`*^9, 3.732806535502472*^9}, {
   3.7328066140294237`*^9, 3.732806619453465*^9}, {3.7328125457536993`*^9, 
   3.732812576174129*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"pointDist", " ", "=", " ", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{"N", "[", 
      RowBox[{
       RowBox[{"Count", "[", 
        RowBox[{"workSamples", ",", " ", "k"}], "]"}], " ", "/", " ", 
       RowBox[{"Length", "[", "workSamples", "]"}]}], "]"}], ",", " ", 
     RowBox[{"{", 
      RowBox[{"k", ",", " ", "0", ",", " ", "30"}], "}"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"BarChart", "[", 
  RowBox[{"pointDist", ",", 
   RowBox[{"BarSpacing", " ", "\[Rule]", " ", "0.8"}], ",", " ", 
   RowBox[{"ChartLabels", " ", "\[Rule]", " ", 
    RowBox[{"Table", "[", 
     RowBox[{"k", ",", " ", 
      RowBox[{"{", 
       RowBox[{"k", ",", " ", "0", ",", " ", "30"}], "}"}]}], "]"}]}], ",", 
   " ", 
   RowBox[{"ChartStyle", " ", "\[Rule]", " ", "\"\<LakeColors\>\""}]}], 
  "]"}]}], "Input",
 CellChangeTimes->{{3.732805834067937*^9, 3.732805872017988*^9}, {
   3.732805925850425*^9, 3.73280598664017*^9}, {3.7328060172333107`*^9, 
   3.7328060410716753`*^9}, {3.732806086576067*^9, 3.732806119358436*^9}, {
   3.732806166950807*^9, 3.732806194508957*^9}, {3.732806235261991*^9, 
   3.732806237147954*^9}, {3.732806312164798*^9, 3.732806312359481*^9}, {
   3.732806414506826*^9, 3.732806417670239*^9}, {3.732806457154253*^9, 
   3.732806517088128*^9}, 3.732812451071577*^9, {3.732813221341879*^9, 
   3.732813221903255*^9}, {3.733041449323324*^9, 3.7330414502975607`*^9}, {
   3.733271282434628*^9, 3.733271282838867*^9}},
 FontSize->14],

Cell[BoxData[
 GraphicsBox[{
   {Opacity[0], PointBox[{0.11111111111111116`, 0.}]}, {{}, 
    {RGBColor[0.982864, 0.7431472, 0.3262672], EdgeForm[{Opacity[
     0.48299999999999993`], Thickness[Small]}], 
     {RGBColor[0.293416, 0.0574044, 0.529412], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{0.7222222222222223, 0.}, {1.277777777777778, 
            0.00359}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{21.06374606736076, 27.308650162688746`}, {
           95.73929540668439, 103.74000000000001`}}],
         StatusArea[#, 0.00359]& ,
         TagBoxNote->"0.00359"],
        StyleBox["0.00359`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.00359, {}], "Tooltip"]& ]}, 
     {RGBColor[0.32045650000000003`, 0.10442045999999999`, 0.5674207], 
      EdgeForm[{Opacity[0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{1.7222222222222223`, 0.}, {2.2777777777777777`, 
            0.00805}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{31.656573438951106`, 37.90147753427909}, {
           86.24694373922264, 103.74000000000001`}}],
         StatusArea[#, 0.00805]& ,
         TagBoxNote->"0.00805"],
        StyleBox["0.00805`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.00805, {}], "Tooltip"]& ]}, 
     {RGBColor[0.347497, 0.15143652, 0.6054294], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{2.7222222222222223`, 0.}, {3.2777777777777777`, 
            0.01349}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{42.24940081054145, 48.494304905869434`}, {
           74.66882870088365, 103.74000000000001`}}],
         StatusArea[#, 0.01349]& ,
         TagBoxNote->"0.01349"],
        StyleBox["0.01349`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.01349, {}], "Tooltip"]& ]}, 
     {RGBColor[0.3745375, 0.19845258, 0.6434381], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{3.7222222222222223`, 0.}, {4.277777777777778, 
            0.02419}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{52.8422281821318, 59.08713227745978}, {
           51.8956980188566, 103.74000000000001`}}],
         StatusArea[#, 0.02419]& ,
         TagBoxNote->"0.02419"],
        StyleBox["0.02419`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.02419, {}], "Tooltip"]& ]}, 
     {RGBColor[0.401578, 0.24546864, 0.6814468], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{4.722222222222222, 0.}, {5.277777777777778, 0.03787},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{63.435055553722144`, 69.67995964905013}, {
           22.780144025386505`, 103.74000000000001`}}],
         StatusArea[#, 0.03787]& ,
         TagBoxNote->"0.03787"],
        StyleBox["0.03787`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.03787, {}], "Tooltip"]& ]}, 
     {RGBColor[0.4286185, 0.2924847, 0.7194555], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{5.722222222222222, 0.}, {6.277777777777778, 0.05096},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{74.0278829253125, 
           80.27278702064045}, {-5.07969528561668, 103.74000000000001`}}],
         StatusArea[#, 0.05096]& ,
         TagBoxNote->"0.05096"],
        StyleBox["0.05096`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.05096, {}], "Tooltip"]& ]}, 
     {RGBColor[0.45565900000000004`, 0.33950076, 0.7574642], EdgeForm[{
      Opacity[0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{6.722222222222222, 0.}, {7.277777777777778, 0.06512},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{84.62071029690284, 
           90.8656143922308}, {-35.21684766482258, 103.74000000000001`}}],
         StatusArea[#, 0.06512]& ,
         TagBoxNote->"0.06512"],
        StyleBox["0.06512`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.06512, {}], "Tooltip"]& ]}, 
     {RGBColor[0.48269950000000006`, 0.38651682, 0.7954729], EdgeForm[{
      Opacity[0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{7.722222222222222, 0.}, {8.277777777777779, 0.08045},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{95.21353766849319, 
           101.45844176382116`}, {-67.84414610925947, 103.74000000000001`}}],
         StatusArea[#, 0.08045]& ,
         TagBoxNote->"0.08045"],
        StyleBox["0.08045`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.08045, {}], "Tooltip"]& ]}, 
     {RGBColor[0.50974, 0.43353288, 0.8334816], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{8.722222222222223, 0.}, {9.277777777777779, 0.08858},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{105.80636504008353`, 
           112.0512691354115}, {-85.14746876765949, 103.74000000000001`}}],
         StatusArea[#, 0.08858]& ,
         TagBoxNote->"0.08858"],
        StyleBox["0.08858`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.08858, {}], "Tooltip"]& ]}, 
     {RGBColor[0.5367805, 0.48054894, 0.8714903], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{9.722222222222223, 0.}, {10.277777777777779`, 
            0.09304}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{116.39919241167388`, 
           122.64409650700185`}, {-94.63982043512121, 103.74000000000001`}}],
         StatusArea[#, 0.09304]& ,
         TagBoxNote->"0.09304"],
        StyleBox["0.09304`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.09304, {}], "Tooltip"]& ]}, 
     {RGBColor[0.563821, 0.527565, 0.909499], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{10.722222222222223`, 0.}, {11.277777777777779`, 
            0.09473}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{126.99201978326423`, 
           133.23692387859222`}, {-98.23669808489933, 103.74000000000001`}}],
         StatusArea[#, 0.09473]& ,
         TagBoxNote->"0.09473"],
        StyleBox["0.09473`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.09473, {}], "Tooltip"]& ]}, 
     {RGBColor[0.583702, 0.5595083, 0.9099522], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{11.722222222222223`, 0.}, {12.277777777777779`, 
            0.09183}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{137.58484715485457`, 
           143.82975125018257`}, {-92.0645411710789, 103.74000000000001`}}],
         StatusArea[#, 0.09183]& ,
         TagBoxNote->"0.09183"],
        StyleBox["0.09183`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.09183, {}], "Tooltip"]& ]}, 
     {RGBColor[0.603583, 0.5914516, 0.9104053999999999], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{12.722222222222223`, 0.}, {13.277777777777779`, 
            0.08232}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{148.17767452644492`, 
           154.4225786217729}, {-71.82412315368853, 103.74000000000001`}}],
         StatusArea[#, 0.08232]& ,
         TagBoxNote->"0.08232"],
        StyleBox["0.08232`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.08232, {}], "Tooltip"]& ]}, 
     {RGBColor[0.623464, 0.6233949, 0.9108586], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{13.722222222222223`, 0.}, {14.277777777777779`, 
            0.06872}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{158.77050189803526`, 
           165.01540599336326`}, {-42.87883555784106, 103.74000000000001`}}],
         StatusArea[#, 0.06872]& ,
         TagBoxNote->"0.06872"],
        StyleBox["0.06872`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.06872, {}], "Tooltip"]& ]}, 
     {RGBColor[0.643345, 0.6553382, 0.9113118], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{14.722222222222223`, 0.}, {15.277777777777779`, 
            0.05725}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{169.3633292696256, 
           175.6082333649536}, {-18.46689079869614, 103.74000000000001`}}],
         StatusArea[#, 0.05725]& ,
         TagBoxNote->"0.05725"],
        StyleBox["0.05725`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.05725, {}], "Tooltip"]& ]}, 
     {RGBColor[0.663226, 0.6872815, 0.9117649999999999], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{15.722222222222223`, 0.}, {16.27777777777778, 
            0.04435}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{179.95615664121596`, 186.20106073654395`}, {
           8.988565817953287, 103.74000000000001`}}],
         StatusArea[#, 0.04435]& ,
         TagBoxNote->"0.04435"],
        StyleBox["0.04435`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.04435, {}], "Tooltip"]& ]}, 
     {RGBColor[0.683107, 0.7192248, 0.9122182], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{16.72222222222222, 0.}, {17.27777777777778, 0.03231},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{190.54898401280627`, 196.7938881081343}, {
           34.613658660159444`, 103.74000000000001`}}],
         StatusArea[#, 0.03231]& ,
         TagBoxNote->"0.03231"],
        StyleBox["0.03231`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.03231, {}], "Tooltip"]& ]}, 
     {RGBColor[0.702988, 0.7511681, 0.9126714], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{17.72222222222222, 0.}, {18.27777777777778, 0.02242},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{201.14181138439662`, 207.38671547972464`}, {
           55.66284206625734, 103.74000000000001`}}],
         StatusArea[#, 0.02242]& ,
         TagBoxNote->"0.02242"],
        StyleBox["0.02242`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.02242, {}], "Tooltip"]& ]}, 
     {RGBColor[0.722869, 0.7831114, 0.9131246000000001], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{18.72222222222222, 0.}, {19.27777777777778, 0.01572},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{211.73463875598696`, 217.979542851315}, {
           69.92265286715279, 103.74000000000001`}}],
         StatusArea[#, 0.01572]& ,
         TagBoxNote->"0.01572"],
        StyleBox["0.01572`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.01572, {}], "Tooltip"]& ]}, 
     {RGBColor[0.7427499999999999, 0.8150547, 0.9135778], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{19.72222222222222, 0.}, {20.27777777777778, 0.01069},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{222.3274661275773, 228.57237022290533`}, {
           80.62815261767578, 103.74000000000001`}}],
         StatusArea[#, 0.01069]& ,
         TagBoxNote->"0.01069"],
        StyleBox["0.01069`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.01069, {}], "Tooltip"]& ]}, 
     {RGBColor[0.762631, 0.846998, 0.914031], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{20.72222222222222, 0.}, {21.27777777777778, 0.00628},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{232.92029349916766`, 239.16519759449568`}, {
           90.01408778662338, 103.74000000000001`}}],
         StatusArea[#, 0.00628]& ,
         TagBoxNote->"0.00628"],
        StyleBox["0.00628`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.00628, {}], "Tooltip"]& ]}, 
     {RGBColor[0.7804854999999999, 0.852952, 0.9060322000000001], EdgeForm[{
      Opacity[0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{21.72222222222222, 0.}, {22.27777777777778, 0.00378},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{243.513120870758, 249.75802496608603`}, {
           95.33491271233063, 103.74000000000001`}}],
         StatusArea[#, 0.00378]& ,
         TagBoxNote->"0.00378"],
        StyleBox["0.00378`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.00378, {}], "Tooltip"]& ]}, 
     {RGBColor[0.7983399999999999, 0.8589060000000001, 0.8980334], EdgeForm[{
      Opacity[0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{22.72222222222222, 0.}, {23.27777777777778, 0.00224},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{254.10594824234835`, 260.3508523376764}, {
           98.6125408665663, 103.74000000000001`}}],
         StatusArea[#, 0.00224]& ,
         TagBoxNote->"0.00224"],
        StyleBox["0.00224`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.00224, {}], "Tooltip"]& ]}, 
     {RGBColor[0.8161944999999999, 0.86486, 0.8900346], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{23.72222222222222, 0.}, {24.27777777777778, 0.00115},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{264.6987756139387, 270.94367970926675`}, {
           100.93242053417467`, 103.74000000000001`}}],
         StatusArea[#, 0.00115]& ,
         TagBoxNote->"0.00115"],
        StyleBox["0.00115`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.00115, {}], "Tooltip"]& ]}, 
     {RGBColor[0.8340489999999999, 0.870814, 0.8820358], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{24.72222222222222, 0.}, {25.27777777777778, 0.00052},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{275.2916029855291, 281.53650708085706`}, {
           102.2732684154529, 103.74000000000001`}}],
         StatusArea[#, 0.00052]& ,
         TagBoxNote->"0.00052"],
        StyleBox["0.00052`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.00052, {}], "Tooltip"]& ]}, 
     {RGBColor[0.8519034999999999, 0.876768, 0.874037], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           RectangleBox[{25.72222222222222, 0.}, {26.27777777777778, 0.00021},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{285.8844303571194, 292.12933445244744`}, {
           102.9330507062406, 103.74000000000001`}}],
         StatusArea[#, 0.00021]& ,
         TagBoxNote->"0.00021"],
        StyleBox["0.00021`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.00021, {}], "Tooltip"]& ]}, 
     {RGBColor[0.869758, 0.882722, 0.8660382], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{26.72222222222222, 0.}, {27.27777777777778, 0.0001}, 
            "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{296.4772577287098, 302.72216182403776`}, {
           103.16716700297172`, 103.74000000000001`}}],
         StatusArea[#, 0.0001]& ,
         TagBoxNote->"0.0001"],
        StyleBox["0.0001`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.0001, {}], "Tooltip"]& ]}, 
     {RGBColor[0.8876125, 0.888676, 0.8580394], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{27.72222222222222, 0.}, {28.27777777777778, 0.00002},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{307.0700851003001, 313.31498919562813`}, {
           103.33743340059435`, 103.74000000000001`}}],
         StatusArea[#, 0.00002]& ,
         TagBoxNote->"0.00002"],
        StyleBox["0.00002`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.00002, {}], "Tooltip"]& ]}, 
     {RGBColor[0.905467, 0.8946299999999999, 0.8500406], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{28.72222222222222, 0.}, {29.27777777777778, 0.}, 
            "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{317.6629124718905, 323.90781656721845`}, {
           103.38000000000001`, 103.74000000000001`}}],
         StatusArea[#, 0.]& ,
         TagBoxNote->"0."],
        StyleBox["0.`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0., {}], "Tooltip"]& ]}, 
     {RGBColor[0.9233215, 0.9005839999999999, 0.8420418], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{29.72222222222222, 0.}, {30.27777777777778, 0.00002},
             "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{328.2557398434808, 334.5006439388088}, {
           103.33743340059435`, 103.74000000000001`}}],
         StatusArea[#, 0.00002]& ,
         TagBoxNote->"0.00002"],
        StyleBox["0.00002`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.00002, {}], "Tooltip"]& ]}, 
     {RGBColor[0.941176, 0.906538, 0.834043], EdgeForm[{Opacity[
      0.48299999999999993`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{30.72222222222222, 0.}, {31.27777777777778, 0.}, 
            "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{338.84856721507117`, 345.09347131039914`}, {
           103.38000000000001`, 103.74000000000001`}}],
         StatusArea[#, 0.]& ,
         TagBoxNote->"0."],
        StyleBox["0.`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0., {}], "Tooltip"]& ]}}, {}, {}}, {}, {}, 
   StyleBox[
    StyleBox[{
      {Thickness[Tiny], 
       LineBox[{{0.11111111111111116`, 0.}, {31.901111111111113`, 0.}}], 
       StyleBox[{}, "GraphicsLabel",
        StripOnInput->False]}, 
      StyleBox[{
        {Thickness[Tiny], 
         LineBox[{{0.7222222222222222, 0.}, 
           Offset[{-1.102182119232618*^-15, -6.}, {0.7222222222222222, 0.}]}],
          LineBox[{{31.27777777777778, 0.}, 
           Offset[{-1.102182119232618*^-15, -6.}, {31.27777777777778, 
            0.}]}], {{}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, \
{}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {
           LineBox[{{1.2777777777777777`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {1.2777777777777777`, 
              0.}]}], LineBox[{{1.7222222222222223`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {1.7222222222222223`, 
              0.}]}], LineBox[{{2.2777777777777777`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {2.2777777777777777`, 
              0.}]}], LineBox[{{2.722222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {2.722222222222222, 
              0.}]}], LineBox[{{3.2777777777777777`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {3.2777777777777777`, 
              0.}]}], LineBox[{{3.7222222222222223`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {3.7222222222222223`, 
              0.}]}], LineBox[{{4.277777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {4.277777777777778, 
              0.}]}], 
           LineBox[{{4.722222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {4.722222222222222, 
              0.}]}], LineBox[{{5.277777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {5.277777777777778, 
              0.}]}], LineBox[{{5.722222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {5.722222222222222, 
              0.}]}], LineBox[{{6.277777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {6.277777777777778, 
              0.}]}], LineBox[{{6.722222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {6.722222222222222, 
              0.}]}], LineBox[{{7.277777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {7.277777777777778, 
              0.}]}], LineBox[{{7.722222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {7.722222222222222, 
              0.}]}], LineBox[{{8.277777777777779, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {8.277777777777779, 
              0.}]}], LineBox[{{8.722222222222221, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {8.722222222222221, 
              0.}]}], LineBox[{{9.277777777777777, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {9.277777777777777, 
              0.}]}], LineBox[{{9.722222222222221, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {9.722222222222221, 
              0.}]}], LineBox[{{10.277777777777777`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {10.277777777777777`, 
              0.}]}], LineBox[{{10.722222222222221`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {10.722222222222221`, 
              0.}]}], LineBox[{{11.277777777777777`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {11.277777777777777`, 
              0.}]}], LineBox[{{11.722222222222221`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {11.722222222222221`, 
              0.}]}], LineBox[{{12.277777777777777`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {12.277777777777777`, 
              0.}]}], LineBox[{{12.722222222222221`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {12.722222222222221`, 
              0.}]}], LineBox[{{13.277777777777777`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {13.277777777777777`, 
              0.}]}], LineBox[{{13.722222222222221`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {13.722222222222221`, 
              0.}]}], LineBox[{{14.277777777777777`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {14.277777777777777`, 
              0.}]}], LineBox[{{14.722222222222221`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {14.722222222222221`, 
              0.}]}], LineBox[{{15.277777777777777`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {15.277777777777777`, 
              0.}]}], LineBox[{{15.722222222222221`, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {15.722222222222221`, 
              0.}]}], LineBox[{{16.27777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {16.27777777777778, 
              0.}]}], LineBox[{{16.72222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {16.72222222222222, 
              0.}]}], LineBox[{{17.27777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {17.27777777777778, 
              0.}]}], LineBox[{{17.72222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {17.72222222222222, 
              0.}]}], LineBox[{{18.27777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {18.27777777777778, 
              0.}]}], LineBox[{{18.72222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {18.72222222222222, 
              0.}]}], LineBox[{{19.27777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {19.27777777777778, 
              0.}]}], LineBox[{{19.72222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {19.72222222222222, 
              0.}]}], LineBox[{{20.27777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {20.27777777777778, 
              0.}]}], LineBox[{{20.72222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {20.72222222222222, 
              0.}]}], LineBox[{{21.27777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {21.27777777777778, 
              0.}]}], LineBox[{{21.72222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {21.72222222222222, 
              0.}]}], LineBox[{{22.27777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {22.27777777777778, 
              0.}]}], LineBox[{{22.72222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {22.72222222222222, 
              0.}]}], 
           LineBox[{{23.27777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {23.27777777777778, 
              0.}]}], LineBox[{{23.72222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {23.72222222222222, 
              0.}]}], LineBox[{{24.27777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {24.27777777777778, 
              0.}]}], LineBox[{{24.72222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {24.72222222222222, 
              0.}]}], LineBox[{{25.27777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {25.27777777777778, 
              0.}]}], LineBox[{{25.72222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {25.72222222222222, 
              0.}]}], LineBox[{{26.27777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {26.27777777777778, 
              0.}]}], LineBox[{{26.72222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {26.72222222222222, 
              0.}]}], LineBox[{{27.27777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {27.27777777777778, 
              0.}]}], LineBox[{{27.72222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {27.72222222222222, 
              0.}]}], LineBox[{{28.27777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {28.27777777777778, 
              0.}]}], LineBox[{{28.72222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {28.72222222222222, 
              0.}]}], LineBox[{{29.27777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {29.27777777777778, 
              0.}]}], LineBox[{{29.72222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {29.72222222222222, 
              0.}]}], LineBox[{{30.27777777777778, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {30.27777777777778, 
              0.}]}], LineBox[{{30.72222222222222, 0.}, 
             Offset[{-7.347880794884119*^-16, -4.}, {30.72222222222222, 
              0.}]}]}, {}}}, 
        StyleBox[
         {Thickness[Tiny], 
          InsetBox["0", Offset[{0., -2.}, {1., 0.}], {0, 1}, Automatic, {1, 
           0}], InsetBox["1", Offset[{0., -2.}, {2., 0.}], {0, 1}, 
           Automatic, {1, 0}], 
          InsetBox["2", Offset[{0., -2.}, {3., 0.}], {0, 1}, Automatic, {1, 
           0}], 
          InsetBox["3", Offset[{0., -2.}, {4., 0.}], {0, 1}, Automatic, {1, 
           0}], InsetBox["4", Offset[{0., -2.}, {5., 0.}], {0, 1}, 
           Automatic, {1, 0}], 
          InsetBox["5", Offset[{0., -2.}, {6., 0.}], {0, 1}, Automatic, {1, 
           0}], InsetBox["6", Offset[{0., -2.}, {7., 0.}], {0, 1}, 
           Automatic, {1, 0}], 
          InsetBox["7", Offset[{0., -2.}, {8., 0.}], {0, 1}, Automatic, {1, 
           0}], InsetBox["8", Offset[{0., -2.}, {9., 0.}], {0, 1}, 
           Automatic, {1, 0}], 
          InsetBox["9", Offset[{0., -2.}, {10., 0.}], {0, 1}, Automatic, {1, 
           0}], InsetBox["10", Offset[{0., -2.}, {11., 0.}], {0, 1}, 
           Automatic, {1, 0}], 
          InsetBox["11", Offset[{0., -2.}, {12., 0.}], {0, 1}, Automatic, {1, 
           0}], InsetBox["12", Offset[{0., -2.}, {13., 0.}], {0, 1}, 
           Automatic, {1, 0}], 
          InsetBox["13", Offset[{0., -2.}, {14., 0.}], {0, 1}, Automatic, {1, 
           0}], InsetBox["14", Offset[{0., -2.}, {15., 0.}], {0, 1}, 
           Automatic, {1, 0}], 
          InsetBox["15", Offset[{0., -2.}, {16., 0.}], {0, 1}, Automatic, {1, 
           0}], InsetBox["16", Offset[{0., -2.}, {17., 0.}], {0, 1}, 
           Automatic, {1, 0}], 
          InsetBox["17", Offset[{0., -2.}, {18., 0.}], {0, 1}, Automatic, {1, 
           0}], InsetBox["18", Offset[{0., -2.}, {19., 0.}], {0, 1}, 
           Automatic, {1, 0}], 
          InsetBox["19", Offset[{0., -2.}, {20., 0.}], {0, 1}, Automatic, {1, 
           0}], InsetBox["20", Offset[{0., -2.}, {21., 0.}], {0, 1}, 
           Automatic, {1, 0}], 
          InsetBox["21", Offset[{0., -2.}, {22., 0.}], {0, 1}, Automatic, {1, 
           0}], InsetBox["22", Offset[{0., -2.}, {23., 0.}], {0, 1}, 
           Automatic, {1, 0}], 
          InsetBox["23", Offset[{0., -2.}, {24., 0.}], {0, 1}, Automatic, {1, 
           0}], InsetBox["24", Offset[{0., -2.}, {25., 0.}], {0, 1}, 
           Automatic, {1, 0}], 
          InsetBox["25", Offset[{0., -2.}, {26., 0.}], {0, 1}, Automatic, {1, 
           0}], InsetBox["26", Offset[{0., -2.}, {27., 0.}], {0, 1}, 
           Automatic, {1, 0}], 
          InsetBox["27", Offset[{0., -2.}, {28., 0.}], {0, 1}, Automatic, {1, 
           0}], InsetBox["28", Offset[{0., -2.}, {29., 0.}], {0, 1}, 
           Automatic, {1, 0}], 
          InsetBox["29", Offset[{0., -2.}, {30., 0.}], {0, 1}, Automatic, {1, 
           0}], InsetBox["30", Offset[{0., -2.}, {31., 0.}], {0, 1}, 
           Automatic, {1, 0}]}, "GraphicsLabel",
         StripOnInput->False]}, "GraphicsTicks",
       StripOnInput->False]},
     Antialiasing->False], "GraphicsAxes",
    StripOnInput->False]},
  AspectRatio->NCache[GoldenRatio^(-1), 0.6180339887498948],
  Axes->{False, True},
  AxesLabel->{None, None},
  AxesOrigin->{0.11111111111111116`, 0.},
  CoordinatesToolOptions:>{"DisplayFunction" -> ({
      Identity[
       Part[#, 1]], 
      Identity[
       Part[#, 2]]}& ), "CopiedValueFunction" -> ({
      Identity[
       Part[#, 1]], 
      Identity[
       Part[#, 2]]}& )},
  FrameLabel->{{None, None}, {None, None}},
  FrameTicks->{{Automatic, Automatic}, {{{1., 
       FormBox["0", TraditionalForm], 0}, {2., 
       FormBox["1", TraditionalForm], 0}, {3., 
       FormBox["2", TraditionalForm], 0}, {4., 
       FormBox["3", TraditionalForm], 0}, {5., 
       FormBox["4", TraditionalForm], 0}, {6., 
       FormBox["5", TraditionalForm], 0}, {7., 
       FormBox["6", TraditionalForm], 0}, {8., 
       FormBox["7", TraditionalForm], 0}, {9., 
       FormBox["8", TraditionalForm], 0}, {10., 
       FormBox["9", TraditionalForm], 0}, {11., 
       FormBox["10", TraditionalForm], 0}, {12., 
       FormBox["11", TraditionalForm], 0}, {13., 
       FormBox["12", TraditionalForm], 0}, {14., 
       FormBox["13", TraditionalForm], 0}, {15., 
       FormBox["14", TraditionalForm], 0}, {16., 
       FormBox["15", TraditionalForm], 0}, {17., 
       FormBox["16", TraditionalForm], 0}, {18., 
       FormBox["17", TraditionalForm], 0}, {19., 
       FormBox["18", TraditionalForm], 0}, {20., 
       FormBox["19", TraditionalForm], 0}, {21., 
       FormBox["20", TraditionalForm], 0}, {22., 
       FormBox["21", TraditionalForm], 0}, {23., 
       FormBox["22", TraditionalForm], 0}, {24., 
       FormBox["23", TraditionalForm], 0}, {25., 
       FormBox["24", TraditionalForm], 0}, {26., 
       FormBox["25", TraditionalForm], 0}, {27., 
       FormBox["26", TraditionalForm], 0}, {28., 
       FormBox["27", TraditionalForm], 0}, {29., 
       FormBox["28", TraditionalForm], 0}, {30., 
       FormBox["29", TraditionalForm], 0}, {31., 
       FormBox["30", TraditionalForm], 0}}, Automatic}},
  GridLines->{None, None},
  GridLinesStyle->Directive[
    GrayLevel[0.5, 0.4]],
  ImageSize->{497.9609375, Automatic},
  PlotRange->{{All, All}, {All, All}},
  PlotRangePadding->{{
     Scaled[0.02], 
     Scaled[0.02]}, {
     Scaled[0.02], 
     Scaled[0.05]}},
  Ticks->{None, Automatic}]], "Output",
 CellChangeTimes->{{3.732805934933262*^9, 3.732805987399098*^9}, 
   3.7328060424601717`*^9, {3.732806099096129*^9, 3.7328061200390377`*^9}, {
   3.732806171339772*^9, 3.73280619514012*^9}, 3.732806418439608*^9, {
   3.732806458741459*^9, 3.7328065204484253`*^9}, 3.732823573982883*^9, 
   3.7329705149634323`*^9, 3.7330508877038116`*^9, 3.733051306690858*^9, 
   3.733057887407682*^9, 3.7330658722900553`*^9, 3.7330740868633204`*^9, 
   3.7330742540272427`*^9, 3.733080056097513*^9, 3.7331254527671213`*^9, 
   3.733128332560667*^9, 3.733133390161633*^9, 3.7332109484195547`*^9, 
   3.733212665435327*^9, 3.733212959327388*^9, 3.733216073874383*^9, 
   3.733216230060005*^9, 3.7332219205026617`*^9, 3.7332699972433*^9, 
   3.733277806613339*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "Question two of this week\[CloseCurlyQuote]s lab asks the player to compute \
the number of ",
 StyleBox["deadwood points",
  FontSlant->"Italic"],
 " in the game of ",
 StyleBox["gin rummy",
  FontSlant->"Italic"],
 " for the cards that remain in the hand after all possible discards to melds \
have been done. This lab also is the first one of many to drive in the idea \
that in programming, ",
 StyleBox["zero is always a possibility that all computations must be \
prepared for",
  FontSlant->"Italic"],
 ". The general principle that cannot be overemphasized is that ",
 StyleBox["whenever there is nothing to do, the only correct thing is to do \
nothing at all",
  FontSlant->"Italic"],
 ". This whole notion is counterintuitive to most people who are not \
programmers, since our systems and processes designed for the real world of \
humans tend to implicitly assume that there is always at least one of \
something for the operation to make sense to begin with. The author always \
likes to joke in the class at this point that if any of his students ever \
goes to a supermarket checkout lane with no groceries, pays zero dollars for \
the contents of his empty cart and receives a receipt for zero dollars before \
leaving, get a friend to surreptitiously video this transaction and post it \
on YouTube."
}], "Text",
 CellChangeTimes->{{3.7328063200592823`*^9, 3.7328063979046926`*^9}, {
  3.732806634743688*^9, 3.732806670308363*^9}, {3.732807020032551*^9, 
  3.732807027839127*^9}, {3.733041324290505*^9, 3.733041415072275*^9}, {
  3.733051534158926*^9, 3.733051588732675*^9}, {3.733072888220715*^9, 
  3.733072964044738*^9}, {3.733124537679125*^9, 3.733124566327146*^9}, {
  3.733220250187167*^9, 3.7332203684232197`*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"deadwood", "[", "\"\<\>\"", "]"}], " ", ":=", " ", "0"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"deadwood", "[", "\"\<A\>\"", "]"}], " ", ":=", " ", "1"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"deadwood", "[", "\"\<K\>\"", "]"}], " ", ":=", " ", "10"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"deadwood", "[", "\"\<Q\>\"", "]"}], " ", ":=", " ", "10"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"deadwood", "[", "\"\<J\>\"", "]"}], " ", ":=", " ", "10"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"deadwood", "[", "\"\<T\>\"", "]"}], " ", ":=", " ", "10"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"deadwood", "[", 
    RowBox[{"r_", " ", "/;", " ", 
     RowBox[{
      RowBox[{"StringLength", "[", "r", "]"}], " ", "\[Equal]", " ", "1"}]}], 
    "]"}], " ", ":=", " ", 
   RowBox[{"If", "[", 
    RowBox[{
     RowBox[{"DigitQ", "[", "r", "]"}], ",", " ", 
     RowBox[{"ToExpression", "[", "r", "]"}], ",", " ", "0"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"deadwood", "[", 
    RowBox[{"hand_", " ", "/;", " ", 
     RowBox[{
      RowBox[{"StringLength", "[", "hand", "]"}], " ", ">", " ", "1"}]}], 
    "]"}], " ", ":=", " ", 
   RowBox[{"Plus", " ", "@@", " ", 
    RowBox[{"Map", "[", 
     RowBox[{"deadwood", ",", " ", 
      RowBox[{"Characters", "[", "hand", "]"}]}], "]"}]}]}], ";"}]}], "Input",\

 CellChangeTimes->{{3.732806673765937*^9, 3.7328067451156673`*^9}, {
  3.732806812932036*^9, 3.732806816706704*^9}, {3.732806916634472*^9, 
  3.7328070061708937`*^9}},
 FontSize->14],

Cell[TextData[{
 "Question three goes back to the game of contract bridge and asks the \
student to generate the shape of the hand by listing how many spades, hearts, \
diamonds and clubs the hand contains, in this order. In the original \
question, the answer must be given as a string where these counts are \
separated with commas. However, here in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " we now return the answer as a list, because a list can always be converted \
to a string if desired using ",
 StyleBox["StringJoin",
  FontWeight->"Bold"],
 ", and we wish to next perform another interesting computation on bridge \
hand shapes that would require a conversion to a list anyway."
}], "Text",
 CellChangeTimes->{{3.7328070440717907`*^9, 3.732807084669592*^9}, {
  3.732807555982766*^9, 3.7328075813424063`*^9}, {3.732826986719822*^9, 
  3.732826990784379*^9}, {3.733042430850047*^9, 3.733042529919931*^9}, {
  3.7330426591809273`*^9, 3.733042670685479*^9}, {3.733072982893188*^9, 
  3.733072986620431*^9}, {3.733124581371662*^9, 3.733124601350799*^9}, {
  3.733220384528283*^9, 3.733220384950193*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"handShape", "[", "hand_", "]"}], " ", ":=", " ", 
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{"StringCount", "[", 
      RowBox[{"hand", ",", "suit"}], "]"}], ",", " ", 
     RowBox[{"{", 
      RowBox[{"suit", ",", " ", "suits"}], "}"}]}], "]"}]}], ";"}]], "Input",
 CellChangeTimes->{{3.732807092944737*^9, 3.732807170429429*^9}, {
  3.732807444300784*^9, 3.732807476168873*^9}, {3.732807549617366*^9, 
  3.732807550313279*^9}, {3.732807614521646*^9, 3.732807616022505*^9}, {
  3.7328076794151907`*^9, 3.732807687654953*^9}, {3.733041509065761*^9, 
  3.7330416097582207`*^9}, {3.733041639832047*^9, 3.733041644575551*^9}, {
  3.733042195182325*^9, 3.7330421962847567`*^9}, {3.733042345460219*^9, 
  3.7330423472344847`*^9}, {3.7330424537903547`*^9, 3.733042463702175*^9}},
 FontSize->14],

Cell[TextData[{
 "We can now go above and beyond the Java programming lab and estimate the \
probabilities of getting dealt some particular hand shape patterns where the \
order of suits does not matter. Sorting the hand shapes before using ",
 StyleBox["Gather",
  FontWeight->"Bold"],
 " to create a list of sublists of equal shapes eliminates the suit order. \
Each sublist of equal shapes is then turned into a rule whose left side is \
the shape and the right side is the length of that sublist. The estimates \
computed from 200,000 sample hands are pretty close to those given on the \
Wikipedia page \[OpenCurlyDoubleQuote]",
 ButtonBox["Contract Bridge Probabilities",
  BaseStyle->"Hyperlink",
  ButtonData->{
    URL["https://en.wikipedia.org/wiki/Contract_bridge_probabilities"], None},
  
  ButtonNote->"https://en.wikipedia.org/wiki/Contract_bridge_probabilities"],
 "\[CloseCurlyDoubleQuote]. As is conventional in bridge literature, the \
overall shape where the order of suits does not matter is denoted by using \
minus signs to separate the lengths of the suits. The following table shows \
the shapes ordered by their frequency over 200,000 sample hands. The second \
column gives the observed count of that shape over 200,000 generated sample \
hands, whereas the third column displays the exact expected count over that \
number of hand, the function ",
 StyleBox["exactShapeCount",
  FontWeight->"Bold"],
 " derived using some clever combinatorics taken from the web page \
\[OpenCurlyDoubleQuote]",
 ButtonBox["How to Calculate Bridge Suit Probabilities",
  BaseStyle->"Hyperlink",
  ButtonData->{
    URL["http://www.durangobill.com/BrSuitHowTo.html"], None},
  ButtonNote->"http://www.durangobill.com/BrSuitHowTo.html"],
 "\[CloseCurlyDoubleQuote] by \[OpenCurlyDoubleQuote]Durango Bill\
\[CloseCurlyDoubleQuote]. The fourth column then shows how many daily \
duplicate tournaments consisting of 26 hands each a bridge enthusiast would \
have to play on average before he is dealt a hand of the particular shape. As \
this computed table shows, 6-3-3-1 is the most frequent shape among the \
shapes that one literally does not expect to see every day."
}], "Text",
 CellChangeTimes->CompressedData["
1:eJxTTMoPSmViYGCQAGIQrR9/0N7swmvHH2b9ziB65udcbxB9yaIfTE8u2JwK
osWyL6aB6C8rX6wB0ZPkqteC6J6bqttBdOLfpv0g+lxI12kQzRL88iKIVvgV
eB9E/3O//hxEiyyUeQ+i92u/+gI2b4WNjyWQtu//EQqirdgj9e1A6v5eNwXR
Kcm32RyAdNPVr2C67EK8NYi2MfrpAKJfTOxxBdHX1kwA089nWXqBxXft8QXR
HB55ck5AWuqmnAKI/sXrXOkCpDsPPwDTFuzPu11B9muXTwLR9SL8em5A2sXY
A0xfKnI67AGkD+96chlEz/i37waINjm/9g6IXigQ8RxEf9p66iWIPmZ67zuI
7tj4GUxPErryD0Q/iDrI6gmkDR6fPB8Hcj979UUQDQA8ptNA
  "],
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"bridgeSamples", " ", "=", " ", "200000"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"exactShapeCount", "[", "shape_", "]"}], " ", ":=", " ", 
   RowBox[{
    RowBox[{"(", 
     RowBox[{
      RowBox[{"4", "!"}], " ", "*", " ", 
      RowBox[{
       RowBox[{"Times", "@@", 
        RowBox[{"Map", "[", 
         RowBox[{
          RowBox[{
           RowBox[{"Binomial", "[", 
            RowBox[{"13", ",", "#"}], "]"}], "&"}], " ", ",", "shape"}], 
         "]"}]}], " ", "/", " ", 
       RowBox[{"If", "[", 
        RowBox[{
         RowBox[{"MatchQ", "[", 
          RowBox[{"shape", ",", 
           RowBox[{"{", 
            RowBox[{"___", ",", "x_", ",", "___", ",", "x_", ",", "___"}], 
            "}"}]}], "]"}], ",", " ", "2", ",", " ", "1"}], "]"}]}]}], ")"}], 
    " ", "/", " ", 
    RowBox[{"If", "[", 
     RowBox[{
      RowBox[{"MatchQ", "[", 
       RowBox[{"shape", ",", " ", 
        RowBox[{"{", 
         RowBox[{
         "___", ",", "x_", ",", "___", ",", "x_", ",", "___", ",", "x_", ",", 
          "___"}], "}"}]}], "]"}], ",", " ", "3", ",", "1"}], "]"}]}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"handShapeList", " ", "=", 
   RowBox[{"Reverse", "[", 
    RowBox[{"SortBy", "[", " ", 
     RowBox[{
      RowBox[{"Map", "[", 
       RowBox[{
        RowBox[{
         RowBox[{"(", 
          RowBox[{"{", 
           RowBox[{
            RowBox[{"Row", "[", 
             RowBox[{
              RowBox[{"First", "[", "#", "]"}], ",", "\"\<-\>\""}], "]"}], 
            ",", 
            RowBox[{"Length", "[", "#", "]"}], ",", 
            RowBox[{"Round", "[", 
             RowBox[{"bridgeSamples", "*", 
              RowBox[{
               RowBox[{"exactShapeCount", "[", 
                RowBox[{"First", "[", "#", "]"}], "]"}], " ", "/", " ", 
               RowBox[{"Binomial", "[", 
                RowBox[{"52", ",", "13"}], "]"}]}]}], "]"}], ",", " ", 
            RowBox[{"N", "[", 
             RowBox[{"1", "/", 
              RowBox[{"(", 
               RowBox[{
                RowBox[{"(", 
                 RowBox[{
                  RowBox[{"Length", "[", "#", "]"}], "/", "bridgeSamples"}], 
                 ")"}], " ", "*", " ", "26"}], ")"}]}], "]"}]}], "}"}], ")"}],
          "&"}], ",", 
        RowBox[{"Gather", "[", 
         RowBox[{"Table", "[", 
          RowBox[{
           RowBox[{"Reverse", "[", 
            RowBox[{"Sort", "[", 
             RowBox[{"handShape", "[", "bridgeHand", "]"}], "]"}], "]"}], ",", 
           RowBox[{"{", 
            RowBox[{"i", ",", " ", "1", ",", " ", "bridgeSamples"}], "}"}]}], 
          "]"}], " ", "]"}]}], "]"}], ",", 
      RowBox[{
       RowBox[{"(", 
        RowBox[{"#", "[", 
         RowBox[{"[", "2", "]"}], "]"}], ")"}], "&"}]}], "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"TableForm", "[", 
   RowBox[{"handShapeList", ",", 
    RowBox[{"TableHeadings", " ", "\[Rule]", 
     RowBox[{"{", 
      RowBox[{"None", ",", " ", 
       RowBox[{"{", 
        RowBox[{
        "\"\<Shape\>\"", ",", " ", "\"\<Frequency\>\"", ",", "\"\<Exact\>\"", 
         ",", " ", "\"\<Daily duplicates needed\>\""}], "}"}]}], "}"}]}]}], 
   "]"}], " "}]}], "Input",
 CellChangeTimes->CompressedData["
1:eJwdxTtIQmEABlBRhGhICgpCF6PBKEkwbqmJFipSkCVB2MNIESKHKwimiAQO
RRRYIGEWDkUURjREU4J2sZc4BJlZU9CDzBoKB4WG7vcPhyO20WYHl8PhCFk4
6J43ULelvqfuZhO2P3ssmJpwO3Ddd+8cnmHCIfzlWzjG6/bJUxwp5pK4ZWv5
GnvbH/LYZEkU8KpTVMThpUwJy2s0cgX7XaeBwjKPXolnebUaLGWMelzRqA24
XuGUaNmjtrIUl/8KXfhK9Ur+fM/14IZUVYnpskCPxzPyIbwxkhzDvNYsuULH
pvCv64ZcnhYGsaqtg2x9Efh17Ia0lhwRUz4j+8WZdwW7ZMEQ3leb13CT2ryN
tc+ju1iSD8XxIX/wCEd13BO8Exs4x6l+wT2ZkZEXA49vWPTzQT7wbzJW9uF4
Io2r/MbLPfZsgCb/Ax8M5PA=
  "],
 FontSize->14],

Cell[BoxData[
 TagBox[
  TagBox[GridBox[{
     {
      TagBox["\<\"Shape\"\>",
       HoldForm], 
      TagBox["\<\"Frequency\"\>",
       HoldForm], 
      TagBox["\<\"Exact\"\>",
       HoldForm], 
      TagBox["\<\"Daily duplicates needed\"\>",
       HoldForm]},
     {
      TemplateBox[{"-","\"-\"","4","4","3","2"},
       "RowWithSeparators"], "43204", "43102", "0.17804619230413138`"},
     {
      TemplateBox[{"-","\"-\"","5","3","3","2"},
       "RowWithSeparators"], "30849", "31034", "0.24935355091924186`"},
     {
      TemplateBox[{"-","\"-\"","5","4","3","1"},
       "RowWithSeparators"], "25889", "25861", "0.2971264897179378`"},
     {
      TemplateBox[{"-","\"-\"","4","3","3","3"},
       "RowWithSeparators"], "21232", "21072", "0.362297837806504`"},
     {
      TemplateBox[{"-","\"-\"","5","4","2","2"},
       "RowWithSeparators"], "21049", "21159", "0.365447655105121`"},
     {
      TemplateBox[{"-","\"-\"","6","3","2","2"},
       "RowWithSeparators"], "11389", "11285", "0.6754155494167787`"},
     {
      TemplateBox[{"-","\"-\"","6","4","2","1"},
       "RowWithSeparators"], "9286", "9404", "0.8283768783445716`"},
     {
      TemplateBox[{"-","\"-\"","6","3","3","1"},
       "RowWithSeparators"], "6785", "6896", "1.1337225780851425`"},
     {
      TemplateBox[{"-","\"-\"","5","5","2","1"},
       "RowWithSeparators"], "6366", "6348", "1.2083423959013027`"},
     {
      TemplateBox[{"-","\"-\"","4","4","4","1"},
       "RowWithSeparators"], "5981", "5986", "1.2861240080768588`"},
     {
      TemplateBox[{"-","\"-\"","7","3","2","1"},
       "RowWithSeparators"], "3794", "3762", "2.0274928024005514`"},
     {
      TemplateBox[{"-","\"-\"","6","4","3","0"},
       "RowWithSeparators"], "2725", "2652", "2.8228652081863093`"},
     {
      TemplateBox[{"-","\"-\"","5","4","4","0"},
       "RowWithSeparators"], "2512", "2487", "3.0622243998040175`"},
     {
      TemplateBox[{"-","\"-\"","5","5","3","0"},
       "RowWithSeparators"], "1779", "1790", "4.323950361049855`"},
     {
      TemplateBox[{"-","\"-\"","6","5","1","1"},
       "RowWithSeparators"], "1332", "1411", "5.775005775005775`"},
     {
      TemplateBox[{"-","\"-\"","6","5","2","0"},
       "RowWithSeparators"], "1297", "1302", "5.930846331771543`"},
     {
      TemplateBox[{"-","\"-\"","7","2","2","2"},
       "RowWithSeparators"], "1056", "1026", "7.284382284382285`"},
     {
      TemplateBox[{"-","\"-\"","7","4","1","1"},
       "RowWithSeparators"], "791", "784", "9.724788485850432`"},
     {
      TemplateBox[{"-","\"-\"","7","4","2","0"},
       "RowWithSeparators"], "741", "723", "10.380982040901069`"},
     {
      TemplateBox[{"-","\"-\"","7","3","3","0"},
       "RowWithSeparators"], "500", "530", "15.384615384615385`"},
     {
      TemplateBox[{"-","\"-\"","8","2","2","1"},
       "RowWithSeparators"], "408", "385", "18.85369532428356`"},
     {
      TemplateBox[{"-","\"-\"","8","3","1","1"},
       "RowWithSeparators"], "237", "235", "32.45699448231094`"},
     {
      TemplateBox[{"-","\"-\"","7","5","1","0"},
       "RowWithSeparators"], "229", "217", "33.59086328518643`"},
     {
      TemplateBox[{"-","\"-\"","8","3","2","0"},
       "RowWithSeparators"], "214", "217", "35.94536304816678`"},
     {
      TemplateBox[{"-","\"-\"","6","6","1","0"},
       "RowWithSeparators"], "159", "145", "48.37929366231253`"},
     {
      TemplateBox[{"-","\"-\"","8","4","1","0"},
       "RowWithSeparators"], "111", "90", "69.3000693000693`"},
     {
      TemplateBox[{"-","\"-\"","9","2","1","1"},
       "RowWithSeparators"], "30", "36", "256.4102564102564`"},
     {
      TemplateBox[{"-","\"-\"","9","3","1","0"},
       "RowWithSeparators"], "18", "20", "427.35042735042737`"},
     {
      TemplateBox[{"-","\"-\"","9","2","2","0"},
       "RowWithSeparators"], "16", "16", "480.7692307692308`"},
     {
      TemplateBox[{"-","\"-\"","8","5","0","0"},
       "RowWithSeparators"], "10", "6", "769.2307692307693`"},
     {
      TemplateBox[{"-","\"-\"","7","6","0","0"},
       "RowWithSeparators"], "6", "11", "1282.051282051282`"},
     {
      TemplateBox[{"-","\"-\"","10","2","1","0"},
       "RowWithSeparators"], "2", "2", "3846.153846153846`"},
     {
      TemplateBox[{"-","\"-\"","9","4","0","0"},
       "RowWithSeparators"], "2", "2", "3846.153846153846`"},
     {
      TemplateBox[{"-","\"-\"","10","1","1","1"},
       "RowWithSeparators"], "1", "1", "7692.307692307692`"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxDividers->{
     "Columns" -> {{False}}, "ColumnsIndexed" -> {}, 
      "Rows" -> {False, True, {False}, False}, "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[2.0999999999999996`]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}],
   {None, OutputFormsDump`HeadedColumns}],
  Function[BoxForm`e$, 
   TableForm[
   BoxForm`e$, 
    TableHeadings -> {
     None, {"Shape", "Frequency", "Exact", 
       "Daily duplicates needed"}}]]]], "Output",
 CellChangeTimes->{
  3.733042265234283*^9, 3.7330423019433203`*^9, 3.733042350900029*^9, {
   3.733042572975527*^9, 3.733042603582987*^9}, 3.733042689102275*^9, {
   3.733042733063854*^9, 3.733042758198008*^9}, 3.733042876045032*^9, {
   3.733043031176059*^9, 3.733043040436109*^9}, 3.733047715057538*^9, {
   3.7330477833003683`*^9, 3.733047802342162*^9}, {3.733047854332786*^9, 
   3.7330478601342688`*^9}, 3.733050889249085*^9, 3.733051308284251*^9, 
   3.733057888930296*^9, {3.733061983534004*^9, 3.7330620017643642`*^9}, 
   3.7330620572117033`*^9, 3.7330620921251307`*^9, {3.733062177061593*^9, 
   3.733062217995592*^9}, 3.7330622616092777`*^9, 3.733062337875897*^9, 
   3.733062385626609*^9, 3.733065875823213*^9, 3.7330740906209717`*^9, 
   3.733074257665362*^9, 3.7330790820997972`*^9, {3.733079117816765*^9, 
   3.7330791354907*^9}, 3.733079175164657*^9, 3.733079405794401*^9, 
   3.733079534074979*^9, 3.733079567183694*^9, 3.7330797254713697`*^9, 
   3.733079877370788*^9, 3.733080059530867*^9, {3.733124659801566*^9, 
   3.733124687473686*^9}, 3.7331254564445143`*^9, 3.733128336179598*^9, 
   3.733133393210746*^9, 3.733210952795567*^9, 3.7332126685411253`*^9, 
   3.733212962325636*^9, 3.733216076928501*^9, 3.733216233085359*^9, 
   3.7332219240137787`*^9, 3.733270000296315*^9, 3.733277809822455*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "As was pointed out in item 46 of ",
 StyleBox["HAKMEM",
  FontSlant->"Italic"],
 ", the decades old collection of old-timey mathematical and programming \
tricks and general observations, the most probable bridge hand shape is \
4-4-3-2 instead of the intuitively more appealing 4-3-3-3, even though the \
latter shape is more evenly distributed. Also, as most bridge players should \
soon enough learn, to the first approximation this maximally balanced shape \
pretty much always plays about two work points worse than it would initially \
be expected to, an important stepping stone towards the general realization \
that a whole lot of other things matter hugely for the bridge hand than just \
the raw work points. The purpose of the bridge hand is to take enough tricks \
until the opponents take too many, and the work count is just a simple \
statistical estimate of the average power that may or may not be applicable \
to the current situation at hand.\nAnother similarly counterintuitive truth \
about bridge hand distributions is that an even number of missing cards is \
more likely to break unevenly into your two opponent\[CloseCurlyQuote]s hand \
than to break evenly between them. For example, six missing cards are more \
likely to break 4-2 than 3-3, which makes it often a better move to play for \
the ",
 StyleBox["finesse",
  FontSlant->"Italic"],
 " than the brute force ",
 StyleBox["drop",
  FontSlant->"Italic"],
 ". (Dealing out the cards one at the time, the 3-3 distribution can result \
only from the 3-2 or 2-3 distribution of the previous five cards, and the \
sixth card is equally likely to end up in either hand, giving both 4-2 and \
3-3 distributions an equal probability from these predecessor states. \
However, the 4-2 final distribution can also additionally emerge from the 4-1 \
and 1-4 distributions of the first five cards, both of which themselves have \
a nonzero probability and make the outcome of 3-3 impossible.)\nThe last \
question this week goes back to poker, asking for a method that recognizes \
whether the given five-card poker hand is a ",
 StyleBox["full house",
  FontSlant->"Italic"],
 ", that is, contains some three cards of equal rank and another pair of \
cards of some other rank. Without giving any hints, this question was \
intentionally intended to be a bit tricky, to force the students work out the \
necessary conditions and loops from various different possible ways. From the \
very beginning, the author emphasizes the importance of the idea that since \
all programming is really just a high level syntactic sugar for the \
fundamental foundation of ",
 StyleBox["propositional logic",
  FontSlant->"Italic"],
 ", it automatically follows from the properties of propositional logic \
formulas that whenever there is one way to solve some problem, there always \
exist many other, result-equivalent ways to solve that same problem. But in \
this document, identifying whether the given hand is a full house was already \
a special case of identifying the general shape of the hand last week, so we \
don\[CloseCurlyQuote]t need to repeat its code here. "
}], "Text",
 CellChangeTimes->{{3.7328077017973757`*^9, 3.732807944873145*^9}, {
   3.7328083317881927`*^9, 3.732808332186644*^9}, {3.732808792655342*^9, 
   3.7328088048353453`*^9}, {3.73280908033563*^9, 3.7328091259021587`*^9}, {
   3.7328091812489443`*^9, 3.732809210637453*^9}, {3.7328094571216717`*^9, 
   3.732809459657567*^9}, {3.732809514826994*^9, 3.732809557839859*^9}, {
   3.733041651004786*^9, 3.733041651980576*^9}, {3.733043131214353*^9, 
   3.7330431629024773`*^9}, {3.733047987462929*^9, 3.733048161947928*^9}, {
   3.733048195603396*^9, 3.733048359904892*^9}, {3.7330511021587763`*^9, 
   3.733051117124516*^9}, {3.733057314793309*^9, 3.7330573336243153`*^9}, {
   3.733061702985611*^9, 3.733061763826234*^9}, {3.733061892950708*^9, 
   3.7330619094879847`*^9}, {3.733062165894541*^9, 3.733062169115982*^9}, {
   3.733062417182905*^9, 3.733062561973571*^9}, {3.7330730564533987`*^9, 
   3.73307321054638*^9}, {3.733074241036371*^9, 3.733074241274839*^9}, {
   3.733079893845625*^9, 3.733079924111142*^9}, {3.7330800125889273`*^9, 
   3.7330800128138742`*^9}, {3.733124771771224*^9, 3.733124775304254*^9}, 
   3.7332099825209217`*^9, {3.7332101978806267`*^9, 3.7332102341917887`*^9}, {
   3.7332104757517233`*^9, 3.733210585811573*^9}, {3.73321260507023*^9, 
   3.733212647850389*^9}, {3.733213222077589*^9, 3.733213235946878*^9}, {
   3.7332724464732027`*^9, 3.7332726908820543`*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[TextData[StyleBox["Lab Four: String operations", "Chapter"]], "Text",
 CellChangeTimes->{3.73305870041376*^9},
 FontSize->14],

Cell[TextData[{
 "Text strings serve as a convenient stepping stone to ",
 StyleBox["arrays",
  FontSlant->"Italic"],
 " that will be introduced the week following this one, with the ",
 StyleBox["String",
  FontWeight->"Bold"],
 " methods ",
 StyleBox["length",
  FontWeight->"Bold"],
 " and ",
 StyleBox["charAt",
  FontWeight->"Bold"],
 " readily corresponding to the concepts of the array length and the \
positional indexing of its elements. The ",
 StyleBox["String",
  FontWeight->"Bold"],
 " class in Java also serves as an enormous contrast to the character and \
other arrays whose primitive and low level nature will surely annoy anybody \
who has already been spoiled by the power and convenience of, say, strings \
and lists in Python. Whereas Java strings are jam-packed with powerful \
methods for frequently needed operations on text (and in case those are \
somehow not enough to finish the job at hand, the packages ",
 StyleBox["java.util.regex",
  FontWeight->"Bold"],
 " and ",
 StyleBox["java.text",
  FontWeight->"Bold"],
 " fill in the gaps), the primitive Java arrays offer basically diddly squat \
for the programmer. Even the methods that all classes must have by law, such \
as ",
 StyleBox["toString",
  FontWeight->"Bold"],
 " and ",
 StyleBox["equals",
  FontWeight->"Bold"],
 ", are implemented in a way that makes these methods practically useless. \
(At least the utility class ",
 StyleBox["Arrays",
  FontWeight->"Bold"],
 " ameliorates this defective setup a little bit.)\nThe fourth lab of this \
course asks the students to implement various operations on text strings \
whose length and character structure are unlimited. These methods still \
require one loop through the string, since in the last question, the ",
 StyleBox["String",
  FontWeight->"Bold"],
 " method ",
 StyleBox["indexOf",
  FontWeight->"Bold"],
 " to find the first position of the character inside the given string will \
do the work of an inner loop. The first question asks for a method that \
creates and returns a new string that is otherwise the same as its argument \
string, except all of its ",
 StyleBox["runs",
  FontSlant->"Italic"],
 " of consecutive characters have been turned into single characters.\nThe \
JUnit testers for this week are intentionally written to generate long \
strings of random character bursts as test cases, so that any solution that \
builds up the answer by adding immutable strings will end up taking a lot of \
time to slough through these tests. Of course, the mutable ",
 StyleBox["StringBuilder",
  FontWeight->"Bold"],
 " has already been introduced in the lectures covering both the theory of \
its internal operation and the practice with examples of using that class to \
build up the answer. This part of the lectures segways to the fun general \
discussion of how in computing it is often possible to trade space for time \
and vice versa, but since we have ample memory in our computers these days \
and time keeps getting more expensive, we will always try to ",
 StyleBox["cache",
  FontSlant->"Italic"],
 " previous results instead of recomputing them from scratch.\nFor the humour \
value, let us now write some Java using ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", in spirit of the classic programmer observation of how it is possible to \
write Fortran in any language."
}], "Text",
 CellChangeTimes->{{3.732809258036941*^9, 3.7328093415787983`*^9}, {
   3.732809419074679*^9, 3.732809449688883*^9}, {3.7328094923147373`*^9, 
   3.732809507255917*^9}, {3.732809560496357*^9, 3.732809708501338*^9}, {
   3.73281240965392*^9, 3.732812431608953*^9}, {3.732812591934194*^9, 
   3.732813168328928*^9}, {3.732813345959737*^9, 3.7328133620700397`*^9}, {
   3.7328136796583853`*^9, 3.732813726880765*^9}, {3.732813938243986*^9, 
   3.7328139611661*^9}, {3.7330431766230373`*^9, 3.733043396468664*^9}, 
   3.7330437507544107`*^9, {3.733058688121729*^9, 3.733058709665522*^9}, {
   3.73312481055888*^9, 3.73312482301184*^9}, {3.733213263703309*^9, 
   3.7332134691518307`*^9}, {3.7332509992852783`*^9, 3.733251015173213*^9}, {
   3.733251049881875*^9, 3.733251050292613*^9}, {3.733272705936269*^9, 
   3.733272846759136*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"removeDuplicatesJavaStyle", "[", "text_", "]"}], " ", ":=", " ", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"chars", ",", "result", ",", " ", "i"}], "}"}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"chars", " ", "=", " ", 
       RowBox[{"Characters", "[", "text", "]"}]}], ";", "\[IndentingNewLine]", 
      RowBox[{"result", " ", "=", " ", 
       RowBox[{"{", "}"}]}], ";", "\[IndentingNewLine]", 
      RowBox[{"For", "[", 
       RowBox[{
        RowBox[{"i", " ", "=", " ", "1"}], ",", " ", 
        RowBox[{"i", "\[LessEqual]", " ", 
         RowBox[{"Length", "[", "chars", "]"}]}], ",", " ", 
        RowBox[{"i", "++"}], ",", "\[IndentingNewLine]", 
        RowBox[{"If", "[", 
         RowBox[{
          RowBox[{
           RowBox[{"i", " ", "\[Equal]", " ", "1"}], " ", "||", 
           RowBox[{
            RowBox[{"chars", "[", 
             RowBox[{"[", "i", "]"}], "]"}], " ", "\[NotEqual]", " ", 
            RowBox[{"chars", "[", 
             RowBox[{"[", 
              RowBox[{"i", "-", "1"}], "]"}], "]"}]}]}], ",", 
          "\[IndentingNewLine]", 
          RowBox[{
           RowBox[{"AppendTo", "[", 
            RowBox[{"result", ",", " ", 
             RowBox[{"chars", "[", 
              RowBox[{"[", "i", "]"}], "]"}]}], "]"}], ";"}]}], 
         "\[IndentingNewLine]", "]"}]}], "\[IndentingNewLine]", "]"}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"StringJoin", "[", "result", "]"}]}]}], "\[IndentingNewLine]", 
    "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"removeDuplicatesJavaStyle", "[", "\"\<aabbbbbabbbbccccddd\>\"", 
  "]"}]}], "Input",
 CellChangeTimes->{{3.7328131758004*^9, 3.73281318035877*^9}, {
  3.7328133647557583`*^9, 3.7328134058595953`*^9}, {3.732813442052142*^9, 
  3.732813649257998*^9}},
 FontSize->14],

Cell[BoxData["\<\"ababcd\"\>"], "Output",
 CellChangeTimes->{{3.732813643919436*^9, 3.732813657569325*^9}, 
   3.73282365213491*^9, 3.732970570377442*^9, 3.7330509461000843`*^9, 
   3.73305136531199*^9, 3.733057946503647*^9, 3.733065934525934*^9, 
   3.733074321628154*^9, 3.733080119926565*^9, 3.733125514959334*^9, 
   3.7331283993049917`*^9, 3.733133449493999*^9, 3.733210953072497*^9, 
   3.7332126687169943`*^9, 3.7332129625863256`*^9, 3.7332160771747913`*^9, 
   3.733216233322309*^9, 3.733221924329773*^9, 3.733270000578082*^9, 
   3.733277810040554*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "However, many other ways to solve this problem more in the general spirit \
of ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " can surely be thought of. The author has a feeling that he is probably \
missing the best one in this sense. Here are two suggestions meanwhile."
}], "Text",
 CellChangeTimes->{{3.732813739237544*^9, 3.73281376200537*^9}, {
  3.7328139131707706`*^9, 3.732813915388308*^9}, {3.732814044586321*^9, 
  3.732814060856772*^9}, {3.7330627013716583`*^9, 3.7330627017064466`*^9}, {
  3.733272863628528*^9, 3.733272896316442*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"removeDuplicatesSplit", "[", "text_", "]"}], " ", ":=", 
   RowBox[{"StringJoin", "[", 
    RowBox[{"Map", "[", 
     RowBox[{"First", ",", " ", 
      RowBox[{"Split", "[", 
       RowBox[{"Characters", "[", "text", "]"}], "]"}]}], "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"removeDuplicatesFixedPoint", "[", "text_", "]"}], " ", ":=", " ", 
   
   RowBox[{"FixedPoint", "[", 
    RowBox[{
     RowBox[{
      RowBox[{"StringReplace", "[", 
       RowBox[{"#", ",", " ", 
        RowBox[{
         RowBox[{"c_", " ", "~~", " ", "c_"}], " ", ":>", " ", "c"}]}], "]"}],
       "&"}], ",", " ", "text"}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"Table", "[", 
  RowBox[{
   RowBox[{"f", "[", "\"\<aabbbbbabbbbccccddd\>\"", "]"}], ",", " ", 
   RowBox[{"{", 
    RowBox[{"f", ",", 
     RowBox[{"{", 
      RowBox[{"removeDuplicatesSplit", ",", "removeDuplicatesFixedPoint"}], 
      "}"}]}], "}"}]}], "]"}]}], "Input",
 CellChangeTimes->{{3.7328137659987183`*^9, 3.732813779965938*^9}, {
   3.732813836038909*^9, 3.732813897773069*^9}, {3.73281410389811*^9, 
   3.7328141308564663`*^9}, {3.732814237888949*^9, 3.732814408060417*^9}, {
   3.733043771586537*^9, 3.733043809580718*^9}, 3.7332729030916433`*^9},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"\<\"ababcd\"\>", ",", "\<\"ababcd\"\>"}], "}"}]], "Output",
 CellChangeTimes->{{3.732813890268386*^9, 3.732813898335895*^9}, 
   3.732814277203409*^9, {3.732814312363327*^9, 3.732814338410554*^9}, 
   3.7328143941868973`*^9, 3.732823652201837*^9, 3.7329705704870157`*^9, 
   3.73305094617268*^9, 3.733051365400271*^9, 3.733057946632677*^9, 
   3.733065934625815*^9, 3.7330743217443132`*^9, 3.733080120017001*^9, 
   3.733125515064373*^9, 3.733128399437367*^9, 3.73313344959837*^9, 
   3.733210953223679*^9, 3.733212668789506*^9, 3.733212962670557*^9, 
   3.733216077308579*^9, 3.733216233409333*^9, 3.733221924418914*^9, 
   3.733270000648714*^9, 3.733277810095974*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "The second question asks for a method that splits its argument string into \
individual words separated by one or more whitespace characters. Of course, a \
clever student who has, as our friends across the pond would say, ",
 StyleBox["taken a butcher\[CloseCurlyQuote]s",
  FontSlant->"Italic"],
 " through the Java API documentation would realize that there already exists \
a method in ",
 StyleBox["String",
  FontWeight->"Bold"],
 " to do precisely this, and there is no harm pointing such out possibility \
after the lab to remind the students that most wheels that people need to \
drive have long since been invented over and over, so there is no point for \
anybody to reinvent them unless they feel they could use more exercise in the \
art of wheelmaking. But even working from scratch, the student will soon \
realize that it is necessary to use the utility method ",
 StyleBox["Character.isWhitespace",
  FontWeight->"Bold"],
 " to recognize the whitespace characters, since the Unicode character \
standard defines a whopping 25 different whitespace characters! (In addition \
to the familiar troika of the ordinary whitespace, tab and newline \
characters, how many of these other whitespace characters can the reader \
name?) Since in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", this whole method would just be one call to ",
 StyleBox["StringSplit",
  FontWeight->"Bold"],
 ", we could now at least pretend to do a little bit of extra work and \
implement this function properly so that it will recognize all these exotic \
25 whitespace characters."
}], "Text",
 CellChangeTimes->{{3.7328139704352427`*^9, 3.732814036105113*^9}, {
  3.732814443940351*^9, 3.732814506018112*^9}, {3.732814581994137*^9, 
  3.7328146088814096`*^9}, {3.732814649616894*^9, 3.732814705174954*^9}, {
  3.7328148584294777`*^9, 3.7328148662995653`*^9}, {3.73281568832959*^9, 
  3.7328157588535423`*^9}, {3.732817340612369*^9, 3.732817345756584*^9}, {
  3.733043817139721*^9, 3.733043843394113*^9}, {3.733062713147862*^9, 
  3.733062748090777*^9}, {3.733080213252458*^9, 3.73308021418721*^9}, {
  3.7332134995516768`*^9, 3.733213645835947*^9}, {3.733272907667124*^9, 
  3.733273030003688*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"unicodeWhitespaces", " ", "=", " ", 
   RowBox[{"{", 
    RowBox[{
    "9", ",", " ", "10", ",", " ", "11", ",", " ", "12", ",", "13", ",", " ", 
     "32", ",", " ", "133", ",", " ", "160", ",", " ", "5760", ",", " ", 
     "8192", ",", " ", "8193", ",", " ", "8194", ",", " ", "8195", ",", " ", 
     "8196", ",", " ", "8197", ",", " ", "8198", ",", " ", "8199", ",", " ", 
     "8200", ",", " ", "8201", ",", " ", "8202", ",", " ", "8232", ",", " ", 
     "8233", ",", "8239", ",", " ", "8287", ",", " ", "12288"}], " ", "}"}]}],
   ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"splitWords", "[", "text_", "]"}], " ", ":=", " ", 
    "\[IndentingNewLine]", 
    RowBox[{"Map", "[", 
     RowBox[{"FromCharacterCode", ",", " ", "\[IndentingNewLine]", 
      RowBox[{"Select", "[", 
       RowBox[{
        RowBox[{"SplitBy", "[", 
         RowBox[{
          RowBox[{"ToCharacterCode", "[", "text", "]"}], ",", " ", 
          RowBox[{
           RowBox[{"MemberQ", "[", 
            RowBox[{"unicodeWhitespaces", ",", "#"}], "]"}], "&"}]}], "]"}], 
        ",", " ", 
        RowBox[{
         RowBox[{"(", 
          RowBox[{"Not", "[", 
           RowBox[{"MemberQ", "[", 
            RowBox[{"unicodeWhitespaces", ",", 
             RowBox[{"First", "[", "#", "]"}]}], "]"}], "]"}], ")"}], "&"}]}],
        "]"}]}], "\[IndentingNewLine]", "]"}]}], ";"}], 
  "\[IndentingNewLine]"}], "\[IndentingNewLine]", 
 RowBox[{"splitWords", "[", 
  "\"\<  H\:0eadllo world! H\[HappySmiley]w      are y\[OHat]u today?\>\"", 
  "]"}], "\[IndentingNewLine]", 
 RowBox[{"splitWords", "[", 
  RowBox[{"FromCharacterCode", "[", 
   RowBox[{"{", 
    RowBox[{
    "97", ",", " ", "160", ",", " ", "98", ",", " ", "5760", ",", " ", "99", 
     ",", " ", "8192", ",", "100", ",", " ", "8193", ",", " ", "101", ",", 
     " ", "8194"}], "}"}], "]"}], "]"}]}], "Input",
 CellChangeTimes->{{3.732814541806038*^9, 3.732814555731649*^9}, {
  3.732814739024252*^9, 3.732814838604849*^9}, {3.732814930057763*^9, 
  3.732814932990267*^9}, {3.732814974291319*^9, 3.732815085504408*^9}, {
  3.732815166597282*^9, 3.732815234537023*^9}, {3.732815277314374*^9, 
  3.732815283942445*^9}, {3.732815319940856*^9, 3.732815333488083*^9}, {
  3.732815375542082*^9, 3.732815384863433*^9}, {3.7328154264529457`*^9, 
  3.7328156671968117`*^9}, {3.7328158160357513`*^9, 3.732815845952733*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"\<\"H\:0eadllo\"\>", ",", "\<\"world!\"\>", 
   ",", "\<\"H\[HappySmiley]w\"\>", ",", "\<\"are\"\>", 
   ",", "\<\"y\[OHat]u\"\>", ",", "\<\"today?\"\>"}], "}"}]], "Output",
 CellChangeTimes->{
  3.732814840684784*^9, {3.732815177736487*^9, 3.7328152361266623`*^9}, 
   3.732815284678857*^9, {3.7328153309029207`*^9, 3.7328153338970537`*^9}, 
   3.7328153767269897`*^9, 3.7328154312475023`*^9, {3.732815556878621*^9, 
   3.732815575227523*^9}, 3.732815610849595*^9, 3.732815669621385*^9, 
   3.732815823867837*^9, 3.73282365228675*^9, 3.7329705706044617`*^9, 
   3.733050946226509*^9, 3.733051365501906*^9, 3.733057946732259*^9, 
   3.73306593476115*^9, 3.733074321860523*^9, 3.733080120117477*^9, 
   3.7331255151659193`*^9, 3.733128399571928*^9, 3.733133449699362*^9, 
   3.733210953340414*^9, 3.733212668948683*^9, 3.733212962753187*^9, 
   3.7332160774250097`*^9, 3.73321623349358*^9, 3.733221924518631*^9, 
   3.733270000733727*^9, 3.733277810216576*^9},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"\<\"a\"\>", ",", "\<\"b\"\>", ",", "\<\"c\"\>", ",", "\<\"d\"\>", 
   ",", "\<\"e\"\>"}], "}"}]], "Output",
 CellChangeTimes->{
  3.732814840684784*^9, {3.732815177736487*^9, 3.7328152361266623`*^9}, 
   3.732815284678857*^9, {3.7328153309029207`*^9, 3.7328153338970537`*^9}, 
   3.7328153767269897`*^9, 3.7328154312475023`*^9, {3.732815556878621*^9, 
   3.732815575227523*^9}, 3.732815610849595*^9, 3.732815669621385*^9, 
   3.732815823867837*^9, 3.73282365228675*^9, 3.7329705706044617`*^9, 
   3.733050946226509*^9, 3.733051365501906*^9, 3.733057946732259*^9, 
   3.73306593476115*^9, 3.733074321860523*^9, 3.733080120117477*^9, 
   3.7331255151659193`*^9, 3.733128399571928*^9, 3.733133449699362*^9, 
   3.733210953340414*^9, 3.733212668948683*^9, 3.733212962753187*^9, 
   3.7332160774250097`*^9, 3.73321623349358*^9, 3.733221924518631*^9, 
   3.733270000733727*^9, 3.733277810227975*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "Just out of curiosity, let\[CloseCurlyQuote]s find out how many Unicode \
characters from the above list ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " actually recognizes as whitespaces. Really, only six?"
}], "Text",
 CellChangeTimes->{{3.7328157731278152`*^9, 3.732815788036496*^9}, {
  3.732815856547061*^9, 3.732815979281686*^9}, {3.732816284790123*^9, 
  3.732816294476975*^9}, {3.7328163263701077`*^9, 3.732816345139968*^9}, {
  3.7330438705215*^9, 3.733043919258346*^9}, {3.733213655245187*^9, 
  3.733213665626339*^9}, {3.733273035747562*^9, 3.733273044170413*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Map", "[", 
  RowBox[{"ToCharacterCode", ",", " ", 
   RowBox[{"Select", "[", 
    RowBox[{
     RowBox[{"CharacterRange", "[", 
      RowBox[{
       RowBox[{"FromCharacterCode", "[", "1", "]"}], ",", " ", 
       RowBox[{"FromCharacterCode", "[", "13000", "]"}]}], "]"}], ",", " ", 
     RowBox[{
      RowBox[{"StringMatchQ", "[", 
       RowBox[{"#", ",", "Whitespace"}], "]"}], "&"}]}], "]"}]}], 
  "]"}]], "Input",
 CellChangeTimes->{{3.733043930400806*^9, 3.73304411563316*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", "9", "}"}], ",", 
   RowBox[{"{", "10", "}"}], ",", 
   RowBox[{"{", "11", "}"}], ",", 
   RowBox[{"{", "12", "}"}], ",", 
   RowBox[{"{", "13", "}"}], ",", 
   RowBox[{"{", "32", "}"}]}], "}"}]], "Output",
 CellChangeTimes->{
  3.733044014875355*^9, 3.733044054269796*^9, {3.7330440895671988`*^9, 
   3.7330441162280283`*^9}, 3.7330509463062973`*^9, 3.733051365617177*^9, 
   3.733057946833274*^9, 3.733065934944252*^9, 3.7330743219698973`*^9, 
   3.733080120216689*^9, 3.733125515299581*^9, 3.733128399705308*^9, 
   3.733133449816676*^9, 3.733210953456101*^9, 3.733212669065194*^9, 
   3.7332129644900417`*^9, 3.7332160775758133`*^9, 3.733216233592928*^9, 
   3.73322192461893*^9, 3.733270000833316*^9, 3.733277810348785*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "The next question in this lab is our first example of writing a for-loop \
that maintains some ",
 StyleBox["state information ",
  FontSlant->"Italic"],
 "along the way that helps it decide what to do for each input character that \
it processes. The problem asks to convert the argument string to a result of \
equal length but where the first letter of every word is converted to title \
case, and all other characters are kept as they were. This second requirement \
includes all whitespace characters, so we cannot use ",
 StyleBox["split",
  FontWeight->"Bold"],
 " here to separate the words, since doing so would lose the distinction \
between different types of whitespace characters and, more importantly, their \
counts. On a quick googling of the topic, ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " does not seem to make the distinction between title case and upper case, \
so we are content to convert each character that is preceded by some \
whitespace character to uppercase."
}], "Text",
 CellChangeTimes->{{3.7328157731278152`*^9, 3.732815788036496*^9}, {
  3.732815856547061*^9, 3.732815979281686*^9}, {3.732816284790123*^9, 
  3.732816294476975*^9}, {3.7328163263701077`*^9, 3.732816345139968*^9}, {
  3.7330438705215*^9, 3.7330439253674383`*^9}, {3.733044126724399*^9, 
  3.733044182884658*^9}, {3.733213675035542*^9, 3.7332137278097897`*^9}, {
  3.733273049685246*^9, 3.7332731302654533`*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"convertChar", "[", 
    RowBox[{"{", 
     RowBox[{"c1_", ",", "c2_"}], "}"}], "]"}], " ", ":=", " ", 
   RowBox[{"If", "[", 
    RowBox[{
     RowBox[{"StringMatchQ", "[", 
      RowBox[{"c1", ",", " ", "WhitespaceCharacter"}], "]"}], ",", " ", 
     RowBox[{"ToUpperCase", "[", "c2", "]"}], ",", " ", "c2"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"convertToTitleCase", "[", "text_", "]"}], " ", ":=", 
   RowBox[{"StringJoin", "[", 
    RowBox[{"Map", "[", 
     RowBox[{"convertChar", ",", "  ", 
      RowBox[{"Partition", "[", 
       RowBox[{
        RowBox[{"Join", "[", 
         RowBox[{
          RowBox[{"{", "\"\< \>\"", "}"}], ",", " ", 
          RowBox[{"Characters", "[", "text", "]"}]}], "]"}], ",", "2", ",", 
        "1"}], "]"}]}], "]"}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"convertToTitleCase", "[", 
  "\"\<well hello there old chap, how are yeh?\>\"", "]"}]}], "Input",
 CellChangeTimes->{{3.732815985426989*^9, 3.732815993457973*^9}, {
  3.732816034433599*^9, 3.732816096036129*^9}, {3.732816141449391*^9, 
  3.732816276943935*^9}, {3.732816437011231*^9, 3.732816441147065*^9}},
 FontSize->14],

Cell[BoxData["\<\"Well Hello There Old Chap, How Are Yeh?\"\>"], "Output",
 CellChangeTimes->{3.7328162327610903`*^9, 3.732816280139298*^9, 
  3.7328164422008667`*^9, 3.732823652369506*^9, 3.732970570722043*^9, 
  3.733050946372651*^9, 3.7330513657183437`*^9, 3.733057946917994*^9, 
  3.733065935044181*^9, 3.733074322085227*^9, 3.733080120317683*^9, 
  3.7331255154147787`*^9, 3.7331283998204308`*^9, 3.73313344991634*^9, 
  3.7332109535565577`*^9, 3.7332126691656437`*^9, 3.733212964653144*^9, 
  3.733216077664949*^9, 3.7332162336942244`*^9, 3.733221924702426*^9, 
  3.7332700009166327`*^9, 3.733277810414813*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "The last question of this week is similar to the first one, but instead of \
comparing each character to its immediate predecessor to determine whether \
that character will become part of the result, this question compares each \
character to all the previous characters that have been already included in \
the result. This result will then contain every character that appears in the \
original text, but each character included exactly once. Furthermore, these \
characters are required to appear in the result in the exact same order that \
they first originally appeared in the text, so we can\[CloseCurlyQuote]t just \
say ",
 StyleBox["Union[Characters[text]]",
  FontWeight->"Bold"],
 " to solve this problem as a one-liner. This problem might initially seem \
like it necessarily needs to be solved in an imperative fashion, maintaining \
a data structure that remembers the characters that have already been \
encountered in the previously iterated positions. But the same as with any \
computation, functional programming operators are ",
 StyleBox["Turing-complete",
  FontSlant->"Italic"],
 " and can always be combined in a myriad different ways to produce the \
result of any computation in a non-imperative fashion. \nThe following \
expression, the most convoluted lab solution that we have seen so far, is \
easiet to decipher from inside out. Its innermost subexpression first uses ",
 StyleBox["MapIndexed",
  FontWeight->"Bold"],
 ", the nifty and crafty generalization of ",
 StyleBox["Map",
  FontWeight->"Bold"],
 " that operates on each element and its position instead of only the element \
itself, to allow it make decisions based on not just the element of the list \
but its position. This operation converts the list of characters into a list \
of pairs of the form ",
 StyleBox["{c, i}",
  FontSlant->"Italic"],
 " where ",
 StyleBox["c",
  FontSlant->"Italic"],
 " is the original character and ",
 StyleBox["i",
  FontSlant->"Italic"],
 " is its position in the string. This list of pair is then sorted based on \
the first component to make all occurrences of the same original character to \
end up in consecutive positions of the list. The sorted list is split into \
sublists of equal characters with the function ",
 StyleBox["SplitBy",
  FontWeight->"Bold"],
 " so that each sublist contains all consecutive occurrences of that \
particular character. Since we care only about the first occurrence of each \
character, we apply ",
 StyleBox["Map",
  FontWeight->"Bold"],
 " to these sublists to extract the ",
 StyleBox["First",
  FontWeight->"Bold"],
 " occurrence of each character, still in the form of a pair ",
 StyleBox["{c, i}",
  FontSlant->"Italic"],
 ", but ",
 StyleBox["i",
  FontSlant->"Italic"],
 " is now guaranteed to be the position of the first occurrence of that \
character. These pairs are then sorted again, but now based on the position \
",
 StyleBox["i,",
  FontSlant->"Italic"],
 " to effectively return each character in the list in its place in the \
original order. Finally, the original characters are extracted from these \
pairs by dropping the now redundant position component, and the resulting \
list of characters is turned back into a string using ",
 StyleBox["StringJoin",
  FontWeight->"Bold"],
 ". (In the classic Lisp functional programming language, this idiom is known \
as ",
 StyleBox["decorate-sort-undecorate",
  FontSlant->"Italic"],
 ".)"
}], "Text",
 CellChangeTimes->{{3.732816355004492*^9, 3.7328164173706427`*^9}, {
  3.7328164553389473`*^9, 3.732816476562399*^9}, {3.732816507929266*^9, 
  3.7328165361135283`*^9}, {3.7328166716463213`*^9, 3.7328167382701*^9}, {
  3.7328168282778883`*^9, 3.732816859860351*^9}, {3.732816994385631*^9, 
  3.732817326445508*^9}, {3.7328174147800303`*^9, 3.732817497939336*^9}, {
  3.732817536524583*^9, 3.732817558130612*^9}, {3.7328182929224567`*^9, 
  3.732818368310144*^9}, {3.733044208824306*^9, 3.7330442268539143`*^9}, {
  3.733132407726488*^9, 3.73313242080478*^9}, {3.733132460033979*^9, 
  3.7331324808335*^9}, {3.733213753795673*^9, 3.7332139653901863`*^9}, {
  3.7332731458421164`*^9, 3.733273231331916*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"uniqueCharacters", "[", "text_", "]"}], " ", ":=", " ", 
   RowBox[{"StringJoin", "[", 
    RowBox[{"Map", "[", 
     RowBox[{"First", ",", 
      RowBox[{"SortBy", "[", 
       RowBox[{
        RowBox[{"Map", "[", 
         RowBox[{"First", ",", " ", 
          RowBox[{"SplitBy", "[", 
           RowBox[{
            RowBox[{"SortBy", "[", 
             RowBox[{
              RowBox[{"MapIndexed", "[", 
               RowBox[{
                RowBox[{
                 RowBox[{"(", 
                  RowBox[{"{", 
                   RowBox[{"#1", ",", " ", 
                    RowBox[{"First", "[", "#2", "]"}]}], "}"}], ")"}], "&"}], 
                ",", " ", 
                RowBox[{"Characters", "[", "text", "]"}]}], "]"}], ",", " ", 
              "First"}], "]"}], ",", " ", "First"}], "]"}]}], "]"}], ",", " ", 
        RowBox[{
         RowBox[{"#", "[", 
          RowBox[{"[", "2", "]"}], "]"}], "&"}]}], "]"}]}], "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"uniqueCharacters", "[", 
  "\"\<Hello there, world! How are you doing in this day of the year \
2018?\>\"", "]"}]}], "Input",
 CellChangeTimes->{{3.732816482499043*^9, 3.73281648728232*^9}, {
   3.732816616967033*^9, 3.732816654911455*^9}, {3.732816749735531*^9, 
   3.732816777551304*^9}, {3.7328168970693073`*^9, 3.732817001995706*^9}, {
   3.732817353684884*^9, 3.732817400107924*^9}, {3.732817595685711*^9, 
   3.7328176003687687`*^9}, 3.7330442418849573`*^9},
 FontSize->14],

Cell[BoxData["\<\"Helo thr,wd!ayuingsf2018?\"\>"], "Output",
 CellChangeTimes->{
  3.7328169813997*^9, {3.732817362283619*^9, 3.7328174008365297`*^9}, 
   3.7328176008769484`*^9, 3.732823652436734*^9, 3.7329705708385057`*^9, 
   3.733044242522736*^9, 3.733050946440938*^9, 3.733051365818688*^9, 
   3.733057947069016*^9, 3.733065935144088*^9, 3.7330743221951838`*^9, 
   3.7330801204183187`*^9, 3.733125515532917*^9, 3.7331283999404593`*^9, 
   3.733133450016988*^9, 3.733210953706745*^9, 3.733212669265452*^9, 
   3.733212964742523*^9, 3.733216077747653*^9, 3.7332162337769737`*^9, 
   3.733221924802709*^9, 3.733270001000535*^9, 3.733277810482086*^9},
 FontSize->14]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[StyleBox["Lab Five: Arrays",
 FontSize->36]], "Chapter",
 CellChangeTimes->{{3.732818386667109*^9, 3.7328188653658743`*^9}, {
   3.73282044092896*^9, 3.732820461500437*^9}, {3.732822638915674*^9, 
   3.732822656968543*^9}, {3.732822705322612*^9, 3.73282273633554*^9}, {
   3.732823201823759*^9, 3.732823325837797*^9}, {3.733044258973793*^9, 
   3.733044345361959*^9}, 3.733057624603743*^9, 3.733057982919023*^9},
 TextJustification->1.,
 FontSize->14],

Cell[TextData[{
 StyleBox["The fifth lab finally leads the students of this introductory Java \
course to arrays, a topic that at this point should not be all that \
frightening once they realize that the logic of array operations is exactly \
same as it was with text strings, just with a teeny bit different syntax for \
the length and positional indexing operations. From our point of view after \
all the previous labs, it should not come as a surprise that all four lab \
questions of this week can be written out as one-liner rules that operate \
over ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" lists.\nThe first problem of this week asks for a method ", "Text",
  FontSize->14],
 StyleBox["everyOther", "Text",
  FontSize->14,
  FontWeight->"Bold"],
 StyleBox[" that creates a new array that contains all elements in the \
even-numbered positions of the parameter array. (This problem statement \
assumes the usual Java zero-based indexing, so rewritten in ", "Text",
  FontSize->14],
 StyleBox["Mathematica ", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox["conventions, this question actually asks for the elements in the \
odd-numbered positions of the list.) The main difficulty with this problem \
for the tyro is ensuring that the result array has the correct length, since \
it is easy to be off by one in the result length calculations. At this point, \
the author likes give my students the same useful piece of advice that he can \
still somehow remember from his second grade teacher: ", "Text",
  FontSize->14],
 StyleBox["do your calculation using small numbers first to see if your \
calculation steps make sense", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[". Counting with fingers to find out how many elements end up in \
the result usually helps the students find the correct rule, although only \
very advanced students can turn this particular computation into a one-liner \
followed by the element copying logic, instead of writing two separate \
branches of the same copying logic for the odd and even parameter array \
lengths.\nBut seeing how the thoroughly modern ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" is touted for its advanced ", "Text",
  FontSize->14],
 StyleBox["machine learning", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" capabilities, let\[CloseCurlyQuote]s have a fun little comparison \
of which party is smarter, ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" or the average student, in the task of determining how many \
elements the result array will contain. The function ", "Text",
  FontSize->14],
 StyleBox["Predict", "Text",
  FontSize->14,
  FontWeight->"Bold"],
 StyleBox[" that automatically builds a model to best fit its training data \
is given as this training data a small set of examples of the correct result \
lengths for the particular lengths of parameter arrays.", "Text",
  FontSize->14]
}], "Text",
 CellChangeTimes->{
  3.733058150418086*^9, {3.733062770370779*^9, 3.7330628388681517`*^9}, {
   3.7330733600554*^9, 3.733073417526861*^9}, {3.7332139834736233`*^9, 
   3.733214009926564*^9}, {3.733273281092712*^9, 3.7332734223335943`*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"trainingSamples", " ", "=", " ", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"1", "\[Rule]", " ", "1"}], ",", " ", 
     RowBox[{"2", "\[Rule]", " ", "1"}], ",", " ", 
     RowBox[{"3", "\[Rule]", " ", "2"}], ",", " ", 
     RowBox[{"4", "\[Rule]", " ", "2"}], ",", " ", 
     RowBox[{"5", "\[Rule]", " ", "3"}], ",", " ", 
     RowBox[{"6", "\[Rule]", " ", "3"}], ",", " ", 
     RowBox[{"20", "\[Rule]", " ", "10"}]}], "}"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"evaluatePredictor", "[", "p_", "]"}], " ", ":=", 
   RowBox[{"Count", "[", 
    RowBox[{
     RowBox[{"Table", "[", 
      RowBox[{
       RowBox[{
        RowBox[{"Round", "[", 
         RowBox[{"p", "[", "i", "]"}], "]"}], " ", "\[Equal]", " ", 
        RowBox[{
         RowBox[{"Floor", "[", 
          RowBox[{"i", " ", "/", " ", "2"}], "]"}], " ", "+", " ", 
         RowBox[{"Mod", "[", 
          RowBox[{"i", ",", " ", "2"}], "]"}]}]}], ",", " ", 
       RowBox[{"{", 
        RowBox[{"i", ",", " ", "1", ",", " ", "20"}], "}"}]}], "]"}], ",", 
     " ", "True"}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"Table", "[", 
  RowBox[{
   RowBox[{"evaluatePredictor", "[", 
    RowBox[{"Predict", "[", 
     RowBox[{"trainingSamples", ",", " ", 
      RowBox[{"Method", " ", "\[Rule]", " ", "m"}]}], "]"}], "]"}], ",", " ", 
   
   RowBox[{"{", 
    RowBox[{"m", ",", " ", 
     RowBox[{"{", 
      RowBox[{
      "\"\<LinearRegression\>\"", ",", " ", "\"\<NeuralNetwork\>\"", ",", 
       "\"\<RandomForest\>\""}], "}"}]}], "}"}]}], "]"}]}], "Input",
 CellChangeTimes->{{3.732818869310553*^9, 3.732818929156373*^9}, {
  3.732819204613184*^9, 3.732819284862339*^9}, {3.732819367616475*^9, 
  3.732819528003521*^9}, {3.732819572755867*^9, 3.732819840753386*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"19", ",", "14", ",", "6"}], "}"}]], "Output",
 CellChangeTimes->{
  3.732819292584428*^9, {3.732819388682301*^9, 3.7328194040370007`*^9}, {
   3.732819434600276*^9, 3.732819528898303*^9}, 3.7328196714150476`*^9, {
   3.732819755718214*^9, 3.732819842365847*^9}, 3.732823653278232*^9, 
   3.732970571619763*^9, 3.7330509471625023`*^9, 3.7330513665973883`*^9, 
   3.7330579478254766`*^9, 3.733065935878394*^9, 3.733074322974255*^9, 
   3.733080121230982*^9, 3.733125516615856*^9, 3.7331284008807087`*^9, 
   3.7331334507409554`*^9, 3.733210954416032*^9, 3.733212670248159*^9, 
   3.733212965467546*^9, 3.733216078521097*^9, 3.7332162344687433`*^9, 
   3.733221925698491*^9, 3.733270001912998*^9, 3.733277811202035*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "As seems intuitively reasonable, linear regression finds the best fit for a \
problem that is practically a linear function, although it still misses one \
of our twenty validation tests. So that is one point for the humans at this \
point of the future timeline. Alternatively, we can also check how well ",
 StyleBox["FindSequenceFunction",
  FontWeight->"Bold"],
 " fares with this same task. Well, it does find something all right, but \
definitely not the same formal expression that a normal human would find for \
this problem."
}], "Text",
 CellChangeTimes->{{3.732819792598967*^9, 3.732819799158111*^9}, {
  3.732819845484931*^9, 3.7328198934366302`*^9}, {3.732820081073511*^9, 
  3.7328201697924433`*^9}, {3.732822672991189*^9, 3.7328226965106297`*^9}, {
  3.7329547825595303`*^9, 3.732954807958343*^9}, {3.732954891573862*^9, 
  3.7329548935247498`*^9}, {3.733044406640767*^9, 3.7330444148325233`*^9}, {
  3.733073432909892*^9, 3.733073438941731*^9}, {3.73321402210885*^9, 
  3.733214031812595*^9}, {3.733273451319778*^9, 3.733273501115012*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{"tableLength", " ", "=", " ", 
  RowBox[{"FindSequenceFunction", "[", 
   RowBox[{"{", 
    RowBox[{
    "1", ",", "1", ",", "2", ",", "2", ",", "3", ",", "3", ",", "4", ",", "4",
      ",", "5", ",", "5", ",", "6", ",", "6"}], "}"}], 
   "]"}]}], "\[IndentingNewLine]", 
 RowBox[{"FullSimplify", "[", 
  RowBox[{"tableLength", ",", " ", 
   RowBox[{"ComplexityFunction", " ", "\[Rule]", " ", "LeafCount"}]}], 
  "]"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"Table", "[", 
   RowBox[{
    RowBox[{"tableLength", "[", "k", "]"}], ",", 
    RowBox[{"{", 
     RowBox[{"k", ",", "1", ",", "20"}], "}"}]}], "]"}], " "}]}], "Input",
 CellChangeTimes->{{3.732954849677539*^9, 3.7329548642616577`*^9}, {
  3.733044369466072*^9, 3.733044401633307*^9}, {3.733273511759527*^9, 
  3.733273537578723*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{
  RowBox[{
   FractionBox["1", "4"], " ", 
   SuperscriptBox[
    RowBox[{"(", 
     RowBox[{"-", "1"}], ")"}], "#1"], " ", 
   RowBox[{"(", 
    RowBox[{
     RowBox[{"-", "1"}], "+", 
     SuperscriptBox[
      RowBox[{"(", 
       RowBox[{"-", "1"}], ")"}], "#1"], "+", 
     RowBox[{"2", " ", 
      SuperscriptBox[
       RowBox[{"(", 
        RowBox[{"-", "1"}], ")"}], "#1"], " ", "#1"}]}], ")"}]}], 
  "&"}]], "Output",
 CellChangeTimes->{
  3.732954868776181*^9, 3.7329705730261717`*^9, {3.733044375016515*^9, 
   3.733044402571514*^9}, 3.733050948471383*^9, 3.733051367900935*^9, 
   3.733057949185851*^9, 3.7330659372301083`*^9, 3.733074324584847*^9, 
   3.733080122612555*^9, 3.73312551795718*^9, 3.73312840239258*^9, 
   3.7331334520784883`*^9, 3.733210955871541*^9, 3.73321267171369*^9, 
   3.73321296653386*^9, 3.733216079989654*^9, 3.733216235765511*^9, 
   3.733221927463751*^9, 3.7332700032593327`*^9, 3.7332735394804792`*^9, 
   3.733277812513179*^9},
 FontSize->14],

Cell[BoxData[
 RowBox[{
  RowBox[{
   FractionBox["1", "4"], " ", 
   SuperscriptBox[
    RowBox[{"(", 
     RowBox[{"-", "1"}], ")"}], "#1"], " ", 
   RowBox[{"(", 
    RowBox[{
     RowBox[{"-", "1"}], "+", 
     SuperscriptBox[
      RowBox[{"(", 
       RowBox[{"-", "1"}], ")"}], "#1"], "+", 
     RowBox[{"2", " ", 
      SuperscriptBox[
       RowBox[{"(", 
        RowBox[{"-", "1"}], ")"}], "#1"], " ", "#1"}]}], ")"}]}], 
  "&"}]], "Output",
 CellChangeTimes->{
  3.732954868776181*^9, 3.7329705730261717`*^9, {3.733044375016515*^9, 
   3.733044402571514*^9}, 3.733050948471383*^9, 3.733051367900935*^9, 
   3.733057949185851*^9, 3.7330659372301083`*^9, 3.733074324584847*^9, 
   3.733080122612555*^9, 3.73312551795718*^9, 3.73312840239258*^9, 
   3.7331334520784883`*^9, 3.733210955871541*^9, 3.73321267171369*^9, 
   3.73321296653386*^9, 3.733216079989654*^9, 3.733216235765511*^9, 
   3.733221927463751*^9, 3.7332700032593327`*^9, 3.7332735394804792`*^9, 
   3.733277812524139*^9},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
  "1", ",", "1", ",", "2", ",", "2", ",", "3", ",", "3", ",", "4", ",", "4", 
   ",", "5", ",", "5", ",", "6", ",", "6", ",", "7", ",", "7", ",", "8", ",", 
   "8", ",", "9", ",", "9", ",", "10", ",", "10"}], "}"}]], "Output",
 CellChangeTimes->{
  3.732954868776181*^9, 3.7329705730261717`*^9, {3.733044375016515*^9, 
   3.733044402571514*^9}, 3.733050948471383*^9, 3.733051367900935*^9, 
   3.733057949185851*^9, 3.7330659372301083`*^9, 3.733074324584847*^9, 
   3.733080122612555*^9, 3.73312551795718*^9, 3.73312840239258*^9, 
   3.7331334520784883`*^9, 3.733210955871541*^9, 3.73321267171369*^9, 
   3.73321296653386*^9, 3.733216079989654*^9, 3.733216235765511*^9, 
   3.733221927463751*^9, 3.7332700032593327`*^9, 3.7332735394804792`*^9, 
   3.733277812531972*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "After this fun little digression into this refreshing modern day John Henry \
tale, the following solution to the original problem uses ",
 StyleBox["Partition",
  FontWeight->"Bold"],
 " to split the list into sublists of two elements, from each of which we \
take the first one and discard the second. By itself this approach would fail \
for any list of odd length, since the last element would not become part of \
this partition. Fortunately, the ",
 StyleBox["Partition",
  FontWeight->"Bold"],
 " function can be given extra control parameters to handle precisely these \
sorts of common situations. Even though the original lab problems guaranteed \
that the method can assume its arguments to conform to the lab specification, \
we can easily define this rule to match patterns with the particular ",
 StyleBox["Head",
  FontWeight->"Bold"],
 "."
}], "Text",
 CellChangeTimes->{{3.732819792598967*^9, 3.732819799158111*^9}, {
  3.732819845484931*^9, 3.7328198934366302`*^9}, {3.732820081073511*^9, 
  3.7328201697924433`*^9}, {3.732822672991189*^9, 3.7328226965106297`*^9}, {
  3.7329547825595303`*^9, 3.732954841373555*^9}, {3.7330444245911922`*^9, 
  3.7330444608157682`*^9}, {3.733062846590843*^9, 3.733062890703505*^9}, {
  3.7332140414719048`*^9, 3.7332140818360147`*^9}, {3.733273552578867*^9, 
  3.733273577209741*^9}, {3.7332738273851347`*^9, 3.733273872341526*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"everyOther", "[", "v_List", "]"}], " ", ":=", " ", 
   RowBox[{"Map", "[", 
    RowBox[{"First", ",", " ", 
     RowBox[{"Partition", "[", 
      RowBox[{"v", ",", "2", ",", " ", "2", ",", " ", 
       RowBox[{"{", 
        RowBox[{"1", ",", "1"}], "}"}]}], "]"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"everyOther", "[", 
  RowBox[{"Range", "[", "20", "]"}], "]"}]}], "Input",
 CellChangeTimes->{{3.732819913853716*^9, 3.732819963240859*^9}, {
  3.7328200580122957`*^9, 3.732820077626593*^9}, {3.7329517094993687`*^9, 
  3.732951710794252*^9}, {3.7332738245379066`*^9, 3.73327382486222*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
  "1", ",", "3", ",", "5", ",", "7", ",", "9", ",", "11", ",", "13", ",", 
   "15", ",", "17", ",", "19"}], "}"}]], "Output",
 CellChangeTimes->{{3.732819949251071*^9, 3.732819966499202*^9}, {
   3.732820061690535*^9, 3.732820078015028*^9}, 3.7328236535088243`*^9, 
   3.732951711347015*^9, 3.732970573457726*^9, 3.733050948830945*^9, 
   3.7330513683085747`*^9, 3.733057949568307*^9, 3.7330659376507473`*^9, 
   3.7330743251321907`*^9, 3.733080123030241*^9, 3.7331255183406153`*^9, 
   3.733128402834244*^9, 3.733133452487259*^9, 3.733210956331378*^9, 
   3.733212672074211*^9, 3.733212966915984*^9, 3.733216080409253*^9, 
   3.733216236095911*^9, 3.7332219278612757`*^9, 3.7332700035991287`*^9, 
   3.733277812871896*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "The concept of ",
 StyleBox["inversion",
  FontSlant->"Italic"],
 " is important in combinatorics and the theory of sorting algorithms, as a \
measure of how \[OpenCurlyDoubleQuote]out of order\[CloseCurlyDoubleQuote] \
the array elements are compared to the positions that those elements would \
end up when sorting the array. An ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-element array that is already sorted has zero inversions, the minimum \
possible number, whereas an array that is sorted in reverse order has ",
 StyleBox["n",
  FontSlant->"Italic"],
 "(",
 StyleBox["n",
  FontSlant->"Italic"],
 " - 1)/2 inversions, the maximum possible number.\nTo count the number of \
inversions of the given array in Java, coincidentally the second question in \
this week\[CloseCurlyQuote]s lab, done in the brute force way that a student \
of a first programming course can understand and express in code, requires \
the use of ",
 StyleBox["two nested loops",
  FontSlant->"Italic"],
 " for the first time in this course. The outer loop iterates through the \
positions of the array, and the inner loop iterates through the positions \
that come after the current position of the outer loop counter. The rest is \
just your basic counting problem of initializing an integer counter to zero \
and incrementing it every time a new inversion is encountered. But this is \
pretty much the exact opposite to how we would solve this problem properly as \
a functional programming one-liner in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ". The pattern matching rule to choose the element pairs where the order of \
element values is opposite to the order of their positions uses a conditional \
pattern to do this work. The handy function ",
 StyleBox["Subsets",
  FontWeight->"Bold"],
 " can be used to generate all element pairs, triples, quartets and so on, to \
do the work of nested loops of that depth."
}], "Text",
 CellChangeTimes->{{3.732820196096813*^9, 3.7328204280417624`*^9}, {
  3.732820496085547*^9, 3.732820498627964*^9}, {3.732820545356406*^9, 
  3.732820546891039*^9}, {3.732822468069263*^9, 3.7328225482522907`*^9}, {
  3.733044485904175*^9, 3.733044543991407*^9}, {3.73306291289614*^9, 
  3.733062918270865*^9}, {3.733073455741403*^9, 3.733073474477323*^9}, {
  3.7332140979914618`*^9, 3.733214193474227*^9}, {3.733273586861196*^9, 
  3.7332736751693993`*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"countInversions", "[", "v_List", "]"}], " ", ":=", 
   RowBox[{"Length", "[", 
    RowBox[{"Cases", "[", 
     RowBox[{
      RowBox[{"Subsets", "[", 
       RowBox[{
        RowBox[{"MapIndexed", "[", 
         RowBox[{
          RowBox[{
           RowBox[{"(", 
            RowBox[{"{", 
             RowBox[{"#1", ",", " ", 
              RowBox[{"First", "[", "#2", "]"}]}], "}"}], ")"}], "&"}], ",", 
          " ", "v"}], "]"}], ",", 
        RowBox[{"{", "2", "}"}]}], "]"}], ",", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{
         RowBox[{"{", 
          RowBox[{"a_", ",", "b_"}], "}"}], ",", 
         RowBox[{"{", 
          RowBox[{"c_", ",", "d_"}], "}"}]}], "}"}], " ", "/;", " ", 
       RowBox[{
        RowBox[{"a", " ", ">", " ", "c"}], " ", "&&", " ", 
        RowBox[{"b", " ", "<", " ", "d"}]}]}]}], "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"countInversions", "[", 
  RowBox[{"{", 
   RowBox[{"8", ",", " ", "2", ",", " ", "3", ",", " ", 
    RowBox[{"-", "1"}], ",", " ", "4", ",", " ", "1"}], "}"}], 
  "]"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"countInversions", "[", 
   RowBox[{"Range", "[", 
    RowBox[{"100", ",", "1", ",", 
     RowBox[{"-", "1"}]}], "]"}], "]"}], " ", "\[Equal]", " ", 
  RowBox[{"Binomial", "[", 
   RowBox[{"100", ",", " ", "2"}], "]"}]}]}], "Input",
 CellChangeTimes->{{3.7328205069407454`*^9, 3.732820508723734*^9}, {
  3.732822047254808*^9, 3.7328220495243387`*^9}, {3.7328223049852867`*^9, 
  3.73282246522182*^9}, {3.732822503051836*^9, 3.73282250372816*^9}, {
  3.732822551167865*^9, 3.732822624539263*^9}, {3.732951727840919*^9, 
  3.7329517327218437`*^9}, {3.733273819058375*^9, 3.7332738194083223`*^9}},
 FontSize->14],

Cell[BoxData["10"], "Output",
 CellChangeTimes->{{3.732822339145596*^9, 3.73282235683873*^9}, 
   3.732822442504568*^9, 3.7328225045845747`*^9, {3.7328225525315027`*^9, 
   3.732822558065199*^9}, {3.732822588756329*^9, 3.732822625360579*^9}, 
   3.732823653572391*^9, 3.732951733299251*^9, 3.7329705735634403`*^9, 
   3.733050948896626*^9, 3.733051368426516*^9, 3.7330579496577597`*^9, 
   3.733065937752202*^9, 3.7330743252276783`*^9, 3.733080123128521*^9, 
   3.733125518441197*^9, 3.7331284029714527`*^9, 3.7331334525910683`*^9, 
   3.733210956465824*^9, 3.7332126721729317`*^9, 3.733212966999649*^9, 
   3.733216080622984*^9, 3.7332162361857243`*^9, 3.7332219279469137`*^9, 
   3.733270003668911*^9, 3.7332778129551477`*^9},
 FontSize->14],

Cell[BoxData["True"], "Output",
 CellChangeTimes->{{3.732822339145596*^9, 3.73282235683873*^9}, 
   3.732822442504568*^9, 3.7328225045845747`*^9, {3.7328225525315027`*^9, 
   3.732822558065199*^9}, {3.732822588756329*^9, 3.732822625360579*^9}, 
   3.732823653572391*^9, 3.732951733299251*^9, 3.7329705735634403`*^9, 
   3.733050948896626*^9, 3.733051368426516*^9, 3.7330579496577597`*^9, 
   3.733065937752202*^9, 3.7330743252276783`*^9, 3.733080123128521*^9, 
   3.733125518441197*^9, 3.7331284029714527`*^9, 3.7331334525910683`*^9, 
   3.733210956465824*^9, 3.7332126721729317`*^9, 3.733212966999649*^9, 
   3.733216080622984*^9, 3.7332162361857243`*^9, 3.7332219279469137`*^9, 
   3.733270003668911*^9, 3.733277812968008*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "The third question of this lab is the first one in these weekly labs to \
have the return type ",
 StyleBox["void",
  FontWeight->"Bold"],
 ". The required method modifies the elements of its argument array, instead \
of creating an entire new array to contain the result and return that. (At \
this stage of the course, those students who cannot conceptualize the \
difference between returning a result and printing that result on the screen \
seem to have mysteriously vanished.) Since passing a reference by value is \
for all practical purposes equivalent to passing that object by reference, \
back in the nineties when Java as pretty much all of life was much simpler \
than now, people used to have big fights as modern day versions of the \
\[OpenCurlyDoubleQuote]big-endians\[CloseCurlyDoubleQuote] and \
\[OpenCurlyDoubleQuote]little-endians\[CloseCurlyDoubleQuote] of ",
 StyleBox["Gulliver\[CloseCurlyQuote]s Travels",
  FontSlant->"Italic"],
 " about whether that means that Java also has ",
 StyleBox["call-by-reference",
  FontSlant->"Italic"],
 " parameter passing mechanism in addition to the usual ",
 StyleBox["call-by-value",
  FontSlant->"Italic"],
 ". Such bitter fights over words have long since subsided as our attention \
span has turned to more pressing matters. But wouldn\[CloseCurlyQuote]t this \
still be a good time to find out how assignment and parameter passing \
mechanisms work in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 "? "
}], "Text",
 CellChangeTimes->{{3.7328205901545467`*^9, 3.732820960229298*^9}, {
  3.732821070780067*^9, 3.732821072596072*^9}, {3.732821160010784*^9, 
  3.7328212080177393`*^9}, {3.7328220584052973`*^9, 3.732822097035481*^9}, {
  3.732822142833806*^9, 3.73282226356996*^9}, {3.733044551438817*^9, 
  3.7330446570215073`*^9}, {3.733062936903248*^9, 3.733062937239403*^9}, {
  3.733073499814477*^9, 3.733073518915882*^9}, {3.733214200174192*^9, 
  3.7332142121387587`*^9}, {3.7332736847864523`*^9, 3.7332736875285892`*^9}, {
  3.733273895549879*^9, 3.733273917541391*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"ClearAll", "[", "parameterTest", "]"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"parameterTest", "[", "v_", "]"}], " ", ":=", " ", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", "e", "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"e", " ", "=", " ", "v"}], ";", "\[IndentingNewLine]", 
      RowBox[{
       RowBox[{"e", "[", 
        RowBox[{"[", "2", "]"}], "]"}], " ", "=", " ", "42"}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"Print", "[", 
       RowBox[{"\"\<Inside the function we have \>\"", ",", " ", 
        RowBox[{"e", "[", 
         RowBox[{"[", "2", "]"}], "]"}], ",", "\"\< \>\"", ",", " ", 
        RowBox[{"v", "[", 
         RowBox[{"[", "2", "]"}], "]"}]}], "]"}], ";", "\[IndentingNewLine]", 
      
      RowBox[{"MapAt", "[", 
       RowBox[{
        RowBox[{
         RowBox[{"(", "42", ")"}], "&"}], ",", " ", "v", ",", " ", "2"}], 
       "]"}]}]}], "\[IndentingNewLine]", "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"v", " ", "=", 
   RowBox[{"Range", "[", "100", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"parameterTest", "[", "v", "]"}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"Print", "[", 
   RowBox[{"\"\<Outside the function we have \>\"", ",", " ", 
    RowBox[{"v", "[", 
     RowBox[{"[", "2", "]"}], "]"}]}], "]"}], ";"}]}], "Input",
 CellChangeTimes->{{3.7328209636687*^9, 3.732821055660674*^9}, {
  3.732821130390197*^9, 3.732821143931109*^9}, {3.732821392721883*^9, 
  3.7328213989199343`*^9}, {3.732951742130949*^9, 3.732951744121839*^9}},
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[
 InterpretationBox[
  RowBox[{"\<\"Inside the function we have \"\>", "\[InvisibleSpace]", "42", 
   "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "2"}],
  SequenceForm["Inside the function we have ", 42, " ", 2],
  Editable->False]], "Print",
 CellChangeTimes->{{3.732821040772341*^9, 3.7328210563701363`*^9}, 
   3.732821144853701*^9, 3.732823653657549*^9, 3.732951744739229*^9, 
   3.73297057366502*^9, 3.733050948963954*^9, 3.733051368561366*^9, 
   3.7330579497707233`*^9, 3.733065937869611*^9, 3.733074325344811*^9, 
   3.7330801232441883`*^9, 3.733125518559101*^9, 3.733128403120885*^9, 
   3.733133452708167*^9, 3.733210956599689*^9, 3.733212672274276*^9, 
   3.7332129671004877`*^9, 3.7332160807242937`*^9, 3.733216236286805*^9, 
   3.7332219280469093`*^9, 3.7332700037546663`*^9, 3.7332778130396967`*^9},
 FontSize->14],

Cell[BoxData[
 InterpretationBox[
  RowBox[{"\<\"Outside the function we have \"\>", "\[InvisibleSpace]", "2"}],
  
  SequenceForm["Outside the function we have ", 2],
  Editable->False]], "Print",
 CellChangeTimes->{{3.732821040772341*^9, 3.7328210563701363`*^9}, 
   3.732821144853701*^9, 3.732823653657549*^9, 3.732951744739229*^9, 
   3.73297057366502*^9, 3.733050948963954*^9, 3.733051368561366*^9, 
   3.7330579497707233`*^9, 3.733065937869611*^9, 3.733074325344811*^9, 
   3.7330801232441883`*^9, 3.733125518559101*^9, 3.733128403120885*^9, 
   3.733133452708167*^9, 3.733210956599689*^9, 3.733212672274276*^9, 
   3.7332129671004877`*^9, 3.7332160807242937`*^9, 3.733216236286805*^9, 
   3.7332219280469093`*^9, 3.7332700037546663`*^9, 3.7332778130515213`*^9},
 FontSize->14]
}, Open  ]]
}, Open  ]],

Cell[TextData[{
 "In proper functional programming thinking, modifying data inside a function \
is a huge no-no anyway. But now, we still return to the original lab problem \
of rearranging the array elements so that all nonzero elements are in one \
bunch in the beginning, followed by all the zero elements in the array. The \
function must also maintain the original order of these nonzero elements. As \
always when separating list elements into two groups, either one of the \
functions ",
 StyleBox["Cases",
  FontWeight->"Bold"],
 " and ",
 StyleBox["Select",
  FontWeight->"Bold"],
 ", depending on whether the selection criterion happens to be a pattern or a \
function predicate, will do the job. (The opposite of ",
 StyleBox["Cases",
  FontWeight->"Bold"],
 " in the sense in that it keeps the elements that ",
 StyleBox["Cases",
  FontWeight->"Bold"],
 " discards and vice versa is named ",
 StyleBox["DeleteCases",
  FontWeight->"Bold"],
 ", whereas the negation of ",
 StyleBox["Select",
  FontWeight->"Bold"],
 " is named... (drum roll)... ",
 StyleBox["Select",
  FontWeight->"Bold"],
 ", the exact same function used with  a logical negation placed in front of \
the function used as the selection criterion.) "
}], "Text",
 CellChangeTimes->{{3.7328210932920218`*^9, 3.7328211005863647`*^9}, {
  3.732821282371064*^9, 3.732821370357683*^9}, {3.732821476492529*^9, 
  3.732821493860402*^9}, {3.732821600020352*^9, 3.7328216043460627`*^9}, {
  3.732821672849024*^9, 3.732821703081272*^9}, {3.7328227542376337`*^9, 
  3.732822907867701*^9}, {3.732823436391523*^9, 3.732823437298958*^9}, {
  3.73304466237178*^9, 3.733044662750381*^9}, {3.7330735362980013`*^9, 
  3.733073552299416*^9}, {3.733125127575513*^9, 3.733125145788868*^9}, {
  3.733132801427854*^9, 3.733132823627166*^9}, {3.7332142396364717`*^9, 
  3.7332142689852343`*^9}, {3.733273719323669*^9, 3.733273749823577*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"squeezeLeft", "[", "v_List", "]"}], " ", ":=", " ", 
   RowBox[{"Join", "[", 
    RowBox[{
     RowBox[{"DeleteCases", "[", 
      RowBox[{"v", ",", " ", "0"}], "]"}], ",", " ", 
     RowBox[{"Cases", "[", 
      RowBox[{"v", ",", "0"}], "]"}]}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"squeezeLeft", "[", 
  RowBox[{"{", 
   RowBox[{
   "42", ",", " ", "1", ",", " ", "0", ",", " ", "0", ",", " ", "7", ",", " ",
     "0", ",", " ", "99", ",", " ", 
    RowBox[{"-", "2"}], ",", " ", "0", ",", 
    RowBox[{"-", "99"}]}], "}"}], "]"}]}], "Input",
 CellChangeTimes->{{3.732821387673996*^9, 3.7328214251255693`*^9}, 
   3.732821471209444*^9, {3.732821523781837*^9, 3.732821591420789*^9}, {
   3.733273807656065*^9, 3.73327380800746*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"42", ",", "1", ",", "7", ",", "99", ",", 
   RowBox[{"-", "2"}], ",", 
   RowBox[{"-", "99"}], ",", "0", ",", "0", ",", "0", ",", "0"}], 
  "}"}]], "Output",
 CellChangeTimes->{{3.732821577556127*^9, 3.732821592012662*^9}, 
   3.732823653756789*^9, 3.732970573780775*^9, 3.733050949047434*^9, 
   3.7330513686941*^9, 3.7330579498876333`*^9, 3.733065937985367*^9, 
   3.733074325461322*^9, 3.733080123360178*^9, 3.733125518674349*^9, 
   3.73312840327175*^9, 3.733133452825534*^9, 3.733210956800153*^9, 
   3.7332126723923597`*^9, 3.733212967199277*^9, 3.733216080823567*^9, 
   3.7332162363846292`*^9, 3.733221928151919*^9, 3.7332700038365*^9, 
   3.733277813124235*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "Alternatively, the function ",
 StyleBox["GatherBy",
  FontWeight->"Bold"],
 " could also do the job here. ",
 StyleBox["GatherBy",
  FontWeight->"Bold"],
 " (or simply ",
 StyleBox["Gather",
  FontWeight->"Bold"],
 ", if the selection criterion is the element value equality) is more general \
than ",
 StyleBox["Cases",
  FontWeight->"Bold"],
 " and ",
 StyleBox["Select",
  FontWeight->"Bold"],
 " in that the elements of the list can be partitioned to any number of \
equivalence classes, not merely two. The result is a list of lists of the \
elements of each equivalence class, so flattening this list brings all the \
elements back to the top level but with equal elements gathered together as a \
clump. We give ",
 StyleBox["Flatten",
  FontWeight->"Bold"],
 " the optional level specification of 1 to ensure that the flattening does \
not continue recursively to the sublist structures, which would make a \
difference for the elements that were themselves lists instead of integers."
}], "Text",
 CellChangeTimes->{{3.7328216207710752`*^9, 3.732821658577763*^9}, {
  3.732821717640608*^9, 3.732821827687483*^9}, {3.7328219610219593`*^9, 
  3.732822027580844*^9}, {3.7328222689202137`*^9, 3.732822275128139*^9}, {
  3.732822918099495*^9, 3.732822918627326*^9}, {3.7330447020434103`*^9, 
  3.733044726699437*^9}, {3.733073559115987*^9, 3.7330735623868027`*^9}, {
  3.733132829818927*^9, 3.733132915592738*^9}, {3.733132951045821*^9, 
  3.733133055118619*^9}, {3.733214279436132*^9, 3.7332143318882437`*^9}, {
  3.7332737634660797`*^9, 3.733273792710875*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"squeezeLeftGatherBy", "[", "v_List", "]"}], " ", ":=", " ", 
   RowBox[{"Flatten", "[", 
    RowBox[{
     RowBox[{"GatherBy", "[", 
      RowBox[{"v", ",", " ", 
       RowBox[{
        RowBox[{"(", 
         RowBox[{"#", "!=", " ", "0"}], ")"}], "&"}]}], "]"}], ",", " ", 
     "1"}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"squeezeLeftGatherBy", "[", 
  RowBox[{"{", 
   RowBox[{
   "42", ",", " ", "1", ",", " ", "0", ",", " ", "0", ",", " ", "7", ",", " ",
     "0", ",", " ", "99", ",", " ", 
    RowBox[{"-", "2"}], ",", " ", "0", ",", 
    RowBox[{"-", "99"}]}], "}"}], "]"}]}], "Input",
 CellChangeTimes->{{3.733044732811973*^9, 3.733044754763482*^9}, {
  3.733044786923502*^9, 3.733044806562948*^9}, {3.7331251699347763`*^9, 
  3.733125175213093*^9}, {3.733132983824349*^9, 3.733132983920437*^9}, {
  3.733273812280903*^9, 3.7332738126143312`*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"42", ",", "1", ",", "7", ",", "99", ",", 
   RowBox[{"-", "2"}], ",", 
   RowBox[{"-", "99"}], ",", "0", ",", "0", ",", "0", ",", "0"}], 
  "}"}]], "Output",
 CellChangeTimes->{3.7330448069970627`*^9, 3.733050949114265*^9, 
  3.733051368826442*^9, 3.733057949977676*^9, 3.7330659380872717`*^9, 
  3.733074325566153*^9, 3.7330801234604816`*^9, 3.7331251764956303`*^9, 
  3.733125518774766*^9, 3.733128403404359*^9, 3.733133061797456*^9, 
  3.733133452927783*^9, 3.73321095691702*^9, 3.733212672492012*^9, 
  3.733212967282775*^9, 3.733216080907548*^9, 3.733216236470189*^9, 
  3.733221928252275*^9, 3.733270003920349*^9, 3.733277813206218*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "The last problem of this fifth week requires the student to create and \
return a new array whose exact length is not known at the beginning of the \
method execution, unlike all the other array methods that have been used as \
examples and lab problems so far. The method that implements ",
 StyleBox["run length decoding",
  FontSlant->"Italic"],
 " is given an array whose length is guaranteed to be an even number, so that \
each pair of consecutive elements (",
 StyleBox["n",
  FontSlant->"Italic"],
 ", ",
 StyleBox["v",
  FontSlant->"Italic"],
 ") is expanded into ",
 StyleBox["n ",
  FontSlant->"Italic"],
 "copies of element ",
 StyleBox["v",
  FontSlant->"Italic"],
 ". For example, the array ",
 StyleBox["[1000000, 42]",
  FontWeight->"Bold"],
 " would expand into a million element array whose every element has the same \
value 42. The Java implementation has to first loop through the parameter \
array and add up every other element working as ",
 StyleBox["n",
  FontSlant->"Italic"],
 ", and then use two nested loops to populate the result array with the \
copies of the element. The ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " solution is quite a lot shorter and simpler than that, again a mere \
one-liner. "
}], "Text",
 CellChangeTimes->{{3.7328216207710752`*^9, 3.732821658577763*^9}, {
  3.732821717640608*^9, 3.732821827687483*^9}, {3.7328219610219593`*^9, 
  3.732822027580844*^9}, {3.7328222689202137`*^9, 3.732822275128139*^9}, {
  3.732822918099495*^9, 3.732822918627326*^9}, {3.7330447020434103`*^9, 
  3.733044728195458*^9}, {3.7330448218493347`*^9, 3.733044827418489*^9}, {
  3.733073570012847*^9, 3.733073587146999*^9}, {3.7331330716464043`*^9, 
  3.733133072638198*^9}, {3.733214347442568*^9, 3.733214348248282*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"runLengthDecode", "[", "v_", "]"}], " ", ":=", " ", 
   RowBox[{"Flatten", "[", 
    RowBox[{
     RowBox[{"Table", "[", 
      RowBox[{
       RowBox[{"Table", "[", 
        RowBox[{
         RowBox[{"p", "[", 
          RowBox[{"[", "2", "]"}], "]"}], ",", " ", 
         RowBox[{"{", 
          RowBox[{"i", ",", " ", "1", ",", " ", 
           RowBox[{"p", "[", 
            RowBox[{"[", "1", "]"}], "]"}]}], "}"}]}], "]"}], ",", 
       RowBox[{"{", 
        RowBox[{"p", ",", " ", 
         RowBox[{"Partition", "[", 
          RowBox[{"v", ",", " ", "2"}], "]"}]}], "}"}]}], "]"}], ",", "1"}], 
    "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"runLengthDecode", "[", 
  RowBox[{"{", 
   RowBox[{
   "3", ",", " ", "7", ",", " ", "1", ",", " ", "6", ",", " ", "0", ",", " ", 
    
    RowBox[{"-", "1"}], ",", " ", "4", ",", " ", "8"}], "}"}], 
  "]"}]}], "Input",
 CellChangeTimes->{{3.732821832072557*^9, 3.732821944166225*^9}, {
  3.733133091250566*^9, 3.733133093524267*^9}, {3.733133155504928*^9, 
  3.7331331589870367`*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
  "7", ",", "7", ",", "7", ",", "6", ",", "8", ",", "8", ",", "8", ",", "8"}],
   "}"}]], "Output",
 CellChangeTimes->{{3.7328219311593122`*^9, 3.732821944628867*^9}, 
   3.732823653824497*^9, 3.7329705738810177`*^9, 3.733050949179789*^9, 
   3.7330513689434233`*^9, 3.7330579500614767`*^9, 3.7330659382027817`*^9, 
   3.733074325683201*^9, 3.7330801235608797`*^9, 3.73312551887671*^9, 
   3.733128403537833*^9, 3.733133095131995*^9, 3.733133160805623*^9, 
   3.733133453028242*^9, 3.733210957034255*^9, 3.7332126725917397`*^9, 
   3.733212967366085*^9, 3.7332160810409193`*^9, 3.7332162365402184`*^9, 
   3.7332219283527727`*^9, 3.733270004009377*^9, 3.733277813289288*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "At this point of the course, students should be quite comfortable in \
writing the weekly labs and testing them on the spot with the JUnit testers \
provided by the instructor for each week. Having taught all the Java language \
that needs to be taught in the first programming course for objects-last \
spirit (in the Ryerson Computer Science curriculum, inheritance and \
polymorphism are taught in the second programming course after this one), the \
second half of the lectures is spent taking apart a whole bunch of example \
methods and classes while tirelessly pointing out all the interesting little \
programming techniques and tricks that these examples have to illustrate. One \
theory lecture is spent thoroughly covering recursion well past the usual \
factorial and Fibonacci examples, after which another theory lecture covers \
the introductory theory of algorithms and asymptotic notation. After all \
these examples and labs, combined with the requirement of solving any 50 \
non-warmup problems of their choice on the most excellent ",
 ButtonBox["CodingBat",
  BaseStyle->"Hyperlink",
  ButtonData->{
    URL["http://codingbat.com/java"], None},
  ButtonNote->"http://codingbat.com/java"],
 " interactive Java and Python programming training site, the students are \
ready for the final exam that consists of four method writing questions, with \
no theory or terminology whatsoever to remember. It would be pointless to \
memorize anything that can be googled in five seconds from the API reference \
or Stack Overflow anyway, so all learning efforts should be focused in how to \
write and think about correct working code."
}], "Text",
 CellChangeTimes->{{3.732822923430944*^9, 3.732823180431601*^9}, {
   3.7328674721967707`*^9, 3.732867753120476*^9}, {3.732867869743877*^9, 
   3.732867884822524*^9}, 3.73297096309164*^9, {3.733044853369952*^9, 
   3.7330448778898287`*^9}, {3.733062963461988*^9, 3.733063028606176*^9}, {
   3.7330736002211113`*^9, 3.7330736304186983`*^9}, {3.733133107373826*^9, 
   3.733133150982823*^9}, {3.733273947259221*^9, 3.733273996020978*^9}},
 TextJustification->1.,
 FontSize->14]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[StyleBox["Lab Six: Shapes of arrays",
 FontSize->36]], "Chapter",
 CellChangeTimes->{{3.732971035816072*^9, 3.732971041335691*^9}},
 FontSize->14],

Cell[TextData[{
 "The sixth lab continues with operations on arrays with four example \
problems that each ask for a method to determine whether the general shape of \
the array values satisfies the method specification. This general shape is \
determined by the sequence of signs of the differences between consecutive \
elements. An ",
 StyleBox["upstep",
  FontSlant->"Italic"],
 " is defined to be any position ",
 StyleBox["i",
  FontSlant->"Italic"],
 " where ",
 StyleBox["a[i] < a[i+1]",
  FontWeight->"Bold"],
 ", a ",
 StyleBox["downstep",
  FontSlant->"Italic"],
 " is any position ",
 StyleBox["i",
  FontSlant->"Italic"],
 " where ",
 StyleBox["a[i] > a[i+1]",
  FontWeight->"Bold"],
 ", and a ",
 StyleBox["plateau",
  FontSlant->"Italic"],
 " is any position ",
 StyleBox["i",
  FontSlant->"Italic"],
 " where ",
 StyleBox["a[i] == a[i+1]",
  FontWeight->"Bold"],
 ". These properties are not defined for the last position of the array, \
since that element does not have a successor element in that array to compare \
it with."
}], "Text",
 CellChangeTimes->{{3.732822923430944*^9, 3.732823180431601*^9}, {
   3.7328674721967707`*^9, 3.732867753120476*^9}, {3.732867869743877*^9, 
   3.732867884822524*^9}, {3.73297096309164*^9, 3.732970967352572*^9}, 
   3.732971044679228*^9, {3.7330448922975473`*^9, 3.733044918800844*^9}, {
   3.7330630509238777`*^9, 3.733063052189562*^9}, {3.7330736368268957`*^9, 
   3.7330736479522057`*^9}, {3.733133166804967*^9, 3.733133184620495*^9}, {
   3.733274012158349*^9, 3.73327407733027*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"shape", "[", "v_", "]"}], " ", ":=", " ", 
   RowBox[{"Map", "[", 
    RowBox[{
     RowBox[{
      RowBox[{"(", 
       RowBox[{"Sign", "[", 
        RowBox[{
         RowBox[{"#", "[", 
          RowBox[{"[", "2", "]"}], "]"}], "-", 
         RowBox[{"#", "[", 
          RowBox[{"[", "1", "]"}], "]"}]}], "]"}], ")"}], "&"}], ",", " ", 
     RowBox[{"Partition", "[", 
      RowBox[{"v", ",", "2", ",", "1"}], "]"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"values", " ", "=", " ", 
  RowBox[{"RandomInteger", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{
      RowBox[{"-", "10"}], ",", "10"}], "}"}], ",", "20"}], 
   "]"}]}], "\[IndentingNewLine]", 
 RowBox[{"Show", "[", 
  RowBox[{
   RowBox[{"ListLinePlot", "[", "values", "]"}], ",", 
   RowBox[{"With", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"s", "=", 
       RowBox[{"shape", "[", "values", "]"}]}], "}"}], ",", 
     RowBox[{"DiscretePlot", "[", 
      RowBox[{
       RowBox[{"s", "[", 
        RowBox[{"[", "i", "]"}], "]"}], ",", " ", 
       RowBox[{"{", 
        RowBox[{"i", ",", " ", "1", ",", " ", "19"}], "}"}]}], "]"}]}], 
    "]"}]}], " ", "]"}]}], "Input",
 CellChangeTimes->{{3.732867759983819*^9, 3.732867892991029*^9}, {
  3.732867923527175*^9, 3.73286792559752*^9}, {3.7328680341173058`*^9, 
  3.73286806676324*^9}, {3.732868097644329*^9, 3.732868173275302*^9}, {
  3.7328682324333677`*^9, 3.732868245936182*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"8", ",", "10", ",", 
   RowBox[{"-", "8"}], ",", "1", ",", "8", ",", "1", ",", 
   RowBox[{"-", "5"}], ",", 
   RowBox[{"-", "5"}], ",", 
   RowBox[{"-", "4"}], ",", 
   RowBox[{"-", "3"}], ",", "8", ",", "1", ",", "0", ",", "4", ",", "4", ",", 
   "5", ",", 
   RowBox[{"-", "3"}], ",", 
   RowBox[{"-", "10"}], ",", 
   RowBox[{"-", "10"}], ",", "5"}], "}"}]], "Output",
 CellChangeTimes->{{3.732867842329208*^9, 3.7328678617022953`*^9}, 
   3.732867893647382*^9, 3.732867926296028*^9, 3.732868067487266*^9, {
   3.7328681380719624`*^9, 3.7328681740288973`*^9}, 3.7328683418937073`*^9, 
   3.732970573980991*^9, 3.7330449541429663`*^9, 3.733050949249135*^9, 
   3.733051369192881*^9, 3.733057950143545*^9, 3.7330659383047*^9, 
   3.733074326086164*^9, 3.733080123663783*^9, 3.733125518993058*^9, 
   3.7331284038370113`*^9, 3.7331334531269283`*^9, 3.73321095742274*^9, 
   3.7332126726922827`*^9, 3.733212967450708*^9, 3.7332160813185797`*^9, 
   3.733216236636256*^9, 3.733221928452394*^9, 3.733270004093041*^9, 
   3.7332778133737993`*^9},
 FontSize->14],

Cell[BoxData[
 GraphicsBox[{{{}, {{}, {}, 
     {RGBColor[0.368417, 0.506779, 0.709798], PointSize[
      0.019444444444444445`], AbsoluteThickness[1.6], LineBox[CompressedData["

1:eJxTTMoPSmViYGAQAWIQDQEf7CG0ggNUAEqrQGkOKK1wAEILOKDqE4HJQ2kJ
NHkZKF/kAKo6GF8Jyhc4gGYvlK+GZr4GmvlaMHdDgQ7MPCith8Y3gNkPpQ3R
7DOC8lWgfGM0vglcPwD7kRdM
       "]]}}, {}}, {
    {RGBColor[0.368417, 0.506779, 0.709798], PointSize[0.019444444444444445`],
      AbsoluteThickness[1.6], {
      {RGBColor[0.368417, 0.506779, 0.709798], PointSize[
       0.019444444444444445`], AbsoluteThickness[1.6], Opacity[0.2], 
       LineBox[{{{2., -1.}, {2., 0}}, {{5., -1.}, {5., 0}}, {{6., -1.}, {
          6., 0}}, {{7., 0.}, {7., 0}}, {{11., -1.}, {11., 0}}, {{12., -1.}, {
          12., 0}}, {{14., 0.}, {14., 0}}, {{16., -1.}, {16., 0}}, {{
          17., -1.}, {17., 0}}, {{18., 0.}, {18., 0}}},
        VertexColors->None]}, 
      {RGBColor[0.368417, 0.506779, 0.709798], PointSize[
       0.019444444444444445`], AbsoluteThickness[1.6], Opacity[0.2], 
       LineBox[{{{1., 1.}, {1., 0}}, {{3., 1.}, {3., 0}}, {{4., 1.}, {
          4., 0}}, {{8., 1.}, {8., 0}}, {{9., 1.}, {9., 0}}, {{10., 1.}, {
          10., 0}}, {{13., 1.}, {13., 0}}, {{15., 1.}, {15., 0}}, {{19., 
          1.}, {19., 0}}},
        VertexColors->None]}}}, 
    {RGBColor[0.368417, 0.506779, 0.709798], PointSize[0.019444444444444445`],
      AbsoluteThickness[1.6], {}, PointBox[CompressedData["
1:eJxTTMoPSmViYGAQBmIQDQEf7FFpBgcofz+E5nBAlRdA44ugqZdA48s4MKAA
BTT9Smh8FTS+Gpp5Gmh8LTT1Omj26aHJG6DpN0TjG6HpN4brBwCbVyA+
      "]], {}}}},
  AspectRatio->NCache[GoldenRatio^(-1), 0.6180339887498948],
  Axes->{True, True},
  AxesLabel->{None, None},
  AxesOrigin->{0, 0},
  DisplayFunction->Identity,
  Frame->{{False, False}, {False, False}},
  FrameLabel->{{None, None}, {None, None}},
  FrameTicks->{{Automatic, Automatic}, {Automatic, Automatic}},
  GridLines->{None, None},
  GridLinesStyle->Directive[
    GrayLevel[0.5, 0.4]],
  Method->{},
  PlotRange->{{0., 20.}, {-10., 10.}},
  PlotRangeClipping->True,
  PlotRangePadding->{{
     Scaled[0.02], 
     Scaled[0.02]}, {
     Scaled[0.05], 
     Scaled[0.05]}},
  Ticks->{Automatic, Automatic}]], "Output",
 CellChangeTimes->{{3.732867842329208*^9, 3.7328678617022953`*^9}, 
   3.732867893647382*^9, 3.732867926296028*^9, 3.732868067487266*^9, {
   3.7328681380719624`*^9, 3.7328681740288973`*^9}, 3.7328683418937073`*^9, 
   3.732970573980991*^9, 3.7330449541429663`*^9, 3.733050949249135*^9, 
   3.733051369192881*^9, 3.733057950143545*^9, 3.7330659383047*^9, 
   3.733074326086164*^9, 3.733080123663783*^9, 3.733125518993058*^9, 
   3.7331284038370113`*^9, 3.7331334531269283`*^9, 3.73321095742274*^9, 
   3.7332126726922827`*^9, 3.733212967450708*^9, 3.7332160813185797`*^9, 
   3.733216236636256*^9, 3.733221928452394*^9, 3.733270004093041*^9, 
   3.733277813505571*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "Under Java, these problems are intended to be solved with a single for-loop \
that maintains some kind of state information that allows it to determine if \
there has been a violation in the requirement for the shape. In ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", we aim for a more functional approach. The first question is just a \
simple counting question to get the students started with these definitions, \
asking to compute the number of positions in the array that are upsteps."
}], "Text",
 CellChangeTimes->{{3.732868192987133*^9, 3.732868216136384*^9}, {
  3.73286829994875*^9, 3.732868303149948*^9}, {3.7328683548454447`*^9, 
  3.7328683558200083`*^9}, {3.733044930238928*^9, 3.7330449351278887`*^9}, {
  3.733063058763425*^9, 3.733063063755025*^9}, {3.733214373033947*^9, 
  3.7332143884948273`*^9}, {3.733274080053155*^9, 3.733274109145525*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"countUpsteps", "[", "v_", "]"}], " ", ":=", " ", 
   RowBox[{"Count", "[", 
    RowBox[{
     RowBox[{"shape", "[", "v", "]"}], ",", " ", "1"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"countUpsteps", "[", "values", "]"}]}], "Input",
 CellChangeTimes->{{3.7328682206338987`*^9, 3.7328682241762238`*^9}, {
  3.732868262238357*^9, 3.73286833512507*^9}, {3.7330449591324787`*^9, 
  3.733044961531467*^9}},
 FontSize->14],

Cell[BoxData["9"], "Output",
 CellChangeTimes->{{3.732868314563944*^9, 3.7328683444650383`*^9}, 
   3.732970574365881*^9, 3.733044962114512*^9, 3.73305094939869*^9, 
   3.7330513694956827`*^9, 3.733057950594728*^9, 3.733065938856242*^9, 
   3.733074326796308*^9, 3.7330801241295567`*^9, 3.733125519481669*^9, 
   3.7331284041565647`*^9, 3.733133453559348*^9, 3.733210957886701*^9, 
   3.733212673152831*^9, 3.7332129676177998`*^9, 3.733216081525824*^9, 
   3.733216236869686*^9, 3.733221928864778*^9, 3.73327000426075*^9, 
   3.73327781359046*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "The second question asks the method to determine whether two arrays of same \
length have the exact same shape. The short solution with ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " can be quite slow since it calculates the entire shape for both lists even \
when the first two elements would already determine that the answer is ",
 StyleBox["False",
  FontWeight->"Bold"],
 ". This seems a bit silly when these lists contain a million elements each, \
so perhaps we shall here grant a point for the imperative approach. After \
all, there is probably some good reason why real programmers don\
\[CloseCurlyQuote]t use pure functional programming for everything and, as \
the famous quip points out, nobody had yet to write an operating system \
kernel in a functional programming language. (As discussed in the late \
excellent blog \[OpenCurlyDoubleQuote]",
 ButtonBox["Programming in the 21st Century",
  BaseStyle->"Hyperlink",
  ButtonData->{
    URL["http://prog21.dadgum.com/"], None},
  ButtonNote->"http://prog21.dadgum.com/"],
 "\[CloseCurlyDoubleQuote], even writing a simple real time arcade game such \
as ",
 StyleBox["Pacman",
  FontSlant->"Italic"],
 " or ",
 StyleBox["Space Invaders",
  FontSlant->"Italic"],
 ", a task that a bunch of longhair potheads somehow managed to finish and \
ship on an industrial scale back in the seventies using programming \
environments that would make today\[CloseCurlyQuote]s programmers run home \
crying for mommy, is surprisingly difficult to do using the finest pure \
functional programming languages of our time. So something is clearly wrong \
with this entire big picture, although it is hard to put in words exactly \
what that something could be.) "
}], "Text",
 CellChangeTimes->{{3.732868376252758*^9, 3.732868397243458*^9}, {
  3.732868522954423*^9, 3.73286864444733*^9}, {3.733044972598742*^9, 
  3.733045016261756*^9}, {3.733063078363015*^9, 3.733063259194561*^9}, {
  3.7331332097087183`*^9, 3.733133272251595*^9}, {3.733214408554153*^9, 
  3.733214456095029*^9}, {3.73327411579373*^9, 3.7332741949617443`*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"sameStepShape", "[", 
    RowBox[{"v1_", ",", "v2_"}], "]"}], " ", ":=", " ", 
   RowBox[{
    RowBox[{"shape", "[", "v1", "]"}], " ", "\[Equal]", " ", 
    RowBox[{"shape", "[", "v2", "]"}]}]}], ";"}]], "Input",
 CellChangeTimes->{{3.7328684029168577`*^9, 3.732868407139531*^9}, {
  3.732868451428252*^9, 3.732868456978979*^9}},
 FontSize->14],

Cell[TextData[{
 "The third question is a bit more interesting in that it asks for a method \
that can determine whether the shape of its parameter array is a ",
 StyleBox["sawtooth",
  FontSlant->"Italic"],
 " so that the array contains no plateaus, and every upstep is immediately \
followed by a downstep and vice versa. The absolute magnitudes of these \
upsteps and downsteps do not matter, only the fact that the ",
 StyleBox["forward differences",
  FontSlant->"Italic"],
 " need to alternate with respect to their signs. The first step can be \
either an upstep or a downstep, and the method has to work correctly for \
either one. The intended Java solution might look something like the \
following, if it were \[OpenCurlyDoubleQuote]transpreted\
\[CloseCurlyDoubleQuote] (to coin a term) directly to ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ". The local variable ",
 StyleBox["prev",
  FontWeight->"Bold"],
 " remembers the direction of the step in the previous position, and if the \
current step ",
 StyleBox["curr",
  FontWeight->"Bold"],
 " is ever equal to ",
 StyleBox["prev",
  FontWeight->"Bold"],
 ", we have found a violation of the definition of the sawtooth shape and can \
terminate the function right away without looking at the rest of the \
elements. (Beginning students sometimes find it difficult to understand that \
if the method verifies an universal claim, it can stop and return ",
 StyleBox["false",
  FontWeight->"Bold"],
 " at the first counterexample and ignore the rest of the elements, but that \
method cannot return ",
 StyleBox["true",
  FontWeight->"Bold"],
 " until it has looked at the entire array. Such seemingly obvious things are \
not always that obvious to beginners, especially if they also happen to feel \
that every if-statement must also include an else that does something.)"
}], "Text",
 CellChangeTimes->{{3.7328686805198393`*^9, 3.732868757453669*^9}, {
  3.732868916980549*^9, 3.732868976338254*^9}, {3.7328690696357*^9, 
  3.732869131032317*^9}, {3.733063267641006*^9, 3.733063349600865*^9}, {
  3.733073686275593*^9, 3.733073709657398*^9}, {3.7332145077433453`*^9, 
  3.7332146116992617`*^9}, {3.7332742197728167`*^9, 3.733274294311747*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"isSawtoothLoop", "[", "v_", "]"}], " ", ":=", " ", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"i", ",", " ", 
       RowBox[{"isGood", " ", "=", " ", "True"}], ",", " ", 
       RowBox[{"prev", " ", "=", " ", "0"}], ",", " ", "curr"}], "}"}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"For", "[", 
       RowBox[{
        RowBox[{"i", " ", "=", " ", "1"}], ",", " ", 
        RowBox[{"i", " ", "<", " ", 
         RowBox[{"Length", "[", "v", "]"}]}], ",", " ", 
        RowBox[{"i", "++"}], ",", "\[IndentingNewLine]", 
        RowBox[{
         RowBox[{"curr", " ", "=", " ", 
          RowBox[{"Sign", "[", 
           RowBox[{
            RowBox[{"v", "[", 
             RowBox[{"[", 
              RowBox[{"i", "+", "1"}], "]"}], "]"}], " ", "-", " ", 
            RowBox[{"v", "[", 
             RowBox[{"[", "i", "]"}], "]"}]}], "]"}]}], ";", 
         "\[IndentingNewLine]", 
         RowBox[{"If", "[", 
          RowBox[{
           RowBox[{
            RowBox[{"curr", " ", "\[Equal]", " ", "0"}], " ", "||", " ", 
            RowBox[{"curr", " ", "\[Equal]", " ", "prev"}]}], ",", " ", 
           RowBox[{
            RowBox[{"isGood", " ", "=", " ", "False"}], ";", " ", "Break"}]}],
           "]"}], ";", "\[IndentingNewLine]", 
         RowBox[{"prev", " ", "=", " ", "curr"}], ";"}]}], 
       "\[IndentingNewLine]", "]"}], ";", "\[IndentingNewLine]", "isGood"}]}],
     "\[IndentingNewLine]", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"isSawtoothLoop", "[", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"-", "1"}], ",", " ", "10", ",", " ", "7", ",", " ", "9", ",", 
    " ", 
    RowBox[{"-", "2"}], ",", " ", "0", ",", " ", 
    RowBox[{"-", "2"}]}], "}"}], "]"}]}], "Input",
 CellChangeTimes->{{3.732868761495091*^9, 3.73286891294016*^9}, {
  3.7328689859627*^9, 3.73286901591427*^9}, {3.732869147648786*^9, 
  3.73286916533584*^9}, {3.73286922367242*^9, 3.732869226742741*^9}, {
  3.7328695416265783`*^9, 3.7328695450262117`*^9}},
 FontSize->14],

Cell[BoxData["True"], "Output",
 CellChangeTimes->{{3.732869006628364*^9, 3.732869021357511*^9}, {
   3.732869148622889*^9, 3.732869162925638*^9}, 3.732869228271111*^9, 
   3.732970574482307*^9, 3.7330509494988203`*^9, 3.73305136964643*^9, 
   3.733057950712262*^9, 3.733065938991646*^9, 3.733074327454884*^9, 
   3.733080124263232*^9, 3.733125519610929*^9, 3.73312840432414*^9, 
   3.733133453690304*^9, 3.7332109580359898`*^9, 3.733212673277665*^9, 
   3.733212967971998*^9, 3.733216081642745*^9, 3.733216237203253*^9, 
   3.7332219289814053`*^9, 3.733270004593974*^9, 3.73327781390843*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "One possible one-liner solution more in tune of the logical and functional \
spirit of ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " springs from the realization that the given list is a sawtooth if that \
list itself contains no plateaus, but then also ",
 StyleBox["the shape of its shape",
  FontSlant->"Italic"],
 " contains no plateaus since those would reveal that the original list had \
two consecutive steps of the same sign in those positions. Of course, the \
downside of the following solution is that it computes the entire shape array \
(and then its second-order shape array) even if the answer were already \
determined by the first couple of elements. This approach would therefore \
work much better in Python 3 and its ",
 StyleBox["lazy iterators",
  FontSlant->"Italic"],
 " that never produce any more elements than those actually needed to entail \
the result."
}], "Text",
 CellChangeTimes->{{3.7328691767917*^9, 3.732869215414242*^9}, {
  3.732869406356227*^9, 3.732869490721778*^9}, {3.732869946370799*^9, 
  3.732869969011422*^9}, {3.732870728271633*^9, 3.732870765820158*^9}, {
  3.7330450472214727`*^9, 3.7330450528543777`*^9}, {3.733063371744026*^9, 
  3.7330634509987793`*^9}, {3.733073730816085*^9, 3.733073742784528*^9}, {
  3.733214622404683*^9, 3.733214664977255*^9}, {3.7332743019531193`*^9, 
  3.73327436681388*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"isSawtooth", "[", "v_", "]"}], " ", ":=", 
   RowBox[{"With", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"s", " ", "=", " ", 
       RowBox[{"shape", "[", "v", "]"}]}], "}"}], ",", 
     RowBox[{"And", "[", 
      RowBox[{
       RowBox[{"Not", "[", 
        RowBox[{"MemberQ", "[", 
         RowBox[{"s", ",", " ", "0"}], "]"}], "]"}], ",", " ", 
       RowBox[{"Not", "[", 
        RowBox[{"MemberQ", "[", 
         RowBox[{
          RowBox[{"shape", "[", "s", "]"}], ",", "0"}], "]"}], "]"}]}], 
      "]"}]}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"isSawtooth", "[", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"-", "1"}], ",", " ", "10", ",", " ", "7", ",", " ", "9", ",", 
    " ", 
    RowBox[{"-", "2"}], ",", " ", "0", ",", " ", 
    RowBox[{"-", "2"}], ",", " ", 
    RowBox[{"-", "9"}]}], "}"}], "]"}]}], "Input",
 CellChangeTimes->{{3.732869217926733*^9, 3.732869232686398*^9}, {
  3.732869273366003*^9, 3.732869392108515*^9}},
 FontSize->14],

Cell[BoxData["False"], "Output",
 CellChangeTimes->{{3.732869387151844*^9, 3.7328693925768547`*^9}, 
   3.732970574566575*^9, 3.733050949799716*^9, 3.733051369763391*^9, 
   3.733057950807385*^9, 3.7330659391065273`*^9, 3.7330743275783033`*^9, 
   3.733080124362563*^9, 3.733125519711413*^9, 3.7331284044573183`*^9, 
   3.733133453795265*^9, 3.733210958170123*^9, 3.733212673377448*^9, 
   3.733212968052784*^9, 3.733216081726309*^9, 3.73321623730488*^9, 
   3.733221929065995*^9, 3.733270004677422*^9, 3.733277814008658*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "The last question turned out to be interesting over the years in that many \
students find it surprisingly difficult, but as the hint to this question \
says, this whole question really should be one straightforward loop through \
the array. This question asks for a method that determines whether the given \
array is a ",
 StyleBox["mountain",
  FontSlant->"Italic"],
 " so that its shape first goes up some number of steps (where the word \
\[OpenCurlyDoubleQuote]some\[CloseCurlyDoubleQuote] again means zero or more, \
to emphasize the essential truth that zero is always a possibility in \
programming that the logic of your code needs to be prepared for) and then \
goes down some number of steps (again allowing the same possibility of zero). \
The hint asks you to encode the rule \[OpenCurlyDoubleQuote]One you have gone \
down, you may not go up again\[CloseCurlyDoubleQuote] into an intended Java \
solution that might translate to ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " as the following module."
}], "Text",
 CellChangeTimes->{{3.732869509634491*^9, 3.732869518121459*^9}, {
  3.732869549800706*^9, 3.732869719798538*^9}, {3.732869880604162*^9, 
  3.732869882995638*^9}, {3.733045072215027*^9, 3.7330450724542227`*^9}, {
  3.733063455493372*^9, 3.733063479302401*^9}, {3.733073757089594*^9, 
  3.7330737768880453`*^9}, {3.733214686892046*^9, 3.733214696984974*^9}, {
  3.73327437457659*^9, 3.733274442828692*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"isMountainLoop", "[", "v_", "]"}], " ", ":=", " ", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"i", ",", " ", "step", ",", " ", 
       RowBox[{"isGood", " ", "=", " ", "True"}], ",", " ", 
       RowBox[{"goneDown", " ", "=", " ", "False"}]}], "}"}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"For", "[", 
       RowBox[{
        RowBox[{"i", " ", "=", " ", "1"}], ",", " ", 
        RowBox[{"i", " ", "<", " ", 
         RowBox[{"Length", "[", "v", "]"}]}], ",", " ", 
        RowBox[{"i", "++"}], ",", "\[IndentingNewLine]", 
        RowBox[{
         RowBox[{"step", " ", "=", " ", 
          RowBox[{"Sign", "[", 
           RowBox[{
            RowBox[{"v", "[", 
             RowBox[{"[", 
              RowBox[{"i", "+", "1"}], "]"}], "]"}], " ", "-", " ", 
            RowBox[{"v", "[", 
             RowBox[{"[", "i", "]"}], "]"}]}], "]"}]}], ";", 
         "\[IndentingNewLine]", 
         RowBox[{"If", "[", 
          RowBox[{
           RowBox[{
            RowBox[{"step", " ", "\[Equal]", " ", "0"}], " ", "||", " ", 
            RowBox[{"(", 
             RowBox[{
              RowBox[{"step", " ", "\[Equal]", " ", "1"}], " ", "&&", " ", 
              "goneDown"}], ")"}]}], ",", "  ", 
           RowBox[{
            RowBox[{"isGood", " ", "=", " ", "False"}], ";", " ", "Break"}]}],
           "]"}], ";", "\[IndentingNewLine]", 
         RowBox[{"If", "[", 
          RowBox[{
           RowBox[{"step", " ", "\[Equal]", " ", 
            RowBox[{"-", "1"}]}], ",", " ", 
           RowBox[{"goneDown", " ", "=", " ", "True"}]}], "]"}], ";"}]}], 
       "\[IndentingNewLine]", "]"}], ";", "\[IndentingNewLine]", "isGood"}]}],
     "\[IndentingNewLine]", "]"}]}], ";"}]], "Input",
 CellChangeTimes->{{3.7328697237195883`*^9, 3.732869858957827*^9}, 
   3.732870252167618*^9, 3.732870285935031*^9},
 FontSize->14],

Cell[TextData[{
 "The one-liner solution in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " looks for a position that is a downstep followed by an upstep, thus by its \
existence contradicting the requirement that the list is a mountain."
}], "Text",
 CellChangeTimes->{{3.7328698897722797`*^9, 3.732869929219082*^9}, {
  3.732870039072942*^9, 3.732870074160606*^9}, {3.732870699024383*^9, 
  3.7328707161249247`*^9}, {3.733214708106875*^9, 3.7332147100002832`*^9}, {
  3.733274458278837*^9, 3.733274458835917*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"isMountain", "[", "v_", "]"}], " ", ":=", " ", 
   RowBox[{"With", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"s", " ", "=", " ", 
       RowBox[{"shape", "[", "v", "]"}]}], "}"}], ",", " ", 
     RowBox[{"And", "[", 
      RowBox[{
       RowBox[{"Not", "[", 
        RowBox[{"MemberQ", "[", 
         RowBox[{"s", ",", "0"}], "]"}], "]"}], ",", 
       RowBox[{"Not", "[", 
        RowBox[{"MemberQ", "[", 
         RowBox[{
          RowBox[{"Partition", "[", 
           RowBox[{"s", ",", " ", "2", ",", "1"}], "]"}], ",", " ", 
          RowBox[{"{", 
           RowBox[{
            RowBox[{"-", "1"}], ",", " ", "1"}], "}"}]}], "]"}], "]"}]}], 
      "]"}]}], "]"}]}], ";"}]], "Input",
 CellChangeTimes->{{3.732869934436184*^9, 3.7328699378029423`*^9}, {
  3.7328699864273157`*^9, 3.7328700243936768`*^9}, {3.7328703395080423`*^9, 
  3.732870372411375*^9}, {3.7328704114611683`*^9, 3.732870411522933*^9}},
 FontSize->14],

Cell[TextData[{
 "To convince ourselves that the previous two functions that test whether the \
list is a mountain are equivalent, we can run both functions over a ten \
thousand randomly generated lists of integers to verify that both functions \
produce the same answer for all these lists. This operation can also be \
implemented as a one-liner that generates a list of results of the equality \
comparisons between the results that the functions returned for the same \
randomly generated list, and then turns this list of truth values into a \
logical conjunction by using ",
 StyleBox["Apply",
  FontWeight->"Bold"],
 " (here abbreviated as ",
 StyleBox["@@",
  FontWeight->"Bold"],
 " as is the usual way) to replace its head with ",
 StyleBox["And",
  FontWeight->"Bold"],
 " to quickly determine whether every part of that conjunction is ",
 StyleBox["True",
  FontWeight->"Bold"],
 "."
}], "Text",
 CellChangeTimes->{{3.7328700905290833`*^9, 3.732870129575383*^9}, {
  3.732870440602757*^9, 3.732870669814156*^9}, {3.733274481839817*^9, 
  3.7332745449960213`*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"And", " ", "@@", " ", 
  RowBox[{"Table", "[", "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"With", "[", 
     RowBox[{
      RowBox[{"{", 
       RowBox[{"v", " ", "=", " ", 
        RowBox[{"RandomInteger", "[", 
         RowBox[{
          RowBox[{"{", 
           RowBox[{
            RowBox[{"-", "10"}], ",", "10"}], "}"}], ",", 
          RowBox[{"RandomInteger", "[", 
           RowBox[{"{", 
            RowBox[{"1", ",", " ", "20"}], "}"}], "]"}]}], "]"}]}], "}"}], 
      ",", "\[IndentingNewLine]", 
      RowBox[{
       RowBox[{"isMountainLoop", "[", "v", "]"}], " ", "\[Equal]", " ", 
       RowBox[{"isMountain", "[", "v", "]"}]}]}], "\[IndentingNewLine]", 
     "]"}], ",", 
    RowBox[{"{", 
     RowBox[{"i", ",", " ", "1", ",", " ", "10000"}], "}"}]}], 
   "]"}]}]], "Input",
 CellChangeTimes->{{3.73287013696885*^9, 3.732870138008174*^9}, {
  3.732870169922193*^9, 3.732870221430472*^9}, {3.732870275118937*^9, 
  3.732870327588132*^9}, {3.732870379747554*^9, 3.7328704346425877`*^9}, {
  3.7328705152433367`*^9, 3.7328705171051273`*^9}, {3.732870572681306*^9, 
  3.732870583362611*^9}, {3.732870784256844*^9, 3.732870784316608*^9}},
 FontSize->14],

Cell[BoxData["True"], "Output",
 CellChangeTimes->{{3.732870230216527*^9, 3.732870328401327*^9}, {
   3.7328703768166018`*^9, 3.7328704361768837`*^9}, 3.73287058596612*^9, 
   3.732870786251399*^9, 3.7329705758925962`*^9, 3.7330509510909977`*^9, 
   3.7330513711152077`*^9, 3.733057952113068*^9, 3.733065940547243*^9, 
   3.733074329125668*^9, 3.733080125709264*^9, 3.733125521021551*^9, 
   3.733128406204867*^9, 3.733133455168347*^9, 3.733210959734468*^9, 
   3.733212674683852*^9, 3.7332129698550587`*^9, 3.7332160831091433`*^9, 
   3.733216238616111*^9, 3.733221930563512*^9, 3.733270006010989*^9, 
   3.733277815343358*^9},
 FontSize->14]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[StyleBox["Lab Seven: Two-dimensional arrays",
 FontSize->36]], "Chapter",
 CellChangeTimes->{{3.732870817708276*^9, 3.732870942417152*^9}, {
  3.732871605768173*^9, 3.732871718667369*^9}},
 FontSize->14],

Cell[TextData[{
 StyleBox["Having received enough theory and practice for how to think about \
one-dimensional arrays and how they are processed by looping through their \
elements one step at the time, the seventh lab of this course expands this \
thinking into the second dimension, which then should naturally generalize to \
arbitrary higher dimensions among the denizens of the human ", "Text",
  FontSize->14],
 StyleBox["Flatland", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[". After all, as the famous ", "Text",
  FontSize->14],
 StyleBox["zero-one-infinity", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" principle that the author also loves to point out to his students \
whenever he spots it somewhere puts it; allowing none is fine, and allowing \
just one is also fine, but once you allow there to be two of something, you \
must then allow any number of that something.\nThe key to writing Java code \
that works on higher-dimensional arrays is the plain realization that Java \
really only has ", "Text",
  FontSize->14],
 StyleBox["scalars", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" and one-dimensional arrays in the core language. What looks like, \
acts like and quacks like a two-dimensional array is in reality a \
one-dimensional array whose elements just also happen to be one-dimensional \
arrays. This flash of realization explains why it is a perfectly legal and \
meaningful operation to index a two-dimensional array using only one index; \
why the ", "Text",
  FontSize->14],
 StyleBox["length", "Text",
  FontSize->14,
  FontWeight->"Bold"],
 StyleBox[" of the two-dimensional array gives its number of rows; why the \
two-dimensional array can be ", "Text",
  FontSize->14],
 StyleBox["ragged", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" so that its rows have different lengths; and why an entire row of \
a two-dimensional array can be reassigned or swapped in O(1) time. The same \
principle also happens to be how ", "Text",
  FontSize->14],
 StyleBox["Mathematica ", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox["works, so that its ", "Text",
  FontSize->14],
 StyleBox["n", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox["-dimensional ", "Text",
  FontSize->14],
 StyleBox["tensors", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" are really just linear lists whose elements are ", "Text",
  FontSize->14],
 StyleBox["n ", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox["- 1 dimensional tensors, and can be treated and processed just \
like any other list. (Due to the lack of strong expliclt typing during the \
compile time, the elements of ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" tensors do not all need to have the same dimension.)\nThe first \
question asks for a method to create the transpose of the two-dimensional \
array whose each row is guaranteed to have the same number of elements for \
this operation to be meaningful. This, of course, is just the ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" built-in function ", "Text",
  FontSize->14],
 StyleBox["Transpose", "Text",
  FontSize->14,
  FontWeight->"Bold"],
 StyleBox[", so there is little point in giving this function a new name of \
our own. The second question of this week\[CloseCurlyQuote]s lab is more \
interesting, as it asks for a method that generates a one-dimensional array \
that contains the ", "Text",
  FontSize->14],
 StyleBox["row minimums", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" of the argument two-dimensional array. To again emphasize the \
idea that zero is always a possibility in programming that the logic of your \
code needs to be able to tolerate and handle without crashing, the method is \
expected to work even if some row has zero elements. The method specification \
defines the row minimum to be zero in that case. (In retrospect, the positive \
infinity would have been a more appropriate value for the minimum of an empty \
row.)", "Text",
  FontSize->14]
}], "Text",
 CellChangeTimes->{
  3.733058207159944*^9, {3.733063500917757*^9, 3.733063536878455*^9}, {
   3.73307088465578*^9, 3.733070949014023*^9}, {3.733073792857645*^9, 
   3.733073891310896*^9}, {3.733214723774084*^9, 3.7332149218627577`*^9}, {
   3.733274555145876*^9, 3.733274812736595*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"rowMin", "[", 
    RowBox[{"{", "}"}], "]"}], " ", ":=", " ", "0"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"rowMin", "[", "list_", "]"}], " ", ":=", " ", 
   RowBox[{"Min", "[", "list", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"minValues", "[", "a_", "]"}], " ", ":=", " ", 
   RowBox[{"Map", "[", 
    RowBox[{"rowMin", ",", " ", "a"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"minValues", "[", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{
      RowBox[{"-", "2"}], ",", "9", ",", " ", "42", ",", " ", 
      RowBox[{"-", "17"}]}], "}"}], ",", " ", 
    RowBox[{"{", "}"}], ",", " ", 
    RowBox[{"{", 
     RowBox[{"5", ",", " ", "2", ",", " ", 
      RowBox[{"-", "4"}], ",", " ", "9"}], "}"}]}], "}"}], "]"}]}], "Input",
 CellChangeTimes->{{3.7328718992751837`*^9, 3.7328719623213367`*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"-", "17"}], ",", "0", ",", 
   RowBox[{"-", "4"}]}], "}"}]], "Output",
 CellChangeTimes->{3.732871963558546*^9, 3.7329705760672197`*^9, 
  3.733050951269979*^9, 3.733051371467946*^9, 3.733057952350645*^9, 
  3.7330659408486233`*^9, 3.733074329413254*^9, 3.733080125985469*^9, 
  3.733125521253853*^9, 3.7331284064665194`*^9, 3.7331334554470797`*^9, 
  3.7332126749272842`*^9, 3.733212970056604*^9, 3.73321608351161*^9, 
  3.7332162388577023`*^9, 3.7332219307832327`*^9, 3.733270006227981*^9, 
  3.733277815575001*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "The third question asks for a method that creates and returns a new \
two-dimensional array that has the given number of ",
 StyleBox["rows",
  FontSlant->"Italic"],
 " and ",
 StyleBox["columns",
  FontSlant->"Italic"],
 ", its elements consisting of the numbers from ",
 StyleBox["start",
  FontSlant->"Italic"],
 " counting upwards placed in the rows of this array but so that in every \
other row, these numbers are placed right to left instead of left to right. \
This matrix is easy to construct by partitioning the one-dimensional list of \
the required elements into the desired rows, followed by using ",
 StyleBox["MapIndexed",
  FontWeight->"Bold"],
 " to reverse the sublists located in even-numbered rows, here again using ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " one-based counting."
}], "Text",
 CellChangeTimes->{{3.7328719845453777`*^9, 3.732872077182643*^9}, {
  3.732872199261615*^9, 3.7328722609168043`*^9}, {3.7330635892115297`*^9, 
  3.733063605130663*^9}, {3.733073995884727*^9, 3.7330740267702713`*^9}, {
  3.733214942143622*^9, 3.73321495283652*^9}, {3.733274819626008*^9, 
  3.733274848550074*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"zigzagOrder", "[", 
    RowBox[{"list_", ",", " ", "idx_"}], "]"}], " ", ":=", " ", 
   RowBox[{"If", "[", 
    RowBox[{
     RowBox[{
      RowBox[{"Mod", "[", 
       RowBox[{
        RowBox[{"First", "[", "idx", "]"}], ",", " ", "2"}], "]"}], 
      "\[Equal]", "1"}], ",", " ", "list", ",", " ", 
     RowBox[{"Reverse", "[", "list", "]"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"zigzag", "[", 
    RowBox[{"rows_", ",", " ", "cols_", ",", " ", "start_"}], "]"}], " ", ":=",
    " ", 
   RowBox[{"MapIndexed", "[", 
    RowBox[{"zigzagOrder", ",", " ", 
     RowBox[{"Partition", "[", 
      RowBox[{
       RowBox[{"Range", "[", 
        RowBox[{"start", ",", " ", 
         RowBox[{"start", " ", "+", " ", 
          RowBox[{"rows", " ", "*", " ", "cols"}]}]}], "]"}], ",", " ", 
       "cols"}], "]"}]}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"zigzag", "[", 
   RowBox[{"6", ",", " ", "12", ",", " ", "10"}], "]"}], " ", "//", " ", 
  "MatrixForm"}]}], "Input",
 CellChangeTimes->{{3.73287208430442*^9, 3.732872190072124*^9}, {
  3.732951772354513*^9, 3.732951776468182*^9}},
 FontSize->14],

Cell[BoxData[
 TagBox[
  RowBox[{"(", "\[NoBreak]", GridBox[{
     {"10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", 
      "21"},
     {"33", "32", "31", "30", "29", "28", "27", "26", "25", "24", "23", 
      "22"},
     {"34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", 
      "45"},
     {"57", "56", "55", "54", "53", "52", "51", "50", "49", "48", "47", 
      "46"},
     {"58", "59", "60", "61", "62", "63", "64", "65", "66", "67", "68", 
      "69"},
     {"81", "80", "79", "78", "77", "76", "75", "74", "73", "72", "71", "70"}
    },
    GridBoxAlignment->{
     "Columns" -> {{Center}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
      "RowsIndexed" -> {}},
    GridBoxSpacings->{"Columns" -> {
        Offset[0.27999999999999997`], {
         Offset[0.7]}, 
        Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
        Offset[0.2], {
         Offset[0.4]}, 
        Offset[0.2]}, "RowsIndexed" -> {}}], "\[NoBreak]", ")"}],
  Function[BoxForm`e$, 
   MatrixForm[BoxForm`e$]]]], "Output",
 CellChangeTimes->{{3.732872137764797*^9, 3.732872190870234*^9}, 
   3.732951778853209*^9, 3.7329705761541*^9, 3.733050951336647*^9, 
   3.733051371601571*^9, 3.733057952434299*^9, 3.733065940965119*^9, 
   3.733074329530731*^9, 3.733080126085408*^9, 3.733125521348879*^9, 
   3.733128406594307*^9, 3.7331334555674953`*^9, 3.7332126750330467`*^9, 
   3.73321297014256*^9, 3.733216083664598*^9, 3.733216238961473*^9, 
   3.7332219308711576`*^9, 3.7332700062895412`*^9, 3.73327781566295*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "The last question of this week treats the rows of the two-dimensional array \
as coordinates of points located in three-dimensional Cartesian space, so the \
question comes with a guarantee that every row of the parameter array \
contains exactly three elements, for the question to make sense to begin \
with. The required task is to find an ",
 StyleBox["antipodal pair",
  FontSlant->"Italic"],
 " of points whose distance from each other is as large as possible, and \
return that distance. This question would be an interesting exercise for a \
course in ",
 StyleBox["combinatorial geometry",
  FontSlant->"Italic"],
 ", but here in the first regular programming course instead of fancy \
programming course, we are content with the quadratic time all-pairs brute \
force solution. Since ",
 StyleBox["Subsets",
  FontWeight->"Bold"],
 " is a handy way to generate the list of all possible pairs, triples and \
higher-uples of elements, this entire function can again be written as a \
one-liner, followed by another line to handle the corner cases of a singleton \
set or or an empty set. In ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", the same function can handle points in arbitrary dimensions. The distance \
metric also does not need to be hardcoded into the function, but the next \
example shows how to write a ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " function to take optional arguments that, since the language makes no \
distinction between symbolic expressions that are code and data, can \
themselves be functions."
}], "Text",
 CellChangeTimes->{{3.732873613607986*^9, 3.7328736958935833`*^9}, {
  3.7328738315392723`*^9, 3.732873912369999*^9}, {3.733045225466522*^9, 
  3.7330452383154078`*^9}, {3.7330636878976107`*^9, 3.733063703315074*^9}, {
  3.73306374618659*^9, 3.733063750410241*^9}, {3.7330640917558317`*^9, 
  3.733064102276972*^9}, {3.733064239296296*^9, 3.733064243097527*^9}, {
  3.733064296536622*^9, 3.733064324608*^9}, {3.7330646997840843`*^9, 
  3.7330647003617077`*^9}, {3.733065084116736*^9, 3.733065106817367*^9}, {
  3.733073952646257*^9, 3.7330739532371607`*^9}, {3.733074166191444*^9, 
  3.73307417312374*^9}, {3.733214962167943*^9, 3.733215045251567*^9}, {
  3.733274876649036*^9, 3.7332749692846003`*^9}, {3.733275019243973*^9, 
  3.7332750883630743`*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"maximumDistance", "[", 
    RowBox[{
     RowBox[{"pts_List", " ", "/;", " ", 
      RowBox[{
       RowBox[{"Length", "[", "pts", "]"}], " ", ">", " ", "1"}]}], ",", " ", 
     
     RowBox[{"df_:", " ", "EuclideanDistance"}]}], "]"}], " ", ":=", 
   RowBox[{"Max", "[", 
    RowBox[{"Map", "[", 
     RowBox[{
      RowBox[{
       RowBox[{"df", "[", 
        RowBox[{
         RowBox[{"#", "[", 
          RowBox[{"[", "1", "]"}], "]"}], ",", 
         RowBox[{"#", "[", 
          RowBox[{"[", "2", "]"}], "]"}]}], "]"}], "&"}], ",", " ", 
      RowBox[{"Subsets", "[", 
       RowBox[{"pts", ",", " ", 
        RowBox[{"{", "2", "}"}]}], "]"}]}], "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"maximumDistance", "[", 
    RowBox[{"pts_List", ",", " ", 
     RowBox[{"df_:", " ", "EuclideanDistance"}]}], "]"}], " ", ":=", " ", 
   "0"}], ";"}]}], "Input",
 CellChangeTimes->{{3.7328737746700373`*^9, 3.732873888195225*^9}, 
   3.732873932988819*^9, {3.733045246290524*^9, 3.733045270981162*^9}, {
   3.733063658404086*^9, 3.733063671994343*^9}, {3.73306375572156*^9, 
   3.733063761634671*^9}, {3.733064036249659*^9, 3.7330640411425543`*^9}, {
   3.733064336936254*^9, 3.7330643902077837`*^9}, {3.733064497292614*^9, 
   3.733064499781843*^9}, {3.733064557724432*^9, 3.733064573028668*^9}, {
   3.7330646037323647`*^9, 3.7330646127909193`*^9}, {3.733064648457893*^9, 
   3.733064717939996*^9}, {3.7330647559417973`*^9, 3.7330647648383923`*^9}, {
   3.733274975944756*^9, 3.733274996859873*^9}},
 FontSize->14],

Cell[TextData[{
 "Just to do something interesting with this problem, let us compute the \
average maximum distance within the set of uniformly chosen random points \
inside the unit rectangle, as a function of the number of points in the set. \
As ",
 StyleBox["n",
  FontSlant->"Italic"],
 " increases, this ought to converge to the diameter of the unit rectangle, \
which is the square root of two."
}], "Text",
 CellChangeTimes->{{3.733063785400895*^9, 3.7330638593503647`*^9}, {
  3.73306405816413*^9, 3.733064065229114*^9}, {3.733064423422132*^9, 
  3.7330644239901047`*^9}, {3.7330649364452667`*^9, 3.733064973301083*^9}, {
  3.733065917452154*^9, 3.733065935765767*^9}, {3.733073963837134*^9, 
  3.733073964412648*^9}, {3.733125405021728*^9, 3.7331254288554497`*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"distanceSample", "[", "n_", "]"}], " ", ":=", " ", 
   RowBox[{"maximumDistance", "[", 
    RowBox[{"RandomReal", "[", 
     RowBox[{
      RowBox[{"{", 
       RowBox[{"0", ",", "1"}], "}"}], ",", 
      RowBox[{"{", 
       RowBox[{"n", ",", "3"}], "}"}]}], "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"distanceTrial", "[", 
    RowBox[{"n_", ",", " ", "trials_"}], "]"}], " ", ":=", " ", 
   RowBox[{"Mean", "[", 
    RowBox[{"Table", "[", 
     RowBox[{
      RowBox[{"distanceSample", "[", "n", "]"}], ",", " ", 
      RowBox[{"{", "trials", "}"}]}], "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"BarChart", "[", 
  RowBox[{
   RowBox[{"Table", "[", 
    RowBox[{
     RowBox[{"distanceTrial", "[", 
      RowBox[{"i", ",", " ", "1000"}], "]"}], ",", " ", 
     RowBox[{"{", 
      RowBox[{"i", ",", " ", "2", ",", " ", "30"}], "}"}]}], "]"}], ",", " ", 
   
   RowBox[{"ChartStyle", " ", "\[Rule]", " ", "\"\<Pastel\>\""}]}], 
  "]"}]}], "Input",
 CellChangeTimes->{{3.733063866063032*^9, 3.73306400749693*^9}, {
  3.733064212980255*^9, 3.733064213059228*^9}, {3.733064351592647*^9, 
  3.733064352358385*^9}, {3.733064466119947*^9, 3.733064478121552*^9}, {
  3.733064771689659*^9, 3.733064790551313*^9}, {3.733064891286037*^9, 
  3.7330649027093153`*^9}, {3.7330649771005993`*^9, 3.733064983821856*^9}, {
  3.7331252451509037`*^9, 3.733125318392208*^9}},
 FontSize->14],

Cell[BoxData[
 GraphicsBox[{
   {Opacity[0], PointBox[{-0.045527544351073757`, 0.}]}, {{}, 
    {RGBColor[0.982864, 0.7431472, 0.3262672], EdgeForm[{Opacity[
     0.49699999999999994`], Thickness[Small]}], 
     {RGBColor[0.761959, 0.470832, 0.940597], EdgeForm[{Opacity[
      0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{0.5331465919701214, 0.}, {1.4668534080298787`, 
            0.660069095859658}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{15.638232525546977`, 23.503390309280988`}, {
           1.010908608403895, 73.788}}],
         StatusArea[#, 0.660069095859658]& ,
         TagBoxNote->"0.660069095859658"],
        StyleBox["0.660069095859658`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.660069095859658, {}], "Tooltip"]& ]}, 
     {RGBColor[0.7807124285714286, 0.5159265, 0.9455752857142857], EdgeForm[{
      Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{1.5331465919701215`, 0.}, {2.4668534080298787`, 
            0.8427411636363583}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{23.67625651192609, 
           31.541414295660104`}, {-19.030296031920244`, 73.78800000000001}}],
         StatusArea[#, 0.8427411636363583]& ,
         TagBoxNote->"0.8427411636363583"],
        StyleBox["0.8427411636363583`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.8427411636363583, {}], "Tooltip"]& ]}, 
     {RGBColor[0.7994658571428572, 0.561021, 0.9505535714285714], EdgeForm[{
      Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{2.5331465919701217`, 0.}, {3.4668534080298787`, 
            0.9372707275534462}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{31.714280498305207`, 
           39.57943828203921}, {-29.4012649385557, 73.78799999999998}}],
         StatusArea[#, 0.9372707275534462]& ,
         TagBoxNote->"0.9372707275534462"],
        StyleBox["0.9372707275534462`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[0.9372707275534462, {}], "Tooltip"]& ]}, 
     {RGBColor[0.8198412500000001, 0.59669675, 0.9208629285714286], EdgeForm[{
      Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{3.5331465919701217`, 0.}, {4.466853408029879, 
            1.0070996096582876`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{39.752304484684316`, 
           47.61746226841833}, {-37.062287957022306`, 73.78800000000001}}],
         StatusArea[#, 1.0070996096582876`]& ,
         TagBoxNote->"1.0070996096582876"],
        StyleBox["1.0070996096582876`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.0070996096582876`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.842163, 0.62107, 0.8495695714285715], EdgeForm[{Opacity[
      0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{4.533146591970121, 0.}, {5.466853408029879, 
            1.0481176711992486`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{47.790328471063425`, 
           55.65548625479744}, {-41.56243609295237, 73.78800000000001}}],
         StatusArea[#, 1.0481176711992486`]& ,
         TagBoxNote->"1.0481176711992486"],
        StyleBox["1.0481176711992486`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.0481176711992486`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.86448475, 0.64544325, 0.7782762142857143], EdgeForm[{Opacity[
      0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{5.533146591970121, 0.}, {6.466853408029879, 
            1.0832652741529625`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{55.828352457442534`, 
           63.693510241176554`}, {-45.41852811613626, 73.78800000000001}}],
         StatusArea[#, 1.0832652741529625`]& ,
         TagBoxNote->"1.0832652741529625"],
        StyleBox["1.0832652741529625`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.0832652741529625`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.8818382857142857, 0.6661318571428572, 0.7273914285714286], 
      EdgeForm[{Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{6.533146591970121, 0.}, {7.466853408029879, 
            1.1141961709303168`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{63.86637644382165, 
           71.73153422755567}, {-48.81199948572444, 73.78799999999998}}],
         StatusArea[#, 1.1141961709303168`]& ,
         TagBoxNote->"1.1141961709303168"],
        StyleBox["1.1141961709303168`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.1141961709303168`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.898695, 0.686452, 0.6785475], EdgeForm[{Opacity[
      0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{7.533146591970121, 0.}, {8.466853408029879, 
            1.140177125052048}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{71.90440043020077, 
           79.76955821393477}, {-51.662405815722195`, 73.78800000000001}}],
         StatusArea[#, 1.140177125052048]& ,
         TagBoxNote->"1.140177125052048"],
        StyleBox["1.140177125052048`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.140177125052048, {}], "Tooltip"]& ]}, 
     {RGBColor[0.9133704285714286, 0.7086834285714285, 0.6405378571428572], 
      EdgeForm[{Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{8.533146591970121, 0.}, {9.466853408029879, 
            1.1549528911426346`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{79.94242441657988, 
           87.80758220031389}, {-53.2834755038422, 73.78799999999998}}],
         StatusArea[#, 1.1549528911426346`]& ,
         TagBoxNote->"1.1549528911426346"],
        StyleBox["1.1549528911426346`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.1549528911426346`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.9242286071428572, 0.7342596071428571, 0.6214882142857143], 
      EdgeForm[{Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{9.533146591970121, 0.}, {10.466853408029879`, 
            1.1771630798040302`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{87.980448402959, 
           95.84560618669299}, {-55.72018595159031, 73.78799999999998}}],
         StatusArea[#, 1.1771630798040302`]& ,
         TagBoxNote->"1.1771630798040302"],
        StyleBox["1.1771630798040302`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.1771630798040302`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.9350867857142857, 0.7598357857142857, 0.6024385714285715], 
      EdgeForm[{Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{10.533146591970121`, 0.}, {11.466853408029879`, 
            1.1902913546892462`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{96.0184723893381, 
           103.8836301730721}, {-57.16050710605748, 73.78799999999998}}],
         StatusArea[#, 1.1902913546892462`]& ,
         TagBoxNote->"1.1902913546892462"],
        StyleBox["1.1902913546892462`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.1902913546892462`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.9427158928571429, 0.7894796428571429, 0.5951930714285715], 
      EdgeForm[{Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{11.533146591970121`, 0.}, {12.466853408029879`, 
            1.202442083242465}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{104.05649637571722`, 
           111.92165415945122`}, {-58.49358030344288, 73.78799999999998}}],
         StatusArea[#, 1.202442083242465]& ,
         TagBoxNote->"1.202442083242465"],
        StyleBox["1.202442083242465`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.202442083242465, {}], "Tooltip"]& ]}, 
     {RGBColor[0.9496274285714286, 0.8200274285714285, 0.5905707142857143], 
      EdgeForm[{Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{12.533146591970121`, 0.}, {13.466853408029879`, 
            1.2071504549344274`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{112.09452036209633`, 
           119.95967814583034`}, {-59.01014225924598, 73.78799999999998}}],
         StatusArea[#, 1.2071504549344274`]& ,
         TagBoxNote->"1.2071504549344274"],
        StyleBox["1.2071504549344274`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.2071504549344274`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.9554621785714286, 0.8498811428571429, 0.5879491428571428], 
      EdgeForm[{Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{13.533146591970121`, 0.}, {14.466853408029879`, 
            1.2257198850736013`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{120.13254434847545`, 
           127.99770213220944`}, {-61.0474200653324, 73.78799999999998}}],
         StatusArea[#, 1.2257198850736013`]& ,
         TagBoxNote->"1.2257198850736013"],
        StyleBox["1.2257198850736013`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.2257198850736013`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.9584254999999999, 0.877884, 0.5906629999999999], EdgeForm[{
      Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{14.533146591970121`, 0.}, {15.466853408029879`, 
            1.2336776226717452`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{128.17056833485455`, 
           136.03572611858857`}, {-61.92047443877584, 73.78799999999998}}],
         StatusArea[#, 1.2336776226717452`]& ,
         TagBoxNote->"1.2336776226717452"],
        StyleBox["1.2336776226717452`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.2336776226717452`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.9613888214285714, 0.9058868571428571, 0.5933768571428572], 
      EdgeForm[{Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{15.533146591970121`, 0.}, {16.466853408029877`, 
            1.2425967461556615`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{136.20859232123365`, 
           144.07375010496767`}, {-62.899003784444574`, 73.78799999999998}}],
         StatusArea[#, 1.2425967461556615`]& ,
         TagBoxNote->"1.2425967461556615"],
        StyleBox["1.2425967461556615`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.2425967461556615`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.9581918571428572, 0.9248882857142857, 0.6055372857142857], 
      EdgeForm[{Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{16.53314659197012, 0.}, {17.466853408029877`, 
            1.2495922215580357`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{144.24661630761275`, 
           152.11177409134677`}, {-63.6664870444836, 73.78799999999998}}],
         StatusArea[#, 1.2495922215580357`]& ,
         TagBoxNote->"1.2495922215580357"],
        StyleBox["1.2495922215580357`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.2495922215580357`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.9526847857142857, 0.9405141785714286, 0.6212401785714285], 
      EdgeForm[{Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{17.53314659197012, 0.}, {18.466853408029877`, 
            1.2553528960403169`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{152.28464029399188`, 
           160.1497980777259}, {-64.29849859157365, 73.788}}],
         StatusArea[#, 1.2553528960403169`]& ,
         TagBoxNote->"1.2553528960403169"],
        StyleBox["1.2553528960403169`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.2553528960403169`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.9441039285714286, 0.9526649285714286, 0.6406724285714286], 
      EdgeForm[{Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{18.53314659197012, 0.}, {19.466853408029877`, 
            1.2678340942631687`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{160.322664280371, 
           168.187822064105}, {-65.66782807245737, 73.788}}],
         StatusArea[#, 1.2678340942631687`]& ,
         TagBoxNote->"1.2678340942631687"],
        StyleBox["1.2678340942631687`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.2678340942631687`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.9216910357142857, 0.9491775357142858, 0.6768867857142857], 
      EdgeForm[{Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{19.53314659197012, 0.}, {20.466853408029877`, 
            1.270631429565169}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{168.36068826675012`, 
           176.2258460504841}, {-65.97472758871795, 73.788}}],
         StatusArea[#, 1.270631429565169]& ,
         TagBoxNote->"1.270631429565169"],
        StyleBox["1.270631429565169`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.270631429565169, {}], "Tooltip"]& ]}, 
     {RGBColor[0.8992781428571429, 0.9456901428571428, 0.7131011428571428], 
      EdgeForm[{Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{20.53314659197012, 0.}, {21.466853408029877`, 
            1.274445681050187}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{176.39871225312922`, 
           184.26387003686324`}, {-66.39319438274553, 73.788}}],
         StatusArea[#, 1.274445681050187]& ,
         TagBoxNote->"1.274445681050187"],
        StyleBox["1.274445681050187`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.274445681050187, {}], "Tooltip"]& ]}, 
     {RGBColor[0.86116075, 0.930182, 0.758764], EdgeForm[{Opacity[
      0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{21.53314659197012, 0.}, {22.466853408029877`, 
            1.2841792791007427`}, "RoundingRadius" -> 0]},
          ImageSizeCache->{{184.43673623950832`, 
           192.30189402324234`}, {-67.4610808570822, 73.788}}],
         StatusArea[#, 1.2841792791007427`]& ,
         TagBoxNote->"1.2841792791007427"],
        StyleBox["1.2841792791007427`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.2841792791007427`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.8140693571428572, 0.9078048571428571, 0.8098259999999999], 
      EdgeForm[{Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{22.53314659197012, 0.}, {23.466853408029877`, 
            1.2873562040526831`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{192.47476022588745`, 
           200.33991800962147`}, {-67.80962567766538, 73.788}}],
         StatusArea[#, 1.2873562040526831`]& ,
         TagBoxNote->"1.2873562040526831"],
        StyleBox["1.2873562040526831`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.2873562040526831`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.76494675, 0.8843873214285713, 0.8597907499999999], EdgeForm[{
      Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{23.53314659197012, 0.}, {24.466853408029877`, 
            1.2978213255339033`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{200.51278421226655`, 
           208.37794199600057`}, {-68.95776859707091, 73.788}}],
         StatusArea[#, 1.2978213255339033`]& ,
         TagBoxNote->"1.2978213255339033"],
        StyleBox["1.2978213255339033`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.2978213255339033`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.695512, 0.8505658571428572, 0.898783], EdgeForm[{Opacity[
      0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{24.53314659197012, 0.}, {25.466853408029877`, 
            1.302178153303016}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{208.55080819864565`, 
           216.41596598237967`}, {-69.43576218397313, 73.788}}],
         StatusArea[#, 1.302178153303016]& ,
         TagBoxNote->"1.302178153303016"],
        StyleBox["1.302178153303016`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.302178153303016, {}], "Tooltip"]& ]}, 
     {RGBColor[0.62607725, 0.816744392857143, 0.93777525], EdgeForm[{Opacity[
      0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{25.53314659197012, 0.}, {26.466853408029877`, 
            1.3101660481179132`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{216.58883218502478`, 
           224.4539899687588}, {-70.31212514728306, 73.788}}],
         StatusArea[#, 1.3101660481179132`]& ,
         TagBoxNote->"1.3101660481179132"],
        StyleBox["1.3101660481179132`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.3101660481179132`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.5595402857142857, 0.7817428571428572, 0.9494085714285714], 
      EdgeForm[{Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{26.53314659197012, 0.}, {27.466853408029877`, 
            1.3094792125191803`}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{224.6268561714039, 
           232.4920139551379}, {-70.2367714659239, 73.788}}],
         StatusArea[#, 1.3094792125191803`]& ,
         TagBoxNote->"1.3094792125191803"],
        StyleBox["1.3094792125191803`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.3094792125191803`, {}], "Tooltip"]& ]}, 
     {RGBColor[0.4954181428571429, 0.7457579285714286, 0.9382427857142858], 
      EdgeForm[{Opacity[0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{27.53314659197012, 0.}, {28.466853408029877`, 
            1.315988660316932}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{232.66488015778302`, 
           240.530037941517}, {-70.95093196674945, 73.788}}],
         StatusArea[#, 1.315988660316932]& ,
         TagBoxNote->"1.315988660316932"],
        StyleBox["1.315988660316932`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.315988660316932, {}], "Tooltip"]& ]}, 
     {RGBColor[0.431296, 0.709773, 0.927077], EdgeForm[{Opacity[
      0.49699999999999994`], Thickness[Small]}], 
      TagBox[
       TooltipBox[
        TagBox[
         DynamicBox[{
           FEPrivate`If[
            CurrentValue["MouseOver"], 
            EdgeForm[{
              GrayLevel[0.5], 
              AbsoluteThickness[1.5], 
              Opacity[0.66]}], {}, {}], 
           
           RectangleBox[{28.53314659197012, 0.}, {29.466853408029877`, 
            1.320462631291421}, "RoundingRadius" -> 0]},
          
          ImageSizeCache->{{240.70290414416212`, 
           248.56806192789614`}, {-71.44177749636928, 73.788}}],
         StatusArea[#, 1.320462631291421]& ,
         TagBoxNote->"1.320462631291421"],
        StyleBox["1.320462631291421`", {}, StripOnInput -> False]],
       Annotation[#, 
        Style[1.320462631291421, {}], "Tooltip"]& ]}}, {}, {}}, {}, {}, 
   StyleBox[
    StyleBox[{
      {Thickness[Tiny], 
       LineBox[{{-0.045527544351073757`, 0.}, {30.057101027077497`, 0.}}], 
       StyleBox[{}, "GraphicsLabel",
        StripOnInput->False]}, 
      StyleBox[{
        {Thickness[Tiny], 
         LineBox[{{0.5331465919701214, 0.}, 
           Offset[{-1.102182119232618*^-15, -6.}, {0.5331465919701214, 0.}]}],
          LineBox[{{29.466853408029877`, 0.}, 
           Offset[{-1.102182119232618*^-15, -6.}, {29.466853408029877`, 
            0.}]}], {{}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, \
{}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}}}, 
        StyleBox[{}, "GraphicsLabel",
         StripOnInput->False]}, "GraphicsTicks",
       StripOnInput->False]},
     Antialiasing->False], "GraphicsAxes",
    StripOnInput->False]},
  AspectRatio->NCache[GoldenRatio^(-1), 0.6180339887498948],
  Axes->{False, True},
  AxesLabel->{None, None},
  AxesOrigin->{-0.045527544351073757`, 0.},
  CoordinatesToolOptions:>{"DisplayFunction" -> ({
      Identity[
       Part[#, 1]], 
      Identity[
       Part[#, 2]]}& ), "CopiedValueFunction" -> ({
      Identity[
       Part[#, 1]], 
      Identity[
       Part[#, 2]]}& )},
  FrameLabel->{{None, None}, {None, None}},
  FrameTicks->{{Automatic, Automatic}, {Automatic, Automatic}},
  GridLines->{None, None},
  GridLinesStyle->Directive[
    GrayLevel[0.5, 0.4]],
  ImageSize->{358.57421875, Automatic},
  PlotRange->{{All, All}, {All, All}},
  PlotRangePadding->{{
     Scaled[0.02], 
     Scaled[0.02]}, {
     Scaled[0.02], 
     Scaled[0.05]}},
  Ticks->{None, Automatic}]], "Output",
 CellChangeTimes->{
  3.73306399118122*^9, 3.733064060867817*^9, 3.733064113679936*^9, 
   3.733064233798361*^9, {3.733064367215042*^9, 3.733064394711639*^9}, {
   3.7330644791513767`*^9, 3.733064503239477*^9}, {3.733064768568027*^9, 
   3.733064779599778*^9}, {3.733064888767086*^9, 3.7330649166760693`*^9}, 
   3.733064997625661*^9, 3.733065941147386*^9, 3.733074330327923*^9, 
   3.733080126489172*^9, 3.73312533423901*^9, 3.733125534027068*^9, 
   3.733128420973812*^9, 3.73313346910513*^9, 3.7332126878941393`*^9, 
   3.7332129831427298`*^9, 3.73321609637541*^9, 3.733216251560525*^9, 
   3.733221945706394*^9, 3.733270019317771*^9, 3.7332750149448023`*^9, 
   3.733277829516528*^9},
 FontSize->14]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[StyleBox["Lab Eight: Recursion",
 FontSize->36]], "Chapter",
 CellChangeTimes->{{3.732873940642396*^9, 3.732874512274522*^9}, {
   3.7328749406685467`*^9, 3.732875019320356*^9}, {3.73304527802007*^9, 
   3.7330454248652353`*^9}, 3.733058225440941*^9},
 TextJustification->1.,
 FontSize->14],

Cell[TextData[{
 StyleBox["In the author\[CloseCurlyQuote]s humble view, most of the \
introductory programming courses that he has seen teach recursion in a pretty \
wrongheaded way that is obviously meant to be taken by silent agreement \
between the teachers and students to be a forced formality that, in spirit, \
is probably really not that different from how the present day Chinese \
university students all still have to study the formally approved theory of \
Communism, just because that is the way that it is. The students leave the \
course with a misguided notion that recursion is basically a needlessly \
convoluted way to solve factorials and Fibonacci numbers and other similarly \
simple linear tasks that any sane programmer, assuming that he would even \
waste his working hours with such toy problems anyway to begin with, ", "Text",
  FontSize->14],
 "would instinctively solve ",
 StyleBox["with a simple for-loop to avoid a ", "Text",
  FontSize->14],
 StyleBox["stack overflow", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" and, in the case of a branching recursion that has repeated \
subproblems such as Fibonacci numbers, avoid the exponential blowup of \
running time during repeatedly solving the same small set of repeated \
subproblems all the way down.\nTaking a little sidebar to the second course \
of algorithms, we recall that recursions that become exponential with \
repeated subproblems can usually be ", "Text",
  FontSize->14],
 StyleBox["memoized", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" to prevent these repeated subproblems to be recomputed from \
scratch each time, which given this author again a convenient excuse to \
emphasize the importance of the time-space tradeoff in all of computation \
when memory that would otherwise just be sitting idle is used to cache the \
results of computations that will be needed again in near future. Memoization \
is quite trivial to implement in ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" with the canonical pattern of lazy assignment of eager \
assignments. This memoized version of Fibonacci is, as they used to say back \
in the day, nearly \[OpenCurlyDoubleQuote]too cheap to meter\
\[CloseCurlyDoubleQuote] especially when compared to the exponential time \
version. (For a deep Fibonacci recursion, you still need to increase the \
value of the global variable ", "Text",
  FontSize->14],
 StyleBox["$RecursionLimit ", "Text",
  FontSize->14,
  FontWeight->"Bold"],
 StyleBox["to ensure that the evaluation does not crash with a stack \
overflow.)", "Text",
  FontSize->14]
}], "Text",
 CellChangeTimes->{
  3.73305823688802*^9, {3.733064806682702*^9, 3.733064850361105*^9}, {
   3.73306511421139*^9, 3.7330652033074303`*^9}, {3.733070966700981*^9, 
   3.733071008492594*^9}, {3.733074040847155*^9, 3.7330741178681498`*^9}, {
   3.733215096007988*^9, 3.7332152643008633`*^9}, {3.73321535097436*^9, 
   3.733215412605754*^9}, {3.7332154799724283`*^9, 3.733215561387754*^9}, {
   3.7332156912175713`*^9, 3.733215754376914*^9}, {3.733215785431072*^9, 
   3.733215794128316*^9}, {3.733215940831978*^9, 3.7332159412292843`*^9}, {
   3.7332160036848288`*^9, 3.7332160090841827`*^9}, {3.733216045155519*^9, 
   3.733216064275435*^9}, {3.733216178012319*^9, 3.733216182993376*^9}, {
   3.733216344457542*^9, 3.733216434958458*^9}, {3.733251396871614*^9, 
   3.7332514677883377`*^9}, {3.733269326759534*^9, 3.7332693278799267`*^9}, {
   3.7332751006853523`*^9, 3.733275376415553*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"fib", "[", 
    RowBox[{"n_", " ", "/;", " ", 
     RowBox[{"n", " ", "<", " ", "2"}]}], "]"}], " ", ":=", " ", "1"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"fib", "[", 
    RowBox[{"n_", " ", "/;", " ", 
     RowBox[{"n", " ", "\[GreaterEqual]", " ", "2"}]}], "]"}], " ", ":=", " ", 
   RowBox[{
    RowBox[{"fib", "[", 
     RowBox[{"n", "-", "1"}], "]"}], " ", "+", " ", 
    RowBox[{"fib", "[", 
     RowBox[{"n", "-", "2"}], "]"}]}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"memFib", "[", 
    RowBox[{"n_", " ", "/;", " ", 
     RowBox[{"n", " ", "<", " ", "2"}]}], "]"}], " ", ":=", " ", "1"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"memFib", "[", 
    RowBox[{"n_", " ", "/;", " ", 
     RowBox[{"n", " ", "\[GreaterEqual]", " ", "2"}]}], "]"}], " ", ":=", " ", 
   RowBox[{
    RowBox[{"memFib", "[", "n", "]"}], " ", "=", " ", 
    RowBox[{
     RowBox[{"memFib", "[", 
      RowBox[{"n", "-", "1"}], "]"}], " ", "+", " ", 
     RowBox[{"memFib", "[", 
      RowBox[{"n", "-", "2"}], "]"}]}]}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"{", 
  RowBox[{
   RowBox[{"First", "[", 
    RowBox[{"Timing", "[", 
     RowBox[{"fib", "[", "30", "]"}], "]"}], "]"}], ",", " ", 
   RowBox[{"First", "[", 
    RowBox[{"Timing", "[", 
     RowBox[{"memFib", "[", "30", "]"}], "]"}], "]"}]}], "}"}]}], "Input",
 CellChangeTimes->{{3.7332152700844393`*^9, 3.7332153488628473`*^9}, {
  3.733215414485714*^9, 3.73321544990119*^9}, {3.733215951765834*^9, 
  3.733215951845183*^9}, {3.733216106900324*^9, 3.733216107011145*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
  "4.20099200000000028154545361758209764957`6.643951767786156", ",", 
   "0.00019499999999999999646983772638719756`2.310634524642142"}], 
  "}"}]], "Output",
 CellChangeTimes->{{3.7332154421010027`*^9, 3.733215454574111*^9}, 
   3.733216101044482*^9, 3.733216255891943*^9, 3.733221950602619*^9, 
   3.733270024068799*^9, 3.7332778339137697`*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 StyleBox["During the second half of the author\[CloseCurlyQuote]s \
introductory programming course, one entire three-hour lecture is used to go \
through the theory of recursion, up to and including memoization and why tail \
calls are better than ordinary recursive calls. This theory is then driven in \
with a dozen examples in the lecture and six more in this week\
\[CloseCurlyQuote]s lab, followed by the CodingBat sections on recursion to \
ensure that the students will really be able do that one recursion problem \
out of the four problems in their final exam. To avoid the simplistic view of \
recursion being a silly way to write a for-loop and instead bring out the \
power of recursion as a useful programming technique, the recursion lecture \
needs to offer interesting examples in which each recursive call branches to \
two more or recursive calls, which makes these functions not that \
straightforward to simulate with result-equivalent loops and nested loops, at \
least until the students become familar with the power of the deceptively \
simple data structure of a ", "Text",
  FontSize->14],
 StyleBox["stack", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[".\nThe author is therefore on a continuous hunt of simple but \
meaningful example problems that are best solved with branching recursion, \
such as opening all the safe tiles that emanate from the given zero-value \
tile in ", "Text",
  FontSize->14],
 StyleBox["Minesweeper", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[", or the ", "Text",
  FontSize->14],
 StyleBox["subset sum problem", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" to determine whether the given array of integers contains a \
subset whose elements exactly add up to the given goal. Discussion of the \
subset sum problem also allows pointing out the curious asymmetry of how very \
easy it is to verify whether the subset of integers that some guy offers to \
you adds up to the goal, and yet it is so strangely difficult to find a \
subset that works as a solution, despite the fact this Mickey Mouse problem \
consists of nothing but positive integers and their addition, and would be \
easy enough even for a ten year old to understand and solve by hand, at least \
in small instances. It is almost as if the computational reality and its \
\[OpenCurlyDoubleQuote]abstract physics\[CloseCurlyDoubleQuote] had an \
entirely different concept of \[OpenCurlyDoubleQuote]simple\
\[CloseCurlyDoubleQuote] than we humanoids.\nSince Java does not have any \
easy and efficient way to extract a subarray from an array as a separate \
object (the low level C programming language turns out to out much better in \
this respect), all these array recursions are always written so that the same \
entire array object is always passed as argument at every level of recursion. \
The recursive method then receives additional ", "Text",
  FontSize->14],
 StyleBox["indexing parameters", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" that instruct that method to behave ", "Text",
  FontSize->14],
 StyleBox["as if", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" only that subarray had actually been passed to it, and ignore the \
rest of that array object entirely. The end result is just a good as if only \
the subarray had been passed in the recursive call.\nInstead of writing the \
following solutions that way in ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[", these array problems actually make better examples of ", "Text",
  FontSize->14],
 StyleBox["recursive pattern matching rules", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[". The first of the six questions this week (the grading works this \
week so that points only start to accumulate from the third solved problem \
onwards, so that this lab gives the same two points as the other labs) asks \
for a recursive function to determine whether all elements of the array are \
equal. The following recursive rules say as ", "Text",
  FontSize->14],
 StyleBox["base cases", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" that all elements of an empty array and a singleton array are \
equal, and otherwise all the elements in the array are equal if the first two \
are equal and then all elements are equal from the second element onwards. \
The ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" pattern of a single underscore matches any single expression, the \
pattern of two underscores matches any sequence of one or more expressions, \
and the pattern of three underscores matches any sequence of zero or more \
expressions.", "Text",
  FontSize->14]
}], "Text",
 CellChangeTimes->{
  3.73305823688802*^9, {3.733064806682702*^9, 3.733064850361105*^9}, {
   3.73306511421139*^9, 3.7330652033074303`*^9}, {3.733070966700981*^9, 
   3.733071008492594*^9}, {3.733074040847155*^9, 3.7330741178681498`*^9}, {
   3.733215096007988*^9, 3.7332152643008633`*^9}, {3.7332155699785843`*^9, 
   3.733215681483428*^9}, {3.733215769980302*^9, 3.733215903760063*^9}, {
   3.733216448149692*^9, 3.733216473271006*^9}, {3.7332514763957644`*^9, 
   3.733251718682596*^9}, {3.733269464751993*^9, 3.73326949797482*^9}, {
   3.733275389015442*^9, 3.733275621906128*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"allEqual", "[", 
    RowBox[{"{", "}"}], "]"}], " ", ":=", " ", "True"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"allEqual", "[", 
    RowBox[{"{", "x_", "}"}], "]"}], " ", ":=", " ", "True"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"allEqual", "[", 
    RowBox[{"{", 
     RowBox[{"x_", ",", " ", "x_", ",", " ", "rest___"}], "}"}], "]"}], " ", ":=",
    " ", 
   RowBox[{"allEqual", "[", 
    RowBox[{"{", 
     RowBox[{"x", ",", " ", "rest"}], "}"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"allEqual", "[", "___", "]"}], " ", ":=", " ", "False"}], ";"}], 
  " "}]}], "Input",
 CellChangeTimes->{{3.732874516345902*^9, 3.7328746311134*^9}, {
  3.73287474728559*^9, 3.732874792662788*^9}, {3.733275627457554*^9, 
  3.733275628466085*^9}},
 FontSize->14],

Cell[TextData[{
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " is not Prolog so that it would automatically backtracking over rules. \
Instead, whenever you define multiple rules for the same symbol, only the \
first one that matches the argument pattern is actually used, similar to the \
behaviour of the if-else ladders of traditional imperative languages. ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " can and will usually internally rearrange the rules from the most specific \
to most general to resolve situations where the argument patterns overlap. In \
the previous example, the last rule that can match any sequence of \
expressions is the most general of these rules, but the other three preceding \
rules are disjoint in the sense that no argument pattern can match more than \
one of them at the time. Unlike in Prolog, where the query fails unless a \
solution is found during backtracking, in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " the default result of failure (that is, default in the sense of the ",
 StyleBox["closed world assumption",
  FontSlant->"Italic"],
 " implicit in Prolog) has to be explicitly encoded as a kind of \
\[OpenCurlyDoubleQuote]none of the above\[CloseCurlyDoubleQuote] rule. This \
last rule then allows us to write queries such as ",
 StyleBox["allEqual[2 + foo]",
  FontWeight->"Bold"],
 " that are legal expressions but whose result we define to evaluate to ",
 StyleBox["False",
  FontWeight->"Bold"],
 ".\nThe second question of this week asks the student to implement ",
 StyleBox["System.arraycopy",
  FontWeight->"Bold"],
 " using recursion. Since mutating assignments over arrays go deeply against \
the functional spirit of ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", we will now have to plead the fifth and politely decline to implement \
this function at all. (If really needed, the result list can always be \
trivially built up as a one-liner using ",
 StyleBox["Join",
  FontWeight->"Bold"],
 " and ",
 StyleBox["Take",
  FontWeight->"Bold"],
 ".) Instead, we shall move on to the third question that asks the student to \
implement the basic ",
 StyleBox["linear search algorithm",
  FontSlant->"Italic"],
 " using only recursion."
}], "Text",
 CellChangeTimes->{{3.732874638383594*^9, 3.732874909794344*^9}, {
  3.732875123023254*^9, 3.732875170254443*^9}, {3.732970764909543*^9, 
  3.732970819563788*^9}, {3.732970879819745*^9, 3.732970906130251*^9}, {
  3.733045456463176*^9, 3.733045499215665*^9}, {3.733051165612232*^9, 
  3.7330511665792723`*^9}, {3.7330652143361*^9, 3.733065243060067*^9}, {
  3.733251729603805*^9, 3.7332518417689247`*^9}, {3.733269508029394*^9, 
  3.7332695266526003`*^9}, {3.73327563562236*^9, 3.73327581845193*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"linearSearch", "[", 
    RowBox[{"_", ",", " ", 
     RowBox[{"{", "}"}]}], "]"}], " ", ":=", " ", "False"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"linearSearch", "[", 
    RowBox[{"x_", ",", " ", 
     RowBox[{"{", 
      RowBox[{"x_", ",", " ", "rest___"}], "}"}]}], "]"}], ":=", " ", 
   "True"}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"linearSearch", "[", 
    RowBox[{"x_", ",", " ", 
     RowBox[{"{", 
      RowBox[{"y_", ",", " ", "rest___"}], "}"}]}], "]"}], " ", ":=", " ", 
   RowBox[{"linearSearch", "[", 
    RowBox[{"x", ",", " ", "rest"}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"linearSearch", "[", 
     RowBox[{"___", ",", " ", "___"}], "]"}], " ", ":=", " ", "False"}], 
   ";"}], " "}]}], "Input",
 CellChangeTimes->{{3.732875054762006*^9, 3.7328751174052467`*^9}},
 FontSize->14],

Cell["\<\
The fourth question continues in the same vein, asking the student to \
recursively reverse the order of the elements inside the given list.\
\>", "Text",
 CellChangeTimes->{{3.732875185238823*^9, 3.732875196933666*^9}, {
  3.7328755254555798`*^9, 3.732875530343645*^9}, {3.733045504061635*^9, 
  3.733045515661255*^9}, {3.7332518507808647`*^9, 3.7332518640718327`*^9}, {
  3.733275829689741*^9, 3.733275830109844*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"reverse", "[", 
    RowBox[{"{", "}"}], "]"}], " ", ":=", " ", 
   RowBox[{"{", "}"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"reverse", "[", 
    RowBox[{"{", "x_", "}"}], "]"}], " ", ":=", " ", 
   RowBox[{"{", "x", "}"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"reverse", "[", 
    RowBox[{"{", 
     RowBox[{"x_", ",", " ", "rest___"}], "}"}], "]"}], " ", ":=", 
   RowBox[{"Append", "[", 
    RowBox[{
     RowBox[{"reverse", "[", 
      RowBox[{"{", "rest", "}"}], "]"}], ",", " ", "x"}], "]"}]}], 
  ";"}]}], "Input",
 CellChangeTimes->{{3.732875212366621*^9, 3.732875233461561*^9}, {
  3.732875278988596*^9, 3.732875354179268*^9}, {3.732875447619184*^9, 
  3.732875505730871*^9}},
 FontSize->14],

Cell[TextData[{
 "According to the student feedback, the fifth question this week is the most \
interesting and the most fun question of the entire slew of 42 questions in \
these ten labs. This question asks to implement the classic ",
 StyleBox["array partition",
  FontSlant->"Italic"],
 " algorithm that these students will then meet next year in the ",
 StyleBox["quicksort",
  FontSlant->"Italic"],
 " lecture of the normal introduction to algorithms course. Using the parity \
of the element as the partitioning criterion instead of comparing it to the \
",
 StyleBox["pivot element",
  FontSlant->"Italic"],
 ", tthe elements of the given list of integers are to be rearranged so that \
all odd elements come first as one clump, followed by all even elements as \
another clump. This abstract problem is, of course, agnostic to the actual \
criterion used to separate the elements, and the basic logic of the function \
could be written to be the same and work with any possible criterion.\nTo \
have some variety for these recursion problems, we wll solve this particular \
problem using an additional ",
 StyleBox["accumulator parameter (",
  FontSlant->"Italic"],
 "in the following code named ",
 StyleBox["stack",
  FontWeight->"Bold"],
 ") that is used to gather the even numbers that happened to be encountered \
along the way during the recursion. In this programming style, the top level \
call first always calls to the accumulator version of the same function. The \
base case of the recursion is rewritten to return the value of the \
accumulator parameter instead of what would have been the ordinary answer for \
the base case. The recursive rules place the current element ",
 StyleBox["x",
  FontSlant->"Italic"],
 " either into the answer or into to stack depending on whether the element \
",
 StyleBox["x",
  FontSlant->"Italic"],
 " is odd or even, that is, which side of the partitioning criterions it \
happens to fall on. Note also how the use of the accumulator parameter turns \
each rule ",
 StyleBox["tail recursive",
  FontSlant->"Italic"],
 " so that no other computation takes place after the recursive call. This \
allows the execution environment to recycle the current stack frame of \
recursion and avoid the possibility of stack overflow, which is why the \
accumulator parameter technique can be quite useful in traditional imperative \
programming languages."
}], "Text",
 CellChangeTimes->{{3.732875519544694*^9, 3.732875548543333*^9}, {
  3.732875599214396*^9, 3.732875613686289*^9}, {3.732875858905839*^9, 
  3.732876041167405*^9}, {3.733045522877859*^9, 3.733045708044402*^9}, {
  3.733057680281516*^9, 3.73305769309054*^9}, {3.733251876328096*^9, 
  3.733252061318336*^9}, {3.733269557565878*^9, 3.733269591444079*^9}, {
  3.7332758674917717`*^9, 3.733276104586297*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"parityPartition", "[", "x_", "]"}], " ", ":=", " ", 
   RowBox[{"parityPartition", "[", 
    RowBox[{"x", ",", " ", 
     RowBox[{"{", "}"}]}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"parityPartition", "[", 
    RowBox[{
     RowBox[{"{", "}"}], ",", " ", "stack_"}], "]"}], " ", ":=", " ", 
   "stack"}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"parityPartition", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{
       RowBox[{"x_", " ", "/;", " ", 
        RowBox[{
         RowBox[{"Mod", "[", 
          RowBox[{"x", ",", " ", "2"}], "]"}], " ", "!=", " ", "0"}]}], ",", 
       " ", "rest___"}], "}"}], ",", " ", "stack_"}], "]"}], " ", ":=", " ", 
   RowBox[{"Join", "[", 
    RowBox[{
     RowBox[{"{", "x", "}"}], ",", " ", 
     RowBox[{"parityPartition", "[", 
      RowBox[{
       RowBox[{"{", "rest", "}"}], ",", " ", "stack"}], "]"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"parityPartition", "[", 
     RowBox[{
      RowBox[{"{", 
       RowBox[{
        RowBox[{"x_", " ", "/;", " ", 
         RowBox[{
          RowBox[{"Mod", "[", 
           RowBox[{"x", ",", "2"}], "]"}], " ", "\[Equal]", " ", "0"}]}], ",",
         " ", "rest___"}], "}"}], ",", " ", "stack_"}], "]"}], ":=", " ", 
    RowBox[{"parityPartition", "[", 
     RowBox[{
      RowBox[{"{", "rest", "}"}], ",", 
      RowBox[{"Append", "[", 
       RowBox[{"stack", ",", " ", "x"}], "]"}]}], "]"}]}], ";"}], 
  " "}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"parityPartition", "[", 
   RowBox[{"{", 
    RowBox[{"4", ",", 
     RowBox[{"-", "2"}], ",", "7", ",", " ", "1", ",", " ", "9", ",", " ", 
     "0"}], "}"}], "]"}], " "}]}], "Input",
 CellChangeTimes->{{3.732875727271769*^9, 3.732875845795404*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"7", ",", "1", ",", "9", ",", "4", ",", 
   RowBox[{"-", "2"}], ",", "0"}], "}"}]], "Output",
 CellChangeTimes->{3.732875846426784*^9, 3.732970576424589*^9, 
  3.7330509515162153`*^9, 3.733051371845265*^9, 3.733057952714336*^9, 
  3.7330659412936783`*^9, 3.733074330850293*^9, 3.7330801266158*^9, 
  3.733125534388184*^9, 3.733128421363432*^9, 3.733133469591563*^9, 
  3.73321268813132*^9, 3.733212983348177*^9, 3.733216101385345*^9, 
  3.733216256377397*^9, 3.7332219508925467`*^9, 3.733270024344613*^9, 
  3.733277834168067*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "As a quick aside, it is also good to be aware of how the ",
 StyleBox["integer remainder operator",
  FontSlant->"Italic"],
 " works, should your logic potentially require computing the parities of \
negative elements. The sign of the remainder is always the same as the sign \
of the first operand, so that the sign of the second operand does not matter. \
This is the only mathematically meaningful way to define the remainder so \
that the quotient and remainder satisfy the equation binding them to the \
original operands of the integer division."
}], "Text",
 CellChangeTimes->{{3.732876058433313*^9, 3.732876139277529*^9}, {
  3.732876245300083*^9, 3.732876286139494*^9}, {3.7330457153304777`*^9, 
  3.733045722331378*^9}, {3.7332520734615097`*^9, 3.733252139443858*^9}, {
  3.733276109821149*^9, 3.7332761134105597`*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"Map", "[", 
   RowBox[{
    RowBox[{
     RowBox[{"Mod", "[", 
      RowBox[{
       RowBox[{"#", "[", 
        RowBox[{"[", "1", "]"}], "]"}], ",", " ", 
       RowBox[{"#", "[", 
        RowBox[{"[", "2", "]"}], "]"}]}], "]"}], "&"}], ",", " ", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"{", 
       RowBox[{"7", ",", "2"}], "}"}], ",", 
      RowBox[{"{", 
       RowBox[{
        RowBox[{"-", "7"}], ",", "2"}], "}"}], ",", 
      RowBox[{"{", 
       RowBox[{"7", ",", 
        RowBox[{"-", "2"}]}], "}"}], ",", " ", 
      RowBox[{"{", 
       RowBox[{
        RowBox[{"-", "7"}], ",", 
        RowBox[{"-", "2"}]}], "}"}]}], "}"}]}], "]"}], 
  " "}], "\[IndentingNewLine]", 
 RowBox[{"Map", "[", 
  RowBox[{
   RowBox[{
    RowBox[{
     RowBox[{"QuotientRemainder", "[", 
      RowBox[{
       RowBox[{"#", "[", 
        RowBox[{"[", "1", "]"}], "]"}], ",", " ", 
       RowBox[{"#", "[", 
        RowBox[{"[", "2", "]"}], "]"}]}], "]"}], "[", 
     RowBox[{"[", "2", "]"}], "]"}], "&"}], ",", " ", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"7", ",", "2"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{
       RowBox[{"-", "7"}], ",", "2"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"7", ",", 
       RowBox[{"-", "2"}]}], "}"}], ",", " ", 
     RowBox[{"{", 
      RowBox[{
       RowBox[{"-", "7"}], ",", 
       RowBox[{"-", "2"}]}], "}"}]}], "}"}]}], "]"}]}], "Input",
 CellChangeTimes->{{3.732876144239023*^9, 3.7328762316398077`*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"1", ",", "1", ",", 
   RowBox[{"-", "1"}], ",", 
   RowBox[{"-", "1"}]}], "}"}]], "Output",
 CellChangeTimes->{{3.7328762026577473`*^9, 3.732876228190974*^9}, 
   3.732970576504874*^9, 3.733050951587874*^9, 3.7330513719698687`*^9, 
   3.733057952834886*^9, 3.733065941396109*^9, 3.733074330965375*^9, 
   3.733080126721306*^9, 3.733125534489046*^9, 3.733128421492386*^9, 
   3.733133469875876*^9, 3.733212688221676*^9, 3.7332129834321613`*^9, 
   3.733216101469034*^9, 3.733216256577614*^9, 3.733221950980509*^9, 
   3.733270024420323*^9, 3.733277834252832*^9},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"1", ",", "1", ",", 
   RowBox[{"-", "1"}], ",", 
   RowBox[{"-", "1"}]}], "}"}]], "Output",
 CellChangeTimes->{{3.7328762026577473`*^9, 3.732876228190974*^9}, 
   3.732970576504874*^9, 3.733050951587874*^9, 3.7330513719698687`*^9, 
   3.733057952834886*^9, 3.733065941396109*^9, 3.733074330965375*^9, 
   3.733080126721306*^9, 3.733125534489046*^9, 3.733128421492386*^9, 
   3.733133469875876*^9, 3.733212688221676*^9, 3.7332129834321613`*^9, 
   3.733216101469034*^9, 3.733216256577614*^9, 3.733221950980509*^9, 
   3.733270024420323*^9, 3.733277834262562*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "The last question is an example problem seen in the lectures a couple of \
weeks earlier, but this time this very problem must be solved using recursion \
instead of the straightforward for-loop through the positions. The problem \
ask to count how many ",
 StyleBox["runs",
  FontSlant->"Italic"],
 " of equal consecutive elements there exist inside the given list, with each \
singleton element being a trivial run of length one. This question is \
equivalent to counting how many elements inside the list are not equal to the \
next element, with the boundary condition that the last element of the list \
is considered to be different from the nonexistent element after it."
}], "Text",
 CellChangeTimes->{{3.7328763001801643`*^9, 3.732876390281933*^9}, {
  3.7328765602083282`*^9, 3.732876667733432*^9}, {3.733045729722122*^9, 
  3.733045763170869*^9}, {3.733252149147316*^9, 3.7332522084263573`*^9}, {
  3.733276138477867*^9, 3.733276138706085*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[{
 RowBox[{
  RowBox[{"countRuns", "[", 
   RowBox[{"{", "}"}], "]"}], " ", ":=", " ", "0"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"countRuns", "[", 
    RowBox[{"{", "x_", "}"}], "]"}], " ", ":=", " ", "1"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"countRuns", "[", 
    RowBox[{"{", 
     RowBox[{"x_", ",", " ", "y_", ",", " ", "rest___"}], "}"}], "]"}], " ", ":=",
    " ", 
   RowBox[{
    RowBox[{"If", "[", 
     RowBox[{
      RowBox[{"x", " ", "==", " ", "y"}], ",", " ", "0", ",", " ", "1"}], 
     "]"}], " ", "+", " ", 
    RowBox[{"countRuns", "[", 
     RowBox[{"{", 
      RowBox[{"y", ",", " ", "rest"}], "}"}], "]"}]}]}], ";"}]}], "Input",
 CellChangeTimes->{{3.732876361314487*^9, 3.732876457433251*^9}, {
  3.7328765002028923`*^9, 3.732876552146845*^9}},
 FontSize->14]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[StyleBox["Lab Nine: Those dreaded word problems",
 FontSize->36]], "Chapter",
 CellChangeTimes->{{3.732876683966*^9, 3.732876869594296*^9}, {
   3.732876948649515*^9, 3.732877050219481*^9}, {3.732877346187805*^9, 
   3.732877408891445*^9}, {3.732877964666486*^9, 3.732877983098505*^9}, {
   3.73304577553065*^9, 3.7330458678398857`*^9}, 3.73305825699553*^9, {
   3.7330585672835407`*^9, 3.733058567707182*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[TextData[{
 StyleBox["The ninth lab of this course consists of four problems that each \
receive an ", "Text",
  FontSize->14],
 StyleBox["ArrayList<String>", "Text",
  FontSize->14,
  FontWeight->"Bold"],
 StyleBox[" of words as an argument, and these methods have to create and \
return another ", "Text",
  FontSize->14],
 StyleBox["ArrayList<String>", "Text",
  FontSize->14,
  FontWeight->"Bold"],
 StyleBox[" that contains precisely those words that match the requirement \
given in the problem specification. To test out these methods, a massive Unix \
wordlist of about 250,000 words of the English language is slurped into the \
JUnit tester. From this embarrassment of riches, only the proper words that \
consist of lowercase characters from ", "Text",
  FontSize->14],
 StyleBox["a", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" to ", "Text",
  FontSize->14],
 StyleBox["z", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" are kept in. This still leaves in about 210,000 words, most of \
which are technical terms of various fields of scientific and other endeavour \
so that the author estimates that, based on some random sampling done as a \
side effect of the ", "Text",
  FontSize->14],
 StyleBox["Hangman", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" programming project the author once used when teaching this \
course in the daytime mainline, he could reliably provide a definition for \
about one tenth of these words while standing on one foot. For the purposes \
of keeping this document self-contained, we shall instead use the built-in \
dictionary of ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[", since it still gives us more than enough words to play around \
with.\nImplementing the Java solutions does not require any use of ", "Text",
  FontSize->14],
 StyleBox["regular expressions", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[", since such mythical beasts haven\[CloseCurlyQuote]t even been \
mentioned during this first programming course. Instead, all these methods \
are intended to be implemented by using ordinary loops through the characters \
of the individual words, with some comparisons then done inside the bodies of \
these loops. But with ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[", we are always allowed to use whichever particular blade of this \
giant Swiss army knife would best suit the task at hand. Since the author is \
more accustomed to regular expressions, the following solutions use them \
instead of the ", "Text",
  FontSize->14],
 StyleBox["StringExpression", "Text",
  FontSize->14,
  FontWeight->"Bold"],
 StyleBox[" objects of ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[". The same is presumably the case for most of the readers of this \
document. Our first regular expression matches precisely the words that \
contain only lowercase characters ", "Text",
  FontSize->14],
 StyleBox["a", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" to ", "Text",
  FontSize->14],
 StyleBox["z", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" from start of word to its end. ", "Text",
  FontSize->14],
 "The function ",
 StyleBox["RegularExpression",
  FontWeight->"Bold"],
 " can convert any regular expression into a ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " string pattern anyway, and even if you wanted to be explicit for purposes \
of readability and consistency, the official documentation offers handy \
tables of how these two symbolisms can simulate each other."
}], "Text",
 CellChangeTimes->{
  3.733058267605053*^9, {3.733252213470818*^9, 3.733252432640408*^9}, {
   3.733252565863427*^9, 3.73325256610429*^9}, {3.733269630107316*^9, 
   3.733269632171645*^9}, {3.7332696682359047`*^9, 3.733269729721962*^9}, {
   3.733276155104539*^9, 3.733276335521051*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"words", " ", "=", " ", 
   RowBox[{"DictionaryLookup", "[", 
    RowBox[{"RegularExpression", "[", "\"\<^[a-z]+$\>\"", "]"}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"Length", "[", "words", "]"}], "\[IndentingNewLine]", 
 RowBox[{"RandomSample", "[", 
  RowBox[{"words", ",", " ", "20"}], "]"}]}], "Input",
 CellChangeTimes->{{3.732876876651086*^9, 3.7328769324734707`*^9}, {
  3.732877051705121*^9, 3.732877053319682*^9}},
 FontSize->14],

Cell[BoxData["81288"], "Output",
 CellChangeTimes->{3.732876933892116*^9, 3.732877054309786*^9, 
  3.7328778375309772`*^9, 3.73295359425878*^9, 3.73295363042708*^9, 
  3.7329705766979628`*^9, 3.7330509517575903`*^9, 3.733051372186296*^9, 
  3.7330579530578327`*^9, 3.733065941608243*^9, 3.733074331178783*^9, 
  3.73308012707316*^9, 3.733125534684332*^9, 3.7331284217272177`*^9, 
  3.733133470243363*^9, 3.733212688439293*^9, 3.7332129836201897`*^9, 
  3.733216101657537*^9, 3.733216256852854*^9, 3.733221951182083*^9, 
  3.733270024613261*^9, 3.733277834419379*^9},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"\<\"flightiness\"\>", ",", "\<\"thermoluminescence\"\>", 
   ",", "\<\"followers\"\>", ",", "\<\"nonprofit\"\>", 
   ",", "\<\"fantasying\"\>", ",", "\<\"sixteen\"\>", 
   ",", "\<\"heritable\"\>", ",", "\<\"disorientates\"\>", 
   ",", "\<\"myself\"\>", ",", "\<\"tobacconists\"\>", ",", "\<\"bottles\"\>",
    ",", "\<\"slowcoaches\"\>", ",", "\<\"pregnancy\"\>", 
   ",", "\<\"delight\"\>", ",", "\<\"importance\"\>", ",", "\<\"largo\"\>", 
   ",", "\<\"swings\"\>", ",", "\<\"traceries\"\>", ",", "\<\"defaces\"\>", 
   ",", "\<\"intuitionistic\"\>"}], "}"}]], "Output",
 CellChangeTimes->{3.732876933892116*^9, 3.732877054309786*^9, 
  3.7328778375309772`*^9, 3.73295359425878*^9, 3.73295363042708*^9, 
  3.7329705766979628`*^9, 3.7330509517575903`*^9, 3.733051372186296*^9, 
  3.7330579530578327`*^9, 3.733065941608243*^9, 3.733074331178783*^9, 
  3.73308012707316*^9, 3.733125534684332*^9, 3.7331284217272177`*^9, 
  3.733133470243363*^9, 3.733212688439293*^9, 3.7332129836201897`*^9, 
  3.733216101657537*^9, 3.733216256852854*^9, 3.733221951182083*^9, 
  3.733270024613261*^9, 3.7332778344292717`*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "In this week\[CloseCurlyQuote]s first lab problem we imagine that we are \
playing Hangman, and would like to find out which potential words are still \
theoretically possible based on the current pattern that emerged from our  \
previous hits and misses. (We assume that the parameter list contains only \
the words that the previous misses have not already eliminated.) The pattern \
is given as the characters that we have correctly guessed so far in their \
revealed positions. A question mark character is used as a ",
 StyleBox["character wildcard",
  FontSlant->"Italic"],
 " to denote those positions whose true characters are yet to be discovered. \
It is important to realize that unlike an ordinary pattern matching wildcard \
in regular expressions and elsewhere, a question mark can match only those \
characters that are not already part of the revealed pattern as they were \
successfully hit by the previous guesses. For example, the words \
\[OpenCurlyDoubleQuote]bridge\[CloseCurlyDoubleQuote] and \
\[OpenCurlyDoubleQuote]drudge\[CloseCurlyDoubleQuote] match the pattern \
\[OpenCurlyDoubleQuote]?r??ge\[CloseCurlyDoubleQuote], whereas the words \
\[OpenCurlyDoubleQuote]dredge\[CloseCurlyDoubleQuote] and \
\[OpenCurlyDoubleQuote]grunge\[CloseCurlyDoubleQuote] do not. In the \
following solution, the Hangman pattern is converted into a regular \
expression where each question mark becomes the negated character class of \
all the letters that are already part of the pattern."
}], "Text",
 CellChangeTimes->{{3.732877188469385*^9, 3.7328773347704897`*^9}, {
  3.7328779530923357`*^9, 3.732878011073468*^9}, {3.732951821747031*^9, 
  3.732951850599766*^9}, {3.732952552295106*^9, 3.73295255486723*^9}, {
  3.733045878719984*^9, 3.733046039030801*^9}, {3.7330486914768763`*^9, 
  3.733048714674946*^9}, {3.7332524424552927`*^9, 3.733252501710738*^9}, {
  3.733252559895895*^9, 3.73325257399706*^9}, {3.733269737656542*^9, 
  3.7332697554723473`*^9}, {3.7332697938155737`*^9, 3.733269798694723*^9}, {
  3.733276342010892*^9, 3.733276430438259*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"hangmanPattern", "[", "pat_", "]"}], " ", ":=", " ", 
   RowBox[{"With", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"forbid", " ", "=", " ", 
       RowBox[{"StringJoin", "[", 
        RowBox[{"\"\<[^\>\"", ",", 
         RowBox[{"Union", "[", 
          RowBox[{"DeleteCases", "[", 
           RowBox[{
            RowBox[{"Characters", "[", "pat", "]"}], ",", " ", "\"\<?\>\""}], 
           "]"}], "]"}], ",", "\"\<]\>\""}], "]"}]}], "}"}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{"RegularExpression", "[", 
      RowBox[{"StringReplace", "[", 
       RowBox[{"pat", ",", " ", 
        RowBox[{"\"\<?\>\"", " ", "\[Rule]", " ", "forbid"}]}], "]"}], 
      "]"}]}], "\[IndentingNewLine]", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"findMatchingWords", "[", 
    RowBox[{"words_", ",", " ", "pattern_"}], "]"}], " ", ":=", " ", 
   RowBox[{"With", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"hp", " ", "=", " ", 
       RowBox[{"hangmanPattern", "[", "pattern", "]"}]}], "}"}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{"Select", "[", 
      RowBox[{"words", ",", " ", 
       RowBox[{
        RowBox[{"StringMatchQ", "[", 
         RowBox[{"#", ",", " ", "hp"}], "]"}], "&"}]}], "]"}]}], 
    "\[IndentingNewLine]", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"findMatchingWords", "[", 
  RowBox[{"words", ",", " ", "\"\<?r??ge\>\""}], "]"}]}], "Input",
 CellChangeTimes->{{3.732877417891612*^9, 3.7328778158761997`*^9}, {
  3.732877845901997*^9, 3.732877849853774*^9}, {3.732877896669209*^9, 
  3.732877927997426*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"\<\"bridge\"\>", ",", "\<\"cringe\"\>", ",", "\<\"drudge\"\>", 
   ",", "\<\"fridge\"\>", ",", "\<\"fringe\"\>", ",", "\<\"orange\"\>", 
   ",", "\<\"triage\"\>", ",", "\<\"trudge\"\>"}], "}"}]], "Output",
 CellChangeTimes->{{3.7328776661819353`*^9, 3.7328777296135187`*^9}, {
   3.732877818445054*^9, 3.732877850706757*^9}, {3.732877915545969*^9, 
   3.732877922645487*^9}, 3.732952836836164*^9, 3.732970576939356*^9, 
   3.733050951970633*^9, 3.733051372703868*^9, 3.73305795327705*^9, 
   3.733065942162066*^9, 3.7330743314460983`*^9, 3.733080127374631*^9, 
   3.7331255349085073`*^9, 3.733128421972746*^9, 3.733133470760705*^9, 
   3.733212688649041*^9, 3.733212983840434*^9, 3.7332161018756*^9, 
   3.733216257078196*^9, 3.733221951438738*^9, 3.733270024854369*^9, 
   3.73327783462578*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "The second question turns the standard palindrome identification \
programming exercise upside down, and asks the method to cherry pick all ",
 StyleBox["semordnilaps",
  FontSlant->"Italic"],
 " from the given list of words. A semordnilap (read it backwards) is \
humorously defined to be a word that produces a different legal word when it \
is read backwards. Since the ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " wordlist is given in sorted order (and even if it \
weren\[CloseCurlyQuote]t, one quick call to ",
 StyleBox["Sort",
  FontWeight->"Bold"],
 " would fix that), we can use ",
 StyleBox["binary search",
  FontSlant->"Italic"],
 " to quickly determine whether the reversed version of the given word is \
also a word. This one is again a point for Java, where that function is \
already implemented in the ",
 StyleBox["Collections",
  FontWeight->"Bold"],
 " utility class, but ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " seems to be oddly lacking this fundamental computer science algorithm. But \
that is just all the better for our purposes, since implementing binary \
search gives us a chance to practice writing modules and while-loops."
}], "Text",
 CellChangeTimes->{{3.732952719298884*^9, 3.732952739584303*^9}, {
  3.732952890542869*^9, 3.732952898101747*^9}, {3.732952938742284*^9, 
  3.7329529493973827`*^9}, {3.732952986486767*^9, 3.7329530286047163`*^9}, {
  3.73295367066505*^9, 3.732953772040267*^9}, {3.733046048525503*^9, 
  3.733046083260886*^9}, {3.7332764495691547`*^9, 3.733276515459429*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"binarySearch", "[", 
    RowBox[{"words_", ",", " ", "w_"}], "]"}], " ", ":=", " ", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{
       RowBox[{"i", " ", "=", " ", "1"}], ",", " ", 
       RowBox[{"j", " ", "=", " ", 
        RowBox[{"Length", "[", "words", "]"}]}], ",", " ", "mid"}], "}"}], 
     ",", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"While", "[", 
       RowBox[{
        RowBox[{"i", " ", "<", " ", "j"}], ",", " ", "\[IndentingNewLine]", 
        RowBox[{
         RowBox[{"mid", " ", "=", " ", 
          RowBox[{"Floor", "[", 
           RowBox[{
            RowBox[{"(", 
             RowBox[{"i", "+", "j"}], ")"}], "/", "2"}], "]"}]}], ";", 
         "\[IndentingNewLine]", 
         RowBox[{"If", "[", 
          RowBox[{
           RowBox[{
            RowBox[{"Order", "[", 
             RowBox[{
              RowBox[{"words", "[", 
               RowBox[{"[", "mid", "]"}], "]"}], ",", " ", "w"}], "]"}], " ", 
            "\[Equal]", " ", "1"}], ",", " ", 
           RowBox[{"i", " ", "=", " ", 
            RowBox[{"mid", " ", "+", " ", "1"}]}], ",", "  ", 
           RowBox[{"j", " ", "=", " ", "mid"}]}], "]"}], ";"}]}], 
       "\[IndentingNewLine]", "]"}], ";", "\[IndentingNewLine]", 
      RowBox[{
       RowBox[{"words", "[", 
        RowBox[{"[", "i", "]"}], "]"}], " ", "\[Equal]", " ", "w"}]}]}], 
    "\[IndentingNewLine]", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"findSemordnilaps", "[", "words_", "]"}], " ", ":=", " ", 
   RowBox[{"Select", "[", 
    RowBox[{"words", ",", " ", 
     RowBox[{
      RowBox[{"(", 
       RowBox[{"With", "[", 
        RowBox[{
         RowBox[{"{", 
          RowBox[{"rev", " ", "=", " ", 
           RowBox[{"StringReverse", "[", "#", "]"}]}], "}"}], ",", " ", 
         RowBox[{
          RowBox[{"rev", " ", "\[NotEqual]", " ", "#"}], " ", "&&", " ", 
          RowBox[{"binarySearch", "[", 
           RowBox[{"words", ",", " ", "rev"}], "]"}]}]}], "]"}], ")"}], 
      "&"}]}], "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"findSemordnilaps", "[", "words", "]"}]}], "Input",
 CellChangeTimes->{{3.732952743129693*^9, 3.732952854152997*^9}, {
   3.732952910618188*^9, 3.732952924024268*^9}, {3.732952966317415*^9, 
   3.732952978429717*^9}, {3.7329530636374073`*^9, 3.732953113477622*^9}, {
   3.732953153660256*^9, 3.732953160426795*^9}, {3.732953203035494*^9, 
   3.732953266131055*^9}, 3.7329532990497913`*^9, {3.732953330896326*^9, 
   3.732953438270771*^9}, {3.732953553837973*^9, 3.732953626126258*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"\<\"abut\"\>", ",", "\<\"agar\"\>", ",", "\<\"ah\"\>", 
   ",", "\<\"am\"\>", ",", "\<\"animal\"\>", ",", "\<\"are\"\>", 
   ",", "\<\"at\"\>", ",", "\<\"ate\"\>", ",", "\<\"auks\"\>", 
   ",", "\<\"avid\"\>", ",", "\<\"bad\"\>", ",", "\<\"bag\"\>", 
   ",", "\<\"ban\"\>", ",", "\<\"bard\"\>", ",", "\<\"bat\"\>", 
   ",", "\<\"bats\"\>", ",", "\<\"bed\"\>", ",", "\<\"bin\"\>", 
   ",", "\<\"bod\"\>", ",", "\<\"bog\"\>", ",", "\<\"bonk\"\>", 
   ",", "\<\"boy\"\>", ",", "\<\"brag\"\>", ",", "\<\"bud\"\>", 
   ",", "\<\"bun\"\>", ",", "\<\"buns\"\>", ",", "\<\"bur\"\>", 
   ",", "\<\"burg\"\>", ",", "\<\"bus\"\>", ",", "\<\"but\"\>", 
   ",", "\<\"buts\"\>", ",", "\<\"cam\"\>", ",", "\<\"cod\"\>", 
   ",", "\<\"dab\"\>", ",", "\<\"dag\"\>", ",", "\<\"dam\"\>", 
   ",", "\<\"dart\"\>", ",", "\<\"deb\"\>", ",", "\<\"debut\"\>", 
   ",", "\<\"decaf\"\>", ",", "\<\"decal\"\>", ",", "\<\"deem\"\>", 
   ",", "\<\"deep\"\>", ",", "\<\"deeps\"\>", ",", "\<\"deer\"\>", 
   ",", "\<\"deffer\"\>", ",", "\<\"deliver\"\>", ",", "\<\"denier\"\>", 
   ",", "\<\"denies\"\>", ",", "\<\"denim\"\>", ",", "\<\"deres\"\>", 
   ",", "\<\"desserts\"\>", ",", "\<\"devil\"\>", ",", "\<\"dew\"\>", 
   ",", "\<\"dial\"\>", ",", "\<\"dialer\"\>", ",", "\<\"diaper\"\>", 
   ",", "\<\"dim\"\>", ",", "\<\"diva\"\>", ",", "\<\"dob\"\>", 
   ",", "\<\"doc\"\>", ",", "\<\"dog\"\>", ",", "\<\"don\"\>", 
   ",", "\<\"doom\"\>", ",", "\<\"door\"\>", ",", "\<\"dos\"\>", 
   ",", "\<\"drab\"\>", ",", "\<\"draw\"\>", ",", "\<\"drawer\"\>", 
   ",", "\<\"draws\"\>", ",", "\<\"dray\"\>", ",", "\<\"dual\"\>", 
   ",", "\<\"dub\"\>", ",", "\<\"edit\"\>", ",", "\<\"eel\"\>", 
   ",", "\<\"eh\"\>", ",", "\<\"em\"\>", ",", "\<\"emir\"\>", 
   ",", "\<\"emit\"\>", ",", "\<\"er\"\>", ",", "\<\"era\"\>", 
   ",", "\<\"ergo\"\>", ",", "\<\"eta\"\>", ",", "\<\"etas\"\>", 
   ",", "\<\"evil\"\>", ",", "\<\"eviler\"\>", ",", "\<\"faced\"\>", 
   ",", "\<\"fer\"\>", ",", "\<\"fires\"\>", ",", "\<\"flog\"\>", 
   ",", "\<\"flow\"\>", ",", "\<\"gab\"\>", ",", "\<\"gad\"\>", 
   ",", "\<\"gal\"\>", ",", "\<\"gals\"\>", ",", "\<\"gar\"\>", 
   ",", "\<\"garb\"\>", ",", "\<\"gas\"\>", ",", "\<\"gel\"\>", 
   ",", "\<\"gem\"\>", ",", "\<\"girt\"\>", ",", "\<\"gnat\"\>", 
   ",", "\<\"gnus\"\>", ",", "\<\"gob\"\>", ",", "\<\"god\"\>", 
   ",", "\<\"golf\"\>", ",", "\<\"got\"\>", ",", "\<\"grub\"\>", 
   ",", "\<\"gulp\"\>", ",", "\<\"gulper\"\>", ",", "\<\"gum\"\>", 
   ",", "\<\"gums\"\>", ",", "\<\"guns\"\>", ",", "\<\"gut\"\>", 
   ",", "\<\"ha\"\>", ",", "\<\"hap\"\>", ",", "\<\"he\"\>", 
   ",", "\<\"ho\"\>", ",", "\<\"hoop\"\>", ",", "\<\"it\"\>", 
   ",", "\<\"jar\"\>", ",", "\<\"keel\"\>", ",", "\<\"keels\"\>", 
   ",", "\<\"keep\"\>", ",", "\<\"knits\"\>", ",", "\<\"knob\"\>", 
   ",", "\<\"know\"\>", ",", "\<\"laced\"\>", ",", "\<\"lag\"\>", 
   ",", "\<\"lager\"\>", ",", "\<\"laid\"\>", ",", "\<\"lair\"\>", 
   ",", "\<\"lamina\"\>", ",", "\<\"lap\"\>", ",", "\<\"laud\"\>", 
   ",", "\<\"lee\"\>", ",", "\<\"leek\"\>", ",", "\<\"leer\"\>", 
   ",", "\<\"leg\"\>", ",", "\<\"leper\"\>", ",", "\<\"lever\"\>", 
   ",", "\<\"liar\"\>", ",", "\<\"lit\"\>", ",", "\<\"live\"\>", 
   ",", "\<\"lived\"\>", ",", "\<\"loop\"\>", ",", "\<\"loops\"\>", 
   ",", "\<\"loot\"\>", ",", "\<\"looter\"\>", ",", "\<\"loots\"\>", 
   ",", "\<\"lop\"\>", ",", "\<\"ma\"\>", ",", "\<\"mac\"\>", 
   ",", "\<\"macs\"\>", ",", "\<\"mad\"\>", ",", "\<\"maps\"\>", 
   ",", "\<\"mar\"\>", ",", "\<\"mart\"\>", ",", "\<\"mat\"\>", 
   ",", "\<\"maws\"\>", ",", "\<\"may\"\>", ",", "\<\"me\"\>", 
   ",", "\<\"meed\"\>", ",", "\<\"meet\"\>", ",", "\<\"meg\"\>", 
   ",", "\<\"mid\"\>", ",", "\<\"mils\"\>", ",", "\<\"mined\"\>", 
   ",", "\<\"mood\"\>", ",", "\<\"moor\"\>", ",", "\<\"mop\"\>", 
   ",", "\<\"mot\"\>", ",", "\<\"mu\"\>", ",", "\<\"mug\"\>", 
   ",", "\<\"nab\"\>", ",", "\<\"nap\"\>", ",", "\<\"naps\"\>", 
   ",", "\<\"net\"\>", ",", "\<\"new\"\>", ",", "\<\"nib\"\>", 
   ",", "\<\"nip\"\>", ",", "\<\"nips\"\>", ",", "\<\"nit\"\>", 
   ",", "\<\"no\"\>", ",", "\<\"nod\"\>", ",", "\<\"not\"\>", 
   ",", "\<\"now\"\>", ",", "\<\"nub\"\>", ",", "\<\"nus\"\>", 
   ",", "\<\"nut\"\>", ",", "\<\"nuts\"\>", ",", "\<\"ogre\"\>", 
   ",", "\<\"oh\"\>", ",", "\<\"on\"\>", ",", "\<\"oohs\"\>", 
   ",", "\<\"pacer\"\>", ",", "\<\"pah\"\>", ",", "\<\"pal\"\>", 
   ",", "\<\"pals\"\>", ",", "\<\"pan\"\>", ",", "\<\"pans\"\>", 
   ",", "\<\"par\"\>", ",", "\<\"part\"\>", ",", "\<\"parts\"\>", 
   ",", "\<\"pas\"\>", ",", "\<\"pat\"\>", ",", "\<\"paws\"\>", 
   ",", "\<\"pay\"\>", ",", "\<\"peed\"\>", ",", "\<\"peek\"\>", 
   ",", "\<\"peels\"\>", ",", "\<\"pees\"\>", ",", "\<\"per\"\>", 
   ",", "\<\"perts\"\>", ",", "\<\"pets\"\>", ",", "\<\"pin\"\>", 
   ",", "\<\"pins\"\>", ",", "\<\"pis\"\>", ",", "\<\"pit\"\>", 
   ",", "\<\"plug\"\>", ",", "\<\"pol\"\>", ",", "\<\"pols\"\>", 
   ",", "\<\"pom\"\>", ",", "\<\"pooh\"\>", ",", "\<\"pool\"\>", 
   ",", "\<\"pools\"\>", ",", "\<\"ports\"\>", ",", "\<\"pot\"\>", 
   ",", "\<\"pots\"\>", ",", "\<\"prat\"\>", ",", "\<\"pus\"\>", 
   ",", "\<\"rag\"\>", ",", "\<\"raga\"\>", ",", "\<\"rail\"\>", 
   ",", "\<\"raj\"\>", ",", "\<\"ram\"\>", ",", "\<\"rap\"\>", 
   ",", "\<\"raps\"\>", ",", "\<\"rat\"\>", ",", "\<\"rats\"\>", 
   ",", "\<\"raw\"\>", ",", "\<\"re\"\>", ",", "\<\"rebut\"\>", 
   ",", "\<\"recap\"\>", ",", "\<\"recaps\"\>", ",", "\<\"redraw\"\>", 
   ",", "\<\"reed\"\>", ",", "\<\"reel\"\>", ",", "\<\"ref\"\>", 
   ",", "\<\"reffed\"\>", ",", "\<\"regal\"\>", ",", "\<\"reined\"\>", 
   ",", "\<\"relaid\"\>", ",", "\<\"relive\"\>", ",", "\<\"remit\"\>", 
   ",", "\<\"rennet\"\>", ",", "\<\"rep\"\>", ",", "\<\"repaid\"\>", 
   ",", "\<\"repel\"\>", ",", "\<\"replug\"\>", ",", "\<\"retool\"\>", 
   ",", "\<\"retros\"\>", ",", "\<\"revel\"\>", ",", "\<\"reviled\"\>", 
   ",", "\<\"reward\"\>", ",", "\<\"rial\"\>", ",", "\<\"rime\"\>", 
   ",", "\<\"rood\"\>", ",", "\<\"room\"\>", ",", "\<\"rot\"\>", 
   ",", "\<\"rub\"\>", ",", "\<\"sag\"\>", ",", "\<\"sap\"\>", 
   ",", "\<\"saps\"\>", ",", "\<\"sate\"\>", ",", "\<\"saw\"\>", 
   ",", "\<\"scam\"\>", ",", "\<\"seep\"\>", ",", "\<\"seined\"\>", 
   ",", "\<\"sered\"\>", ",", "\<\"serif\"\>", ",", "\<\"shoo\"\>", 
   ",", "\<\"sip\"\>", ",", "\<\"six\"\>", ",", "\<\"skua\"\>", 
   ",", "\<\"slag\"\>", ",", "\<\"slap\"\>", ",", "\<\"sleek\"\>", 
   ",", "\<\"sleep\"\>", ",", "\<\"sleets\"\>", ",", "\<\"slim\"\>", 
   ",", "\<\"sloop\"\>", ",", "\<\"sloops\"\>", ",", "\<\"slop\"\>", 
   ",", "\<\"smart\"\>", ",", "\<\"smug\"\>", ",", "\<\"smut\"\>", 
   ",", "\<\"snap\"\>", ",", "\<\"snaps\"\>", ",", "\<\"snip\"\>", 
   ",", "\<\"snips\"\>", ",", "\<\"snit\"\>", ",", "\<\"snoops\"\>", 
   ",", "\<\"snot\"\>", ",", "\<\"snub\"\>", ",", "\<\"snug\"\>", 
   ",", "\<\"sod\"\>", ",", "\<\"sorter\"\>", ",", "\<\"spacer\"\>", 
   ",", "\<\"spam\"\>", ",", "\<\"span\"\>", ",", "\<\"spans\"\>", 
   ",", "\<\"spar\"\>", ",", "\<\"spas\"\>", ",", "\<\"spat\"\>", 
   ",", "\<\"spay\"\>", ",", "\<\"speed\"\>", ",", "\<\"spin\"\>", 
   ",", "\<\"spins\"\>", ",", "\<\"spit\"\>", ",", "\<\"spool\"\>", 
   ",", "\<\"spools\"\>", ",", "\<\"spoons\"\>", ",", "\<\"sports\"\>", 
   ",", "\<\"spot\"\>", ",", "\<\"spots\"\>", ",", "\<\"sprat\"\>", 
   ",", "\<\"stab\"\>", ",", "\<\"star\"\>", ",", "\<\"steels\"\>", 
   ",", "\<\"step\"\>", ",", "\<\"stew\"\>", ",", "\<\"stink\"\>", 
   ",", "\<\"stool\"\>", ",", "\<\"stop\"\>", ",", "\<\"stops\"\>", 
   ",", "\<\"stows\"\>", ",", "\<\"strap\"\>", ",", "\<\"straw\"\>", 
   ",", "\<\"strep\"\>", ",", "\<\"stressed\"\>", ",", "\<\"strop\"\>", 
   ",", "\<\"strops\"\>", ",", "\<\"stub\"\>", ",", "\<\"stun\"\>", 
   ",", "\<\"sub\"\>", ",", "\<\"sun\"\>", ",", "\<\"sung\"\>", 
   ",", "\<\"sup\"\>", ",", "\<\"swam\"\>", ",", "\<\"swap\"\>", 
   ",", "\<\"sward\"\>", ",", "\<\"sway\"\>", ",", "\<\"swot\"\>", 
   ",", "\<\"swots\"\>", ",", "\<\"ta\"\>", ",", "\<\"tab\"\>", 
   ",", "\<\"tam\"\>", ",", "\<\"tang\"\>", ",", "\<\"tap\"\>", 
   ",", "\<\"taps\"\>", ",", "\<\"tar\"\>", ",", "\<\"tarp\"\>", 
   ",", "\<\"tarps\"\>", ",", "\<\"teem\"\>", ",", "\<\"ten\"\>", 
   ",", "\<\"tenner\"\>", ",", "\<\"ti\"\>", ",", "\<\"tide\"\>", 
   ",", "\<\"til\"\>", ",", "\<\"time\"\>", ",", "\<\"timer\"\>", 
   ",", "\<\"tin\"\>", ",", "\<\"tins\"\>", ",", "\<\"tip\"\>", 
   ",", "\<\"tips\"\>", ",", "\<\"tog\"\>", ",", "\<\"tom\"\>", 
   ",", "\<\"ton\"\>", ",", "\<\"tons\"\>", ",", "\<\"tool\"\>", 
   ",", "\<\"top\"\>", ",", "\<\"tops\"\>", ",", "\<\"tor\"\>", 
   ",", "\<\"tort\"\>", ",", "\<\"tow\"\>", ",", "\<\"tows\"\>", 
   ",", "\<\"trad\"\>", ",", "\<\"tram\"\>", ",", "\<\"trams\"\>", 
   ",", "\<\"trap\"\>", ",", "\<\"trig\"\>", ",", "\<\"trot\"\>", 
   ",", "\<\"trow\"\>", ",", "\<\"tub\"\>", ",", "\<\"tuba\"\>", 
   ",", "\<\"tubed\"\>", ",", "\<\"tuber\"\>", ",", "\<\"tug\"\>", 
   ",", "\<\"tums\"\>", ",", "\<\"tun\"\>", ",", "\<\"um\"\>", 
   ",", "\<\"war\"\>", ",", "\<\"ward\"\>", ",", "\<\"warder\"\>", 
   ",", "\<\"warts\"\>", ",", "\<\"was\"\>", ",", "\<\"way\"\>", 
   ",", "\<\"wed\"\>", ",", "\<\"wen\"\>", ",", "\<\"wets\"\>", 
   ",", "\<\"wolf\"\>", ",", "\<\"won\"\>", ",", "\<\"wonk\"\>", 
   ",", "\<\"wort\"\>", ",", "\<\"wot\"\>", ",", "\<\"xis\"\>", 
   ",", "\<\"yam\"\>", ",", "\<\"yap\"\>", ",", "\<\"yaps\"\>", 
   ",", "\<\"yard\"\>", ",", "\<\"yaw\"\>", ",", "\<\"yaws\"\>", 
   ",", "\<\"yob\"\>"}], "}"}]], "Output",
 CellChangeTimes->{
  3.732952842826069*^9, 3.7329528855601473`*^9, 3.732953030738023*^9, 
   3.732953267555522*^9, 3.732953301758925*^9, {3.73295336589874*^9, 
   3.732953404897389*^9}, 3.732953441044342*^9, {3.732953561241152*^9, 
   3.732953603365443*^9}, 3.7329536421975393`*^9, 3.732970584421617*^9, 
   3.733050959169518*^9, 3.733051379945675*^9, 3.7330579610448923`*^9, 
   3.733065950340102*^9, 3.733074340454225*^9, 3.7330801350245113`*^9, 
   3.73312554209477*^9, 3.73312843025711*^9, 3.733133478422048*^9, 
   3.733212696264247*^9, 3.733212991358884*^9, 3.733216103967507*^9, 
   3.733216264689027*^9, 3.7332219598509817`*^9, 3.7332700335889797`*^9, 
   3.733277841894606*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "Finding all anagrams of the given word is another boilerplate programming \
exercise for the second programming course of which this lab is giving a \
sneak preview. The intended solution of this problem, given as a hint to the \
students, is to sort the arrays of characters of the words and compare these \
arrays for equality to determine whether these two words are anagrams. \
(Alternatively, since in this problem there are known to be exactly 26 \
different characters, we could use an array of counters incremented \
elementwise by one for-loop through each word, and then compare the pairwise \
equality of the resulting counters.)\nTo make this problem more fun and ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 "-l, we recall the ",
 StyleBox["Fundamental Theorem of Arithmetic ",
  FontSlant->"Italic"],
 "that guarantees that every positive integer has a ",
 StyleBox["unique prime factorization",
  FontSlant->"Italic"],
 ". This theorem can be used to convert words to integers so that two words \
become the same integer if and only if they are anagrams. Each of the 26 \
lowercase characters that can appear inside a word is mapped to a prime \
number, after which the ",
 StyleBox["G\[ODoubleDot]del number",
  FontSlant->"Italic"],
 " of each word is the product of the prime numbers that encode the \
characters in the word. Since integer multiplication is orderless, two \
anagrams must necessarily produce the same G\[ODoubleDot]del number, so we \
can effectively use this G\[ODoubleDot]del number as a ",
 StyleBox["hash code",
  FontSlant->"Italic"],
 " that is ",
 StyleBox["consistent",
  FontSlant->"Italic"],
 " with respect to the ",
 StyleBox["equivalence relation",
  FontSlant->"Italic"],
 " of anagrams. The function ",
 StyleBox["Thread",
  FontWeight->"Bold"],
 " is a handy way to \[OpenCurlyDoubleQuote]zip\[CloseCurlyDoubleQuote] two \
lists of same length together into one list whose each element is a pair of \
corresponding elements of the original lists, combined together under the \
given head. The list of substitution rules produced this way is used to \
convert the extracted letters of the word into the list their corresponding \
prime numbers, which are then multiplied together simply by applying ",
 StyleBox["Times",
  FontWeight->"Bold"],
 " to the head of this list. ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " is not needlessly picky about what characters it accepts in function names."
}], "Text",
 CellChangeTimes->{{3.7329538328234367`*^9, 3.732953884509248*^9}, {
  3.732953993308696*^9, 3.732954011059712*^9}, {3.7329543537491837`*^9, 
  3.73295450430737*^9}, {3.732955154567883*^9, 3.732955287806669*^9}, {
  3.732956952599736*^9, 3.7329571402988167`*^9}, {3.733046122701064*^9, 
  3.7330462575397863`*^9}, {3.7330652717622843`*^9, 3.733065376085326*^9}, {
  3.733071106514045*^9, 3.733071168698633*^9}, {3.7332529374781446`*^9, 
  3.733252999383595*^9}, {3.733269271255961*^9, 3.733269301448772*^9}, {
  3.7332765306963997`*^9, 3.733276615828429*^9}, {3.733278123688345*^9, 
  3.733278124901396*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{"primeEncode", " ", "=", " ", 
  RowBox[{"Thread", "[", 
   RowBox[{
    RowBox[{
     RowBox[{"(", 
      RowBox[{"#1", " ", "\[Rule]", " ", "#2"}], ")"}], "&"}], "[", 
    RowBox[{
     RowBox[{"CharacterRange", "[", 
      RowBox[{"\"\<a\>\"", ",", " ", "\"\<z\>\""}], "]"}], ",", 
     RowBox[{"Table", "[", 
      RowBox[{
       RowBox[{"Prime", "[", "i", "]"}], ",", " ", 
       RowBox[{"{", 
        RowBox[{"i", ",", " ", "1", ",", " ", "26"}], "}"}]}], "]"}]}], "]"}],
    "]"}]}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"g\[ODoubleDot]delNumber", "[", "word_", "]"}], " ", ":=", " ", 
   RowBox[{"Times", " ", "@@", " ", 
    RowBox[{"(", 
     RowBox[{
      RowBox[{"Characters", "[", "word", "]"}], " ", "/.", " ", 
      "primeEncode"}], ")"}]}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"g\[ODoubleDot]delNumber", "[", "\"\<hello\>\"", 
  "]"}], "\[IndentingNewLine]", 
 RowBox[{"g\[ODoubleDot]delNumber", "[", 
  "\"\<supercalifragilisticexpialidocious\>\"", "]"}]}], "Input",
 CellChangeTimes->{{3.732953891014646*^9, 3.732953967780839*^9}, {
  3.732954013605896*^9, 3.73295408780632*^9}, {3.732954135059861*^9, 
  3.732954344030654*^9}, {3.732954548321557*^9, 3.732954550246049*^9}, {
  3.7329573431133223`*^9, 3.732957354706971*^9}, {3.733046214827278*^9, 
  3.7330462169786*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"\<\"a\"\>", "\[Rule]", "2"}], ",", 
   RowBox[{"\<\"b\"\>", "\[Rule]", "3"}], ",", 
   RowBox[{"\<\"c\"\>", "\[Rule]", "5"}], ",", 
   RowBox[{"\<\"d\"\>", "\[Rule]", "7"}], ",", 
   RowBox[{"\<\"e\"\>", "\[Rule]", "11"}], ",", 
   RowBox[{"\<\"f\"\>", "\[Rule]", "13"}], ",", 
   RowBox[{"\<\"g\"\>", "\[Rule]", "17"}], ",", 
   RowBox[{"\<\"h\"\>", "\[Rule]", "19"}], ",", 
   RowBox[{"\<\"i\"\>", "\[Rule]", "23"}], ",", 
   RowBox[{"\<\"j\"\>", "\[Rule]", "29"}], ",", 
   RowBox[{"\<\"k\"\>", "\[Rule]", "31"}], ",", 
   RowBox[{"\<\"l\"\>", "\[Rule]", "37"}], ",", 
   RowBox[{"\<\"m\"\>", "\[Rule]", "41"}], ",", 
   RowBox[{"\<\"n\"\>", "\[Rule]", "43"}], ",", 
   RowBox[{"\<\"o\"\>", "\[Rule]", "47"}], ",", 
   RowBox[{"\<\"p\"\>", "\[Rule]", "53"}], ",", 
   RowBox[{"\<\"q\"\>", "\[Rule]", "59"}], ",", 
   RowBox[{"\<\"r\"\>", "\[Rule]", "61"}], ",", 
   RowBox[{"\<\"s\"\>", "\[Rule]", "67"}], ",", 
   RowBox[{"\<\"t\"\>", "\[Rule]", "71"}], ",", 
   RowBox[{"\<\"u\"\>", "\[Rule]", "73"}], ",", 
   RowBox[{"\<\"v\"\>", "\[Rule]", "79"}], ",", 
   RowBox[{"\<\"w\"\>", "\[Rule]", "83"}], ",", 
   RowBox[{"\<\"x\"\>", "\[Rule]", "89"}], ",", 
   RowBox[{"\<\"y\"\>", "\[Rule]", "97"}], ",", 
   RowBox[{"\<\"z\"\>", "\[Rule]", "101"}]}], "}"}]], "Output",
 CellChangeTimes->{
  3.7329539707994833`*^9, {3.732954297780438*^9, 3.732954344749119*^9}, {
   3.7329573475353823`*^9, 3.732957356108994*^9}, 3.7329705846359873`*^9, 
   3.733046222595666*^9, 3.733050959462182*^9, 3.733051380199201*^9, 
   3.733057961292788*^9, 3.7330659505899353`*^9, 3.733074340764031*^9, 
   3.733080135400796*^9, 3.733125542449415*^9, 3.733128430639896*^9, 
   3.733133478686666*^9, 3.7332126966301622`*^9, 3.73321299164962*^9, 
   3.733216264916814*^9, 3.733221960171132*^9, 3.733270033892643*^9, 
   3.733277842168221*^9},
 FontSize->14],

Cell[BoxData["13447687"], "Output",
 CellChangeTimes->{
  3.7329539707994833`*^9, {3.732954297780438*^9, 3.732954344749119*^9}, {
   3.7329573475353823`*^9, 3.732957356108994*^9}, 3.7329705846359873`*^9, 
   3.733046222595666*^9, 3.733050959462182*^9, 3.733051380199201*^9, 
   3.733057961292788*^9, 3.7330659505899353`*^9, 3.733074340764031*^9, 
   3.733080135400796*^9, 3.733125542449415*^9, 3.733128430639896*^9, 
   3.733133478686666*^9, 3.7332126966301622`*^9, 3.73321299164962*^9, 
   3.733216264916814*^9, 3.733221960171132*^9, 3.733270033892643*^9, 
   3.733277842178041*^9},
 FontSize->14],

Cell[BoxData["7549206708138164397666367808363985304525621000"], "Output",
 CellChangeTimes->{
  3.7329539707994833`*^9, {3.732954297780438*^9, 3.732954344749119*^9}, {
   3.7329573475353823`*^9, 3.732957356108994*^9}, 3.7329705846359873`*^9, 
   3.733046222595666*^9, 3.733050959462182*^9, 3.733051380199201*^9, 
   3.733057961292788*^9, 3.7330659505899353`*^9, 3.733074340764031*^9, 
   3.733080135400796*^9, 3.733125542449415*^9, 3.733128430639896*^9, 
   3.733133478686666*^9, 3.7332126966301622`*^9, 3.73321299164962*^9, 
   3.733216264916814*^9, 3.733221960171132*^9, 3.733270033892643*^9, 
   3.733277842184901*^9},
 FontSize->14]
}, Open  ]],

Cell["\<\
The anagrams of the given word can now be identified by the equality of their \
G\[ODoubleDot]del numbers. To speed up the computation, we use the length \
equality comparison as a quick rejection test before computing the G\
\[ODoubleDot]del number that bears the real brunt of this comparison.\
\>", "Text",
 CellChangeTimes->{{3.732954525731544*^9, 3.732954542194293*^9}, {
  3.732955333439292*^9, 3.73295536254884*^9}, {3.7329558368301077`*^9, 
  3.7329558398203897`*^9}, {3.732956698449665*^9, 3.732956708096509*^9}, {
  3.732957289689563*^9, 3.73295730072654*^9}, {3.73295738497475*^9, 
  3.732957395709745*^9}, {3.733046292671026*^9, 3.7330463046418457`*^9}, {
  3.733049716275111*^9, 3.7330497182579937`*^9}, {3.733065404820599*^9, 
  3.7330654107420464`*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"findAnagrams", "[", 
    RowBox[{"words_", ",", " ", "w_"}], "]"}], " ", ":=", " ", 
   RowBox[{"With", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"g", " ", "=", " ", 
       RowBox[{"g\[ODoubleDot]delNumber", "[", "w", "]"}]}], "}"}], ",", " ", 
     
     RowBox[{"Select", "[", 
      RowBox[{"words", ",", " ", 
       RowBox[{
        RowBox[{"(", 
         RowBox[{
          RowBox[{
           RowBox[{"Length", "[", "#", "]"}], " ", "\[Equal]", " ", 
           RowBox[{"Length", "[", "w", "]"}]}], " ", "&&", " ", 
          RowBox[{
           RowBox[{"g\[ODoubleDot]delNumber", "[", "#", "]"}], " ", 
           "\[Equal]", " ", "g"}]}], ")"}], "&"}]}], "]"}]}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"findAnagrams", "[", 
  RowBox[{"words", ",", " ", "\"\<pastel\>\""}], "]"}]}], "Input",
 CellChangeTimes->{{3.73295455251754*^9, 3.7329545844186583`*^9}, {
  3.732954952708194*^9, 3.732954972502983*^9}, {3.7330462197666473`*^9, 
  3.733046219931385*^9}, {3.7330511885649652`*^9, 3.733051193454975*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"\<\"palest\"\>", ",", "\<\"pastel\"\>", ",", "\<\"petals\"\>", 
   ",", "\<\"plates\"\>", ",", "\<\"pleats\"\>", ",", "\<\"staple\"\>"}], 
  "}"}]], "Output",
 CellChangeTimes->{{3.7329545800151577`*^9, 3.732954586195051*^9}, 
   3.732970586027032*^9, 3.73304622653539*^9, 3.733050959652914*^9, 
   3.733051381575141*^9, 3.733057962711092*^9, 3.733065952052804*^9, 
   3.733074342368279*^9, 3.73308013695261*^9, 3.733125543824012*^9, 
   3.73312843204541*^9, 3.733133480166206*^9, 3.733212698060727*^9, 
   3.733212993054501*^9, 3.733216266343296*^9, 3.733221961794785*^9, 
   3.73327003533559*^9, 3.733277843576076*^9},
 FontSize->14]
}, Open  ]],

Cell[TextData[{
 "The fourth question of this penultimate lab, a new one for the current \
semester whose completion inspired the author to write this document, turned \
out to be just too difficult for students, so it was left out of the marking \
of the lab altogether. Regular expressions would make short work of this \
problem, but without that formalism, the working recursive solution is not \
really that obvious, and the loop solution that the instructor had in mind \
actually turned not to work when implemented as simply as was originally \
planned.\nThe problem specification is otherwise the same as the first \
problem of wildcard matching, but now the wildcards are asterisks that can \
match any sequence of zero or more characters that are now allowed to be any \
characters, including those that occur somewhere else in the pattern. (Would \
it be possible to create a version of Hangman where each guess could be some \
more general pattern than merely a single letter? That little aside might be \
a topic to explore in a different day.) We can try out this implementation by \
using it to find out how many words in English contain the letter ",
 StyleBox["a",
  FontSlant->"Italic"],
 " exactly four times."
}], "Text",
 CellChangeTimes->{{3.7329549329965763`*^9, 3.732954993795026*^9}, {
  3.7329555828983192`*^9, 3.7329555978969584`*^9}, {3.732956179496339*^9, 
  3.732956196912861*^9}, {3.732957168080637*^9, 3.732957183505127*^9}, {
  3.732963795671092*^9, 3.732963873933666*^9}, {3.732964361575194*^9, 
  3.7329644048611*^9}, {3.73296446562186*^9, 3.7329645805965*^9}, {
  3.732964792536518*^9, 3.732964823672447*^9}, {3.732965125019108*^9, 
  3.732965165332541*^9}, {3.7329652743605433`*^9, 3.732965288497446*^9}, {
  3.732965335297203*^9, 3.732965398359846*^9}, {3.733046319873246*^9, 
  3.7330463827366123`*^9}, {3.733071212434445*^9, 3.733071224222595*^9}, {
  3.733219291400886*^9, 3.733219291847434*^9}, {3.7332766499094477`*^9, 
  3.733276739968885*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"starPattern", "[", "pat_", "]"}], " ", ":=", " ", 
   RowBox[{"RegularExpression", "[", 
    RowBox[{"StringJoin", "[", 
     RowBox[{
      RowBox[{"Characters", "[", "pat", "]"}], " ", "/.", " ", 
      RowBox[{"\"\<*\>\"", " ", "\[Rule]", " ", "\"\<(.*)\>\""}]}], "]"}], 
    "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"findMatchingWordsStar", "[", 
    RowBox[{"words_", ",", " ", "pattern_"}], "]"}], " ", ":=", " ", 
   RowBox[{"With", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"sp", " ", "=", " ", 
       RowBox[{"starPattern", "[", "pattern", "]"}]}], "}"}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{"Select", "[", 
      RowBox[{"words", ",", " ", 
       RowBox[{
        RowBox[{"StringMatchQ", "[", 
         RowBox[{"#", ",", " ", "sp"}], "]"}], "&"}]}], "]"}]}], 
    "\[IndentingNewLine]", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{"Complement", "[", 
  RowBox[{
   RowBox[{"findMatchingWordsStar", "[", 
    RowBox[{"words", ",", " ", "\"\<*a*a*a*a*\>\""}], "]"}], ",", " ", 
   RowBox[{"findMatchingWordsStar", "[", 
    RowBox[{"words", ",", " ", "\"\<*a*a*a*a*a*\>\""}], "]"}]}], 
  "]"}]}], "Input",
 CellChangeTimes->{{3.732955000266941*^9, 3.732955024595953*^9}, {
  3.732955064571836*^9, 3.732955065209874*^9}, {3.7329554252723923`*^9, 
  3.732955561034487*^9}, {3.732955601702179*^9, 3.732955630168973*^9}, {
  3.732956170535205*^9, 3.732956202124016*^9}, {3.732964585624424*^9, 
  3.732964596811775*^9}, {3.732964989094701*^9, 3.732965117076016*^9}, {
  3.732965161203*^9, 3.732965178091442*^9}, {3.732965232227384*^9, 
  3.732965266389227*^9}},
 FontSize->14],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"\<\"adiabatically\"\>", ",", "\<\"amalgamate\"\>", 
   ",", "\<\"amalgamated\"\>", ",", "\<\"amalgamates\"\>", 
   ",", "\<\"amalgamating\"\>", ",", "\<\"amalgamation\"\>", 
   ",", "\<\"amalgamations\"\>", ",", "\<\"ambassadorial\"\>", 
   ",", "\<\"anagrammatic\"\>", ",", "\<\"antimacassar\"\>", 
   ",", "\<\"antimacassars\"\>", ",", "\<\"antimalarial\"\>", 
   ",", "\<\"baccalaureate\"\>", ",", "\<\"baccalaureates\"\>", 
   ",", "\<\"bacchanalia\"\>", ",", "\<\"bacchanalian\"\>", 
   ",", "\<\"bacchanalians\"\>", ",", "\<\"balaclava\"\>", 
   ",", "\<\"balaclavas\"\>", ",", "\<\"balalaika\"\>", 
   ",", "\<\"balalaikas\"\>", ",", "\<\"caravansaries\"\>", 
   ",", "\<\"caravansary\"\>", ",", "\<\"catamaran\"\>", 
   ",", "\<\"catamarans\"\>", ",", "\<\"diagrammatically\"\>", 
   ",", "\<\"extravaganza\"\>", ",", "\<\"extravaganzas\"\>", 
   ",", "\<\"jacaranda\"\>", ",", "\<\"jacarandas\"\>", 
   ",", "\<\"jambalaya\"\>", ",", "\<\"lackadaisical\"\>", 
   ",", "\<\"lackadaisically\"\>", ",", "\<\"macadamia\"\>", 
   ",", "\<\"macadamias\"\>", ",", "\<\"maharajah\"\>", 
   ",", "\<\"maharajahs\"\>", ",", "\<\"palatalization\"\>", 
   ",", "\<\"paradisaical\"\>", ",", "\<\"paraphernalia\"\>", 
   ",", "\<\"parliamentarian\"\>", ",", "\<\"parliamentarians\"\>", 
   ",", "\<\"phantasmagoria\"\>", ",", "\<\"phantasmagorias\"\>", 
   ",", "\<\"phantasmagorical\"\>", ",", "\<\"sarsaparilla\"\>", 
   ",", "\<\"sarsaparillas\"\>", ",", "\<\"tarmacadam\"\>", 
   ",", "\<\"whatchamacallit\"\>", ",", "\<\"whatchamacallits\"\>"}], 
  "}"}]], "Output",
 CellChangeTimes->{
  3.732955027793282*^9, 3.7329553002516413`*^9, 3.732955632041293*^9, 
   3.732956204479266*^9, {3.732965061332678*^9, 3.732965118492915*^9}, 
   3.732965179284946*^9, {3.732965240841494*^9, 3.732965267464725*^9}, 
   3.732970586590971*^9, 3.7330509600612917`*^9, 3.733051382187168*^9, 
   3.733057963337934*^9, 3.733065952632761*^9, 3.733074343092387*^9, 
   3.733080137619816*^9, 3.73312554443016*^9, 3.733128432661737*^9, 
   3.733133480819566*^9, 3.7332126986739397`*^9, 3.733212993634746*^9, 
   3.733216266949065*^9, 3.733221962464513*^9, 3.733270035930951*^9, 
   3.733277844198515*^9},
 FontSize->14]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[StyleBox["Lab Ten: The Endgame",
 FontSize->36]], "Chapter",
 CellChangeTimes->{{3.7329654474228363`*^9, 3.732965787545919*^9}, {
  3.732965865041181*^9, 3.732965917679861*^9}, {3.732966016559476*^9, 
  3.732966028974217*^9}, {3.73296622022754*^9, 3.732966220578637*^9}, {
  3.73296636437638*^9, 3.732966471311898*^9}, {3.732968881088045*^9, 
  3.7329688936497993`*^9}, {3.7330464243856688`*^9, 3.7330468474516087`*^9}, {
  3.7330582856890707`*^9, 3.733058289135371*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[TextData[{
 StyleBox["As the grande finale for the students who have spread their wings \
and flown out of their nest, no longer helpless little hatchlings for whose \
tiny beaks and stomachs everything must be carefully regurgitated, but who \
have become mighty fearsome eagles that sink their newfound programming \
talons into any problem placed in front of them, this last lab serves a \
buffet of generalized chess problems for an arbitrary ", "Text",
  FontSize->14],
 StyleBox["n", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox["-by-", "Text",
  FontSize->14],
 StyleBox["n", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" board, just so that these students can practice their \
two-dimensional thinking a little bit more. Same as with the card games in \
the second and third labs, no knowledge of the game of chess itself is \
necessary to solve these problems. On the other hand, considering the social \
and cultural importance of the game of chess in all cultures in East and \
West, the basic moves of the different types of chess pieces should be \
elementary common knowledge of all educated adults anyway, so if they are \
not, it is high time to learn them now.\nSince the algorithm theory lecture \
two weeks before this lab strongly emphasized the importance of not being \
\[OpenCurlyDoubleQuote]Shlemiel the Painter\[CloseCurlyDoubleQuote], as named \
by Joel Spolsky in his Internet-famous blog post decades after Jon Bentley\
\[CloseCurlyQuote]s books on code optimization had long delved on that \
particular type of code optimization problem, these problems are strongly \
emphasized not use more nested loops than are necessary. Again, the JUnit \
tester class for this week\[CloseCurlyQuote]s lab is intentionally designed \
to be hard and heavy enough so that any Shlemiel solutions will take \
painfully long to execute, whereas tighter solutions can finish the job in a \
fraction of second. The threshold between linear time versus quadratic time \
algorithms is the surely most important algorithmic issue in everyday \
practical programming. It is pretty rare for most working programmers to do \
something that requires potentially exponential combinatorics, but every \
programmer writes linear for-loops and nested for-loops on a daily basis.\nOf \
course, the higher-level the language is and therefore covers up the details \
of the true computation of zeros and ones that take place underneath the \
layers of abstractions of the language that are just as made-up and fictional \
as hobbits and vampires (but still as functional for the purposes of \
expressing higher level ideas), the more difficult it is for the programmer \
to reason about the actual wall clock running time of various possible \
implementations, as the C programmers will never tire pointing out. Working \
on problems suited for ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" we pretty much ignore all small efficiencies anyway and \
concentrate on just solving the problem itself. The minutes and potentially \
more saved by solving the problem as a one-liner will then more than \
compensate for the execution time being some split second longer.\nThe first \
question starts off by asking for a method that counts how many squares in \
the ", "Text",
  FontSize->14],
 StyleBox["n", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox["-by-", "Text",
  FontSize->14],
 StyleBox["n", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" chessboard are safe from the all chess rooks that have already \
been placed somewhere on the board. The parameter ", "Text",
  FontSize->14],
 StyleBox["board", "Text",
  FontSize->14,
  FontWeight->"Bold"],
 StyleBox[" is guaranteed to be an ", "Text",
  FontSize->14],
 StyleBox["n", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox["-by-", "Text",
  FontSize->14],
 StyleBox["n", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" matrix of truth values whose elements are ", "Text",
  FontSize->14],
 StyleBox["True", "Text",
  FontSize->14,
  FontWeight->"Bold"],
 StyleBox[" for a square that contains a rook, and ", "Text",
  FontSize->14],
 StyleBox["False", "Text",
  FontSize->14,
  FontWeight->"Bold"],
 StyleBox[" for an empty square. Using the observation that a row or a column \
is unsafe if any one of its squares contains a rook, this unsafety can be \
expressed as a logical disjunction between the elements of that row or \
column. Since permuting the rows and columns does not change the answer to \
this question, we can imagine all the safe rows and safe columns to have been \
permuted to be together in one clump, making that answer to be the product of \
these counts of safe rows and safe columns free of threatening rooks and \
other mooks.", "Text",
  FontSize->14]
}], "Text",
 CellChangeTimes->{
  3.7330582967672462`*^9, {3.733065423224039*^9, 3.733065751305664*^9}, {
   3.7330712398675632`*^9, 3.7330712644807377`*^9}, {3.7331301768394337`*^9, 
   3.7331302123095827`*^9}, {3.73327060084179*^9, 3.733270607741116*^9}, {
   3.733276762713436*^9, 3.7332770631901293`*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"countSafeSquaresRooks", "[", "board_", "]"}], " ", ":=", 
   RowBox[{"With", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{
       RowBox[{"unsafeRows", " ", "=", " ", 
        RowBox[{"Apply", "[", 
         RowBox[{"Or", ",", " ", "board", ",", " ", 
          RowBox[{"{", "1", "}"}]}], "]"}]}], ",", " ", 
       RowBox[{"unsafeCols", " ", "=", " ", 
        RowBox[{"Apply", "[", 
         RowBox[{"Or", ",", " ", 
          RowBox[{"Transpose", "[", "board", "]"}], ",", " ", 
          RowBox[{"{", "1", "}"}]}], "]"}]}]}], "}"}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"Count", "[", 
       RowBox[{"unsafeRows", ",", " ", "False"}], "]"}], " ", "*", " ", 
      RowBox[{"Count", "[", 
       RowBox[{"unsafeCols", ",", " ", "False"}], "]"}]}]}], 
    "\[IndentingNewLine]", "]"}]}], ";"}]], "Input",
 CellChangeTimes->{{3.732965795250093*^9, 3.7329658622065573`*^9}, 
   3.7329660145693007`*^9, {3.732966103995895*^9, 3.73296634054571*^9}, {
   3.732966477138199*^9, 3.73296648059317*^9}, 3.7329665791892757`*^9, {
   3.732969057319282*^9, 3.732969061678035*^9}},
 FontSize->14],

Cell["\<\
The second question gives the method a board that contains chess knights of \
the same colour placed on that board, and asks for the count of how many \
different possible moves exist in that situation. Each chess knight can move \
up to eight other squares, jumping over another chess knight if necessary, \
but it cannot move outside the board or into a square that is already \
occupied by another chess knight of the same colour. As a hint to get started \
with this problem, the lab specification provides an array of possible move \
offsets that describe the possible moves of a chess knight, relative to its \
present position.\
\>", "Text",
 CellChangeTimes->{{3.732966497886818*^9, 3.732966568644987*^9}, {
  3.732966614349041*^9, 3.732966636859975*^9}, {3.732966674171042*^9, 
  3.732966703035162*^9}, {3.732967085948271*^9, 3.732967088077259*^9}, {
  3.7330468642265997`*^9, 3.733046897352839*^9}, {3.733277079638093*^9, 
  3.733277119154736*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[
 RowBox[{
  RowBox[{"knightMoves", " ", "=", " ", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"2", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "2"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{
       RowBox[{"-", "1"}], ",", "2"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{
       RowBox[{"-", "2"}], ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{
       RowBox[{"-", "2"}], ",", 
       RowBox[{"-", "1"}]}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{
       RowBox[{"-", "1"}], ",", 
       RowBox[{"-", "2"}]}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", 
       RowBox[{"-", "2"}]}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", 
       RowBox[{"-", "1"}]}], "}"}]}], "}"}]}], ";"}]], "Input",
 CellChangeTimes->{{3.732966640749057*^9, 3.732966669852272*^9}, 
   3.732966705660987*^9, {3.732966829155061*^9, 3.7329669878234167`*^9}, {
   3.732967075711088*^9, 3.732967075824012*^9}},
 FontSize->14],

Cell[TextData[{
 "The total number of moves on this board is then the sum of the counts for \
possible moves for each individual knight. So that the entire board does not \
get copied every time we compute the number of moves in the given square, \
this function is written as a ",
 StyleBox["Module",
  FontWeight->"Bold"],
 " whose inner functions then all see and share the same ",
 StyleBox["board",
  FontWeight->"Bold"],
 "."
}], "Text",
 CellChangeTimes->{{3.7329670968451557`*^9, 3.732967133084222*^9}, {
   3.732967398231504*^9, 3.732967399375903*^9}, {3.732967445432026*^9, 
   3.732967451784644*^9}, {3.732967613293591*^9, 3.7329676579243383`*^9}, 
   3.733046902607534*^9, {3.7332771278054743`*^9, 3.733277140890152*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"countKnightMoves", "[", "board_", "]"}], " ", ":=", " ", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{
       RowBox[{"n", " ", "=", " ", 
        RowBox[{"Length", "[", "board", "]"}]}], ",", "inside", ",", 
       "moves"}], "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{
       RowBox[{"inside", "[", 
        RowBox[{"row_", ",", "col_"}], "]"}], ":=", " ", 
       RowBox[{
        RowBox[{
        "1", " ", "\[LessEqual]", " ", "row", " ", "\[LessEqual]", " ", "n"}],
         " ", "&&", " ", 
        RowBox[{
        "1", " ", "\[LessEqual]", "  ", "col", " ", "\[LessEqual]", " ", 
         "n"}]}]}], ";", "\[IndentingNewLine]", 
      RowBox[{
       RowBox[{"moves", "[", 
        RowBox[{"row_", ",", "col_"}], "]"}], " ", ":=", " ", 
       RowBox[{"If", "[", 
        RowBox[{
         RowBox[{"board", "[", 
          RowBox[{"[", 
           RowBox[{"row", ",", "col"}], "]"}], "]"}], ",", " ", 
         "\[IndentingNewLine]", 
         RowBox[{"Count", "[", 
          RowBox[{
           RowBox[{"Table", "[", 
            RowBox[{
             RowBox[{"With", "[", 
              RowBox[{
               RowBox[{"{", 
                RowBox[{
                 RowBox[{"nr", " ", "=", " ", 
                  RowBox[{"row", " ", "+", " ", 
                   RowBox[{"m", "[", 
                    RowBox[{"[", "1", "]"}], "]"}]}]}], ",", " ", 
                 RowBox[{"nc", " ", "=", " ", 
                  RowBox[{"col", " ", "+", " ", 
                   RowBox[{"m", "[", 
                    RowBox[{"[", "2", "]"}], "]"}]}]}]}], "}"}], ",", 
               RowBox[{
                RowBox[{"inside", "[", 
                 RowBox[{"nr", ",", "nc"}], "]"}], " ", "&&", " ", 
                RowBox[{"Not", "[", 
                 RowBox[{"board", "[", 
                  RowBox[{"[", 
                   RowBox[{"nr", ",", "nc"}], "]"}], "]"}], "]"}]}]}], "]"}], 
             ",", " ", 
             RowBox[{"{", 
              RowBox[{"m", ",", " ", "knightMoves"}], "}"}]}], "]"}], ",", 
           " ", "True"}], "]"}], "\[IndentingNewLine]", ",", 
         "\[IndentingNewLine]", "0"}], "]"}]}], ";", "\[IndentingNewLine]", 
      RowBox[{"Total", "[", 
       RowBox[{
        RowBox[{"Table", "[", 
         RowBox[{
          RowBox[{"moves", "[", 
           RowBox[{"row", ",", "col"}], "]"}], ",", 
          RowBox[{"{", 
           RowBox[{"row", ",", "1", ",", "n"}], "}"}], ",", 
          RowBox[{"{", 
           RowBox[{"col", ",", "1", ",", "n"}], "}"}]}], "]"}], ",", " ", 
        "2"}], "]"}]}]}], "\[IndentingNewLine]", "]"}]}], ";"}]], "Input",
 CellChangeTimes->{{3.732967147909206*^9, 3.732967484457533*^9}, {
  3.732967536464427*^9, 3.7329675391113358`*^9}, {3.732967576632825*^9, 
  3.732967602408223*^9}, {3.7329677317820168`*^9, 3.732967732276938*^9}, {
  3.732968245286664*^9, 3.7329682928292007`*^9}},
 FontSize->14],

Cell[TextData[{
 "The third question is similarly counting the number of possible moves on \
the argument board, but now for the first time for this lab, this calculation \
is performed for a board that contains some number of both black and white \
pieces. In this question, each piece is a pawn of either colour. As per the \
rules of chess, a chess pawn can move one step forward to an empty square, or \
capture forward-left or forward-right another pawn of the opposite colour. \
(For simplicity, we ignore the pawn promotions in the last row, and also the ",
 StyleBox["en passant",
  FontSlant->"Italic"],
 " capturing moves that would require additional bits of state information to \
remember how a pawn got to the square that it is currently in.) The parameter \
board is now a matrix of individual letter characters so that ",
 StyleBox["w",
  FontSlant->"Italic"],
 " represents a white pawn, ",
 StyleBox["b",
  FontSlant->"Italic"],
 " represents a black pawn, and the whitespace character represents an empty \
tile.\nAs always in these labs, the problem guarantees that these are the \
only possible characters that can occur on the given board, and the the board \
is guaranteed to be a square of dimensions ",
 StyleBox["n",
  FontSlant->"Italic"],
 "-by-",
 StyleBox["n",
  FontSlant->"Italic"],
 " for some ",
 StyleBox["n",
  FontSlant->"Italic"],
 ", so that the method does not need to perform error handling for illegal \
argument values. The method specification recommends not to copy-paste and \
duplicate the essentially same block of code separately for white and black \
pawns, but the same block of code logic, if parameterized accordingly, could \
correctly handle both colours. As the author loves to emphasize in all his \
courses whenever he can, whenever you copy-paste your own code within the \
same project, that is a ",
 StyleBox["code smell",
  FontSlant->"Italic"],
 " that guarantees that you are doing ",
 StyleBox["something",
  FontSlant->"Italic"],
 " wrong for sure. Even if the code happens to work for now, it is needlessly \
complex and will easily fail when modified in the future."
}], "Text",
 CellChangeTimes->{{3.732967678460446*^9, 3.732967802769655*^9}, {
  3.732967839240778*^9, 3.732967877240673*^9}, {3.732968241667925*^9, 
  3.73296824190735*^9}, {3.732968314378859*^9, 3.7329683510572*^9}, {
  3.732968559847948*^9, 3.732968765955813*^9}, {3.733046916385285*^9, 
  3.73304707107922*^9}, {3.733071308161317*^9, 3.733071308369802*^9}, {
  3.73327715308524*^9, 3.733277258425749*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"countPawnMoves", "[", "board_", "]"}], " ", ":=", " ", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{
       RowBox[{"n", " ", "=", " ", 
        RowBox[{"Length", "[", "board", "]"}]}], ",", " ", "inside", ",", " ",
        "moves", ",", " ", "forward"}], "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{
       RowBox[{"inside", "[", 
        RowBox[{"row_", ",", "col_"}], "]"}], ":=", " ", 
       RowBox[{
        RowBox[{
        "1", " ", "\[LessEqual]", " ", "row", " ", "\[LessEqual]", " ", "n"}],
         " ", "&&", " ", 
        RowBox[{
        "1", " ", "\[LessEqual]", " ", "col", " ", "\[LessEqual]", " ", 
         "n"}]}]}], ";", "\[IndentingNewLine]", 
      RowBox[{
       RowBox[{"forward", "[", 
        RowBox[{"row_", ",", " ", "piece_"}], "]"}], " ", ":=", " ", 
       RowBox[{"If", "[", 
        RowBox[{
         RowBox[{"piece", " ", "\[Equal]", " ", "\"\<w\>\""}], ",", " ", 
         RowBox[{"row", "-", "1"}], ",", " ", 
         RowBox[{"row", "+", "1"}]}], "]"}]}], ";", "\[IndentingNewLine]", 
      RowBox[{
       RowBox[{"moves", "[", 
        RowBox[{"row_", ",", "col_"}], "]"}], " ", ":=", " ", 
       RowBox[{"If", "[", 
        RowBox[{
         RowBox[{
          RowBox[{"board", "[", 
           RowBox[{"[", 
            RowBox[{"row", ",", "col"}], "]"}], "]"}], " ", "\[Equal]", " ", 
          "\"\< \>\""}], ",", " ", "0", ",", "\[IndentingNewLine]", 
         RowBox[{"With", "[", 
          RowBox[{
           RowBox[{"{", 
            RowBox[{"piece", " ", "=", " ", 
             RowBox[{"board", "[", 
              RowBox[{"[", 
               RowBox[{"row", ",", "col"}], "]"}], "]"}]}], "}"}], ",", 
           "\[IndentingNewLine]", 
           RowBox[{"With", "[", 
            RowBox[{
             RowBox[{"{", 
              RowBox[{
               RowBox[{"oppo", " ", "=", " ", 
                RowBox[{"If", "[", 
                 RowBox[{
                  RowBox[{"piece", " ", "\[Equal]", " ", "\"\<w\>\""}], ",", 
                  " ", "\"\<b\>\"", ",", " ", "\"\<w\>\""}], "]"}]}], ",", 
               " ", 
               RowBox[{"r2", " ", "=", " ", 
                RowBox[{"forward", "[", 
                 RowBox[{"row", ",", " ", "piece"}], "]"}]}]}], "}"}], ",", 
             "\[IndentingNewLine]", 
             RowBox[{
              RowBox[{"If", "[", 
               RowBox[{
                RowBox[{
                 RowBox[{"inside", "[", 
                  RowBox[{"r2", ",", "col"}], "]"}], " ", "&&", " ", 
                 RowBox[{
                  RowBox[{"board", "[", 
                   RowBox[{"[", 
                    RowBox[{"r2", ",", "col"}], "]"}], "]"}], " ", "\[Equal]",
                   " ", "\"\< \>\""}]}], ",", " ", "1", ",", " ", "0"}], 
               "]"}], " ", "+", "\[IndentingNewLine]", 
              RowBox[{"If", "[", 
               RowBox[{
                RowBox[{
                 RowBox[{"inside", "[", 
                  RowBox[{"r2", ",", 
                   RowBox[{"col", "-", "1"}]}], "]"}], " ", "&&", " ", 
                 RowBox[{
                  RowBox[{"board", "[", 
                   RowBox[{"[", 
                    RowBox[{"r2", ",", 
                    RowBox[{"col", "-", "1"}]}], "]"}], "]"}], " ", 
                  "\[Equal]", " ", "oppo"}]}], ",", " ", "1", ",", " ", "0"}],
                "]"}], " ", "+", "\[IndentingNewLine]", 
              RowBox[{"If", "[", 
               RowBox[{
                RowBox[{
                 RowBox[{"inside", "[", 
                  RowBox[{"r2", ",", 
                   RowBox[{"col", "+", "1"}]}], "]"}], " ", "&&", " ", 
                 RowBox[{
                  RowBox[{"board", "[", 
                   RowBox[{"[", 
                    RowBox[{"r2", ",", 
                    RowBox[{"col", "+", "1"}]}], "]"}], "]"}], " ", 
                  "\[Equal]", " ", "oppo"}]}], ",", " ", "1", ",", " ", "0"}],
                "]"}]}]}], "\[IndentingNewLine]", "]"}]}], 
          "\[IndentingNewLine]", "]"}]}], "]"}]}], ";", "\[IndentingNewLine]", 
      RowBox[{"Total", "[", 
       RowBox[{
        RowBox[{"Table", "[", 
         RowBox[{
          RowBox[{"moves", "[", 
           RowBox[{"x", ",", "y"}], "]"}], ",", 
          RowBox[{"{", 
           RowBox[{"x", ",", "1", ",", "n"}], "}"}], ",", 
          RowBox[{"{", 
           RowBox[{"y", ",", "1", ",", "n"}], "}"}]}], "]"}], ",", " ", "2"}],
        "]"}]}]}], "\[IndentingNewLine]", "]"}]}], ";"}]], "Input",
 CellChangeTimes->{{3.732967807963081*^9, 3.732967837354414*^9}, {
   3.732967879881051*^9, 3.732968236071556*^9}, {3.7329682967509327`*^9, 
   3.7329683118377037`*^9}, {3.732968354075981*^9, 3.732968486627061*^9}, 
   3.732968941940566*^9},
 FontSize->14],

Cell[TextData[{
 "The final question of all these labs is otherwise the same as the first \
question of this lab, but this time done for the chess queens instead of \
rooks. The ability of queens to move diagonally makes the computation of \
threatened squares more complicated than it was for the more well-behaved \
rooks that threaten only the same column and the same row that they are in. \
Fortunately, another quick googling reveals that the matrix operations of ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " happen to include the function ",
 StyleBox["Diagonal",
  FontWeight->"Bold"],
 " to extract the given diagonal of the matrix so that the diagonal 0 is the \
main diagonal, and positive numbers denote the diagonals above them."
}], "Text",
 CellChangeTimes->{{3.732968492599131*^9, 3.732968551757882*^9}, {
  3.732968637859775*^9, 3.732968638436318*^9}, {3.732968811146289*^9, 
  3.7329689047043343`*^9}, {3.732969796097608*^9, 3.7329698099621983`*^9}, {
  3.732969942959188*^9, 3.732969966903572*^9}, {3.7331283878063173`*^9, 
  3.733128393633481*^9}, {3.7332772651072598`*^9, 3.733277316063676*^9}},
 TextJustification->1.,
 FontSize->14],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"countSafeSquaresQueens", "[", "board_", "]"}], " ", ":=", " ", 
    RowBox[{"Module", "[", 
     RowBox[{
      RowBox[{"{", 
       RowBox[{
        RowBox[{"n", " ", "=", " ", 
         RowBox[{"Length", "[", "board", "]"}]}], ",", 
        RowBox[{"upsideDown", " ", "=", " ", 
         RowBox[{"Map", "[", 
          RowBox[{"Reverse", ",", " ", "board"}], "]"}]}], ",", "unsafeRows", 
        ",", " ", "unsafeCols", ",", " ", "unsafeSE", ",", " ", "unsafeSW", 
        ",", " ", "safety"}], "}"}], ",", "\[IndentingNewLine]", 
      RowBox[{
       RowBox[{"unsafeRows", " ", "=", " ", 
        RowBox[{"Apply", "[", 
         RowBox[{"Or", ",", " ", "board", ",", " ", 
          RowBox[{"{", "1", "}"}]}], "]"}]}], ";", "\[IndentingNewLine]", 
       RowBox[{"unsafeCols", " ", "=", " ", 
        RowBox[{"Apply", "[", 
         RowBox[{"Or", ",", " ", 
          RowBox[{"Transpose", "[", "board", "]"}], ",", " ", 
          RowBox[{"{", "1", "}"}]}], "]"}]}], ";", "\[IndentingNewLine]", 
       RowBox[{"unsafeSE", " ", "=", " ", 
        RowBox[{"Table", "[", 
         RowBox[{
          RowBox[{"Apply", "[", 
           RowBox[{"Or", ",", " ", 
            RowBox[{"Diagonal", "[", 
             RowBox[{"board", ",", "k"}], "]"}]}], "]"}], ",", 
          RowBox[{"{", 
           RowBox[{"k", ",", " ", 
            RowBox[{
             RowBox[{"-", "n"}], "+", "1"}], ",", " ", 
            RowBox[{"n", "-", "1"}]}], "}"}]}], "]"}]}], ";", 
       "\[IndentingNewLine]", 
       RowBox[{"unsafeSW", " ", "=", " ", 
        RowBox[{"Table", "[", 
         RowBox[{
          RowBox[{"Apply", "[", 
           RowBox[{"Or", ",", " ", 
            RowBox[{"Diagonal", "[", 
             RowBox[{"upsideDown", ",", "k"}], "]"}]}], "]"}], ",", 
          RowBox[{"{", 
           RowBox[{"k", ",", " ", 
            RowBox[{
             RowBox[{"-", "n"}], "+", "1"}], ",", " ", 
            RowBox[{"n", "-", "1"}]}], "}"}]}], "]"}]}], ";", 
       "\[IndentingNewLine]", 
       RowBox[{
        RowBox[{"safety", "[", 
         RowBox[{"row_", ",", "col_"}], "]"}], " ", ":=", " ", 
        RowBox[{"If", "[", 
         RowBox[{
          RowBox[{
           RowBox[{"unsafeRows", "[", 
            RowBox[{"[", "row", "]"}], "]"}], " ", "||", " ", 
           RowBox[{"unsafeCols", "[", 
            RowBox[{"[", "col", "]"}], "]"}], " ", "||", " ", 
           RowBox[{"unsafeSE", "[", 
            RowBox[{"[", 
             RowBox[{"n", " ", "-", " ", "row", " ", "+", " ", "col"}], "]"}],
             "]"}], " ", "||", " ", 
           RowBox[{"unsafeSW", "[", 
            RowBox[{"[", 
             RowBox[{
              RowBox[{"2", "*", "n"}], "+", "1", "-", "row", "-", "col"}], 
             "]"}], "]"}]}], ",", " ", "0", ",", " ", "1"}], "]"}]}], ";", 
       "\[IndentingNewLine]", 
       RowBox[{"Total", "[", 
        RowBox[{
         RowBox[{"Table", "[", 
          RowBox[{
           RowBox[{"safety", "[", 
            RowBox[{"row", ",", "col"}], "]"}], ",", " ", 
           RowBox[{"{", 
            RowBox[{"row", ",", " ", "1", ",", " ", "n"}], "}"}], ",", " ", 
           RowBox[{"{", 
            RowBox[{"col", ",", " ", "1", ",", " ", "n"}], "}"}]}], "]"}], 
         ",", " ", "2"}], "]"}]}]}], "\[IndentingNewLine]", "]"}]}], ";"}], 
  " "}]], "Input",
 CellChangeTimes->{{3.7329689097853117`*^9, 3.732969195156711*^9}, {
  3.7329692280049143`*^9, 3.732969321891996*^9}, {3.732969363459655*^9, 
  3.732969421049245*^9}, {3.7329694763396673`*^9, 3.732969573279488*^9}, {
  3.732969634431383*^9, 3.732969751012259*^9}, {3.7329698269152527`*^9, 
  3.732969827254895*^9}, {3.732969924185853*^9, 3.7329699298462*^9}, {
  3.732969982241249*^9, 3.7329701065128736`*^9}, {3.732970137081553*^9, 
  3.732970139881055*^9}, {3.732970180086423*^9, 3.732970189778503*^9}, {
  3.732970226992444*^9, 3.732970268936041*^9}, {3.7329703059109163`*^9, 
  3.732970374853895*^9}, {3.732970407557241*^9, 3.732970408436734*^9}},
 FontSize->14]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[StyleBox["Conclusions",
 FontSize->36]], "Chapter",
 CellChangeTimes->{{3.733047133044446*^9, 3.73304713483663*^9}, {
   3.733047232028206*^9, 3.7330476799398317`*^9}, {3.733048370166645*^9, 
   3.733048552733913*^9}, {3.733048594407584*^9, 3.733048681173252*^9}, {
   3.733049481432314*^9, 3.733049626437065*^9}, {3.73304967186688*^9, 
   3.7330496956517277`*^9}, 3.733058312128368*^9},
 TextJustification->1.,
 FontSize->14],

Cell[TextData[{
 StyleBox["The private model answers of these ten labs prepared by the \
instructor, to prove that the lab is feasible and that the shared JUnit \
testers would have known checksums to compare the student submissions to, \
together contain 670 lines of code. Discounting for the curly braces and \
other similar waste of vertical space, this would roughly translate to about \
500 lines of actual meaty goodness of code. The above solutions written in ", 
  "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" do not contain even close to that many lines, even if we included \
all those lines that are for demonstration or sanity checks, or that perform \
all that extra stuff that was spun out of these lab problems. (Without \
bothering to actually count, the author offers a rough Stetson estimate of \
100 lines, for an average of about 2.5 lines per problem.)\nOf course, \
everyone has to admit that compiled imperative languages still have a massive \
advantage when it comes to actual execution speed. At this writing, using the \
author\[CloseCurlyQuote]s trusty six year old Mac desktop, it takes about two \
and a half minutes to ecaluate all of the expressions in this notebook \
starting from fresh kernel. But the execution time of a complicated function \
really matters only if the function is to be executed many times by many \
people, otherwise the time spent thinking and coding the function is the lion\
\[CloseCurlyQuote]s share of the total time.\nWe leave it as exercise for the \
reader to rewrite any of the previous lab solution functions to run more \
efficiently, noting how the ", "Text",
  FontSize->14],
 StyleBox["Timing", "Text",
  FontSize->14,
  FontWeight->"Bold"],
 StyleBox[" function in ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" then makes it very easy to measure the execution times of \
arbitrary computations. An interestered reader operating on any modern-day ", 
  "Text",
  FontSize->14],
 StyleBox["multicore", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" machine can also try out the speedup effects of using ", "Text",
  FontSize->14],
 StyleBox["ParallelTable", "Text",
  FontSize->14,
  FontWeight->"Bold"],
 StyleBox[" in place of ", "Text",
  FontSize->14],
 StyleBox["Table", "Text",
  FontSize->14,
  FontWeight->"Bold"],
 StyleBox[", or the more general function ", "Text",
  FontSize->14],
 StyleBox["Parallelize", "Text",
  FontSize->14,
  FontWeight->"Bold"],
 StyleBox[" that, in the finest spirit of ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" and the complete representational equivalence of code and data, \
uses ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" itself to evaluate the clever pattern matching rules that \
determine the best way to parallelize the execution of some high-level \
expression tree. In functional programming, since code and functions are \
expression trees in no way different from what we normally think of as data, \
functions can be written to analyze and create other functions (and also, of \
course, themselves) just like they can analyze and create any other data.\n\
Your humble narrator does not claim to be anything but an amateur enthusiast \
dabbling in ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[", so surely for all of these problems, those with more experience \
with this wonderfully concise and powerful language could have come up with \
solutions that are not just significantly more efficient, but also more \
elegant in their conformance to the spirit of functional programming. (The \
author would always be interested to see these solutions.)\nBut most \
importantly, especially after two decades of imperative programming, ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" is just way more ", "Text",
  FontSize->14],
 StyleBox["fun", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" than Java mired in all its bureaucratic verbosity. For example, \
at least until last week from this writing when Java 10 was released to \
finally allow the use of ", "Text",
  FontSize->14],
 StyleBox["var", "Text",
  FontSize->14,
  FontWeight->"Bold"],
 StyleBox[" in local variable declarations to mean the type of whatever is \
the formal type of the right hand side of the initialization, the Java \
language always required the programmer to say that 42 is an integer when \
assigning that value to a fresh new local variable, just to prove to the \
compiler that the programmer also knows the secret password to the treehouse \
and yes, he is also aware of the fact that 42 is an integer and can thus be \
relied to write his code correctly based on that assumption.\nConstrast this \
to ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[", where the programmers can just say what they want done and let \
the pattern matching engine fill in the detais. In Java, having first written \
the method that computes the shape of a bridge hand, the extra effort \
required to write the code that tabulates all possible hand shapes according \
to their relative frequencies is just that, ", "Text",
  FontSize->14],
 StyleBox["effort.", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" Working in ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[", questions and ideas of that nature simply come out as casual \
little afterthoughts, and they can be implemented with a couple of lines of \
additional code.\nPersonally for the author, ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" has taught a newfound appreciation of the advantages of \
functional programming that he can still remember being unable to understand \
(or as the term was back then, ", "Text",
  FontSize->14],
 StyleBox["to grok", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[") at the beginning of his career when reading and hearing a couple \
of LISP enthusiasts hanging around tout the advantages of their style, when \
all you can see is Lots Of Silly Parentheses. But if you take the LISP lists \
and change all parentheses into square brackets, and move the first element \
to the syntactic position before the left square bracket, surely you are not \
changing anything essential. As you are also not changing anything if you \
follow the convention of capitalizing each name that is part of the standard \
library, or by using a graphical front end that shows the results of \
computations not as the deeply nested and hard to read expression trees that \
they really are, but as various graphical forms chosedn by the head of that \
expression. Add to this mix a high level pattern matching system that serves \
as intelligent runtime macros, and we suddenly realize that ", "Text",
  FontSize->14],
 StyleBox["Mathematica", "Text",
  FontSize->14,
  FontSlant->"Italic"],
 StyleBox[" makes the promises of LISP available in a form that Joe Average \
can readily understand and use. And these days, try out for free online on \
Wolfram Cloud.", "Text",
  FontSize->14]
}], "Text",
 CellChangeTimes->{
  3.7330583191021*^9, {3.733058744794612*^9, 3.7330587616417017`*^9}, {
   3.733065838304578*^9, 3.733065863280208*^9}, {3.7330710509230967`*^9, 
   3.733071092898323*^9}, {3.733071330223672*^9, 3.733071368885737*^9}, {
   3.733071399830369*^9, 3.733071410791494*^9}, {3.73312492697801*^9, 
   3.733125107773178*^9}, {3.7331274534063997`*^9, 3.733128187524164*^9}, {
   3.7331282635941257`*^9, 3.7331282708852577`*^9}, {3.733128477067068*^9, 
   3.733128610129099*^9}, {3.73312864555161*^9, 3.733128896079957*^9}, {
   3.733213013431449*^9, 3.733213080823511*^9}, {3.7332165292264643`*^9, 
   3.7332166166627274`*^9}, {3.733271080263598*^9, 3.73327122704347*^9}, {
   3.733277332559403*^9, 3.733277665105031*^9}, {3.7332777503737783`*^9, 
   3.733277806380417*^9}, {3.733302048141859*^9, 3.733302081065764*^9}},
 TextJustification->1.,
 FontSize->14]
}, Open  ]]
}, Open  ]]
},
WindowSize->{906, 920},
WindowMargins->{{35, Automatic}, {Automatic, 35}},
PrintingCopies->1,
PrintingPageRange->{1, Automatic},
FrontEndVersion->"10.0 for Mac OS X x86 (32-bit, 64-bit Kernel) (December 4, \
2014)",
StyleDefinitions->Notebook[{
   Cell[
    StyleData[
    StyleDefinitions -> 
     FrontEnd`FileName[{"Utility"}, "Memo.nb", CharacterEncoding -> 
       "UTF-8"]]]}, Visible -> False, FrontEndVersion -> 
  "10.0 for Mac OS X x86 (32-bit, 64-bit Kernel) (December 4, 2014)", 
  StyleDefinitions -> "PrivateStylesheetFormatting.nb"]
]
(* End of Notebook Content *)

(* Internal cache information *)
(*CellTagsOutline
CellTagsIndex->{}
*)
(*CellTagsIndex
CellTagsIndex->{}
*)
(*NotebookFileOutline
Notebook[{
Cell[CellGroupData[{
Cell[580, 22, 267, 4, 28, "Input"],
Cell[850, 28, 934, 16, 41, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[1821, 49, 450, 12, 130, "Title"],
Cell[2274, 63, 11393, 208, 1824, "Text"],
Cell[13670, 273, 1433, 40, 108, "Input"],
Cell[15106, 315, 5331, 93, 860, "Text"],
Cell[CellGroupData[{
Cell[20462, 412, 773, 18, 29, "Input"],
Cell[21238, 432, 862, 14, 29, "Output"]
}, Open  ]],
Cell[22115, 449, 935, 16, 55, "Text"],
Cell[CellGroupData[{
Cell[23075, 469, 707, 21, 86, "Input"],
Cell[23785, 492, 692, 12, 29, "Output"]
}, Open  ]],
Cell[24492, 507, 1636, 36, 216, "Text"],
Cell[CellGroupData[{
Cell[26153, 547, 2214, 56, 120, "Input"],
Cell[28370, 605, 981, 21, 49, "Output"],
Cell[29354, 628, 920, 17, 195, "Output"]
}, Open  ]],
Cell[30289, 648, 1176, 30, 147, "Text"],
Cell[31468, 680, 3631, 77, 491, "Text"],
Cell[CellGroupData[{
Cell[35124, 761, 591, 15, 29, "Input"],
Cell[35718, 778, 770, 12, 29, "Output"]
}, Open  ]],
Cell[36503, 793, 2298, 46, 308, "Text"],
Cell[CellGroupData[{
Cell[38826, 843, 954, 23, 67, "Input"],
Cell[39783, 868, 920, 15, 29, "Output"]
}, Open  ]],
Cell[40718, 886, 2626, 55, 331, "Text"],
Cell[CellGroupData[{
Cell[43369, 945, 1610, 42, 104, "Input"],
Cell[44982, 989, 869, 14, 29, "Output"]
}, Open  ]],
Cell[45866, 1006, 2071, 40, 239, "Text"],
Cell[CellGroupData[{
Cell[47962, 1050, 1433, 36, 84, "Input"],
Cell[49398, 1088, 947, 14, 29, "Output"]
}, Open  ]],
Cell[50360, 1105, 1853, 32, 193, "Text"],
Cell[CellGroupData[{
Cell[52238, 1141, 3244, 82, 230, "Input"],
Cell[55485, 1225, 772, 14, 48, "Output"]
}, Open  ]],
Cell[56272, 1242, 4016, 65, 630, "Text"],
Cell[60291, 1309, 553, 13, 32, "Input"],
Cell[60847, 1324, 1226, 31, 124, "Text"],
Cell[CellGroupData[{
Cell[62098, 1359, 1104, 30, 48, "Input"],
Cell[63205, 1391, 737, 12, 29, "Output"],
Cell[63945, 1405, 737, 12, 29, "Output"]
}, Open  ]],
Cell[64697, 1420, 866, 16, 101, "Text"],
Cell[CellGroupData[{
Cell[65588, 1440, 1044, 27, 49, "Input"],
Cell[66635, 1469, 608, 9, 29, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[67280, 1483, 424, 7, 68, "Chapter"],
Cell[67707, 1492, 2297, 44, 354, "Text"],
Cell[70007, 1538, 1514, 41, 123, "Input"],
Cell[71524, 1581, 1215, 22, 147, "Text"],
Cell[CellGroupData[{
Cell[72764, 1607, 1368, 36, 84, "Input"],
Cell[74135, 1645, 732, 14, 29, "Output"]
}, Open  ]],
Cell[74882, 1662, 535, 11, 55, "Text"],
Cell[CellGroupData[{
Cell[75442, 1677, 1508, 33, 66, "Input"],
Cell[76953, 1712, 41203, 975, 332, "Output"]
}, Open  ]],
Cell[118171, 2690, 1796, 35, 239, "Text"],
Cell[119970, 2727, 1738, 52, 159, "Input"],
Cell[121711, 2781, 1161, 22, 147, "Text"],
Cell[122875, 2805, 844, 17, 32, "Input"],
Cell[123722, 2824, 2687, 50, 331, "Text"],
Cell[CellGroupData[{
Cell[126434, 2878, 3777, 103, 303, "Input"],
Cell[130214, 2983, 6567, 154, 655, "Output"]
}, Open  ]],
Cell[136796, 3140, 4593, 73, 630, "Text"],
Cell[141392, 3215, 130, 2, 54, "Text"],
Cell[141525, 3219, 4236, 90, 607, "Text"],
Cell[CellGroupData[{
Cell[145786, 3313, 1876, 45, 211, "Input"],
Cell[147665, 3360, 576, 9, 29, "Output"]
}, Open  ]],
Cell[148256, 3372, 612, 13, 78, "Text"],
Cell[CellGroupData[{
Cell[148893, 3389, 1317, 34, 68, "Input"],
Cell[150213, 3425, 724, 12, 29, "Output"]
}, Open  ]],
Cell[150952, 3440, 2255, 42, 285, "Text"],
Cell[CellGroupData[{
Cell[153232, 3486, 2439, 53, 193, "Input"],
Cell[155674, 3541, 1014, 17, 29, "Output"],
Cell[156691, 3560, 948, 16, 29, "Output"]
}, Open  ]],
Cell[157654, 3579, 639, 13, 55, "Text"],
Cell[CellGroupData[{
Cell[158318, 3596, 524, 14, 48, "Input"],
Cell[158845, 3612, 799, 17, 29, "Output"]
}, Open  ]],
Cell[159659, 3632, 1482, 28, 193, "Text"],
Cell[CellGroupData[{
Cell[161166, 3664, 1216, 30, 86, "Input"],
Cell[162385, 3696, 631, 9, 29, "Output"]
}, Open  ]],
Cell[163031, 3708, 4203, 88, 584, "Text"],
Cell[CellGroupData[{
Cell[167259, 3800, 1520, 37, 139, "Input"],
Cell[168782, 3839, 668, 10, 29, "Output"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[169499, 3855, 465, 8, 68, "Chapter"],
Cell[169967, 3865, 3399, 73, 492, "Text"],
Cell[CellGroupData[{
Cell[173391, 3942, 1822, 47, 103, "Input"],
Cell[175216, 3991, 771, 13, 29, "Output"]
}, Open  ]],
Cell[176002, 4007, 1113, 19, 124, "Text"],
Cell[CellGroupData[{
Cell[177140, 4030, 838, 21, 66, "Input"],
Cell[177981, 4053, 1009, 27, 48, "Output"],
Cell[178993, 4082, 1009, 27, 48, "Output"],
Cell[180005, 4111, 824, 15, 29, "Output"]
}, Open  ]],
Cell[180844, 4129, 1440, 27, 170, "Text"],
Cell[CellGroupData[{
Cell[182309, 4160, 671, 16, 49, "Input"],
Cell[182983, 4178, 778, 14, 29, "Output"]
}, Open  ]],
Cell[183776, 4195, 2441, 49, 331, "Text"],
Cell[CellGroupData[{
Cell[186242, 4248, 1765, 46, 104, "Input"],
Cell[188010, 4296, 743, 11, 29, "Output"],
Cell[188756, 4309, 743, 11, 29, "Output"]
}, Open  ]],
Cell[189514, 4323, 2105, 40, 239, "Text"],
Cell[CellGroupData[{
Cell[191644, 4367, 1645, 42, 193, "Input"],
Cell[CellGroupData[{
Cell[193314, 4413, 852, 14, 22, "Print"],
Cell[194169, 4429, 783, 14, 22, "Print"]
}, Open  ]]
}, Open  ]],
Cell[194979, 4447, 1935, 42, 193, "Text"],
Cell[CellGroupData[{
Cell[196939, 4493, 809, 20, 49, "Input"],
Cell[197751, 4515, 725, 14, 29, "Output"]
}, Open  ]],
Cell[198491, 4532, 1624, 37, 170, "Text"],
Cell[CellGroupData[{
Cell[200140, 4573, 931, 23, 49, "Input"],
Cell[201074, 4598, 697, 13, 29, "Output"]
}, Open  ]],
Cell[201786, 4614, 1821, 43, 216, "Text"],
Cell[CellGroupData[{
Cell[203632, 4661, 1104, 31, 49, "Input"],
Cell[204739, 4694, 729, 13, 29, "Output"]
}, Open  ]],
Cell[205483, 4710, 2152, 34, 331, "Text"]
}, Open  ]],
Cell[CellGroupData[{
Cell[207672, 4749, 160, 3, 68, "Chapter"],
Cell[207835, 4754, 1582, 44, 147, "Text"],
Cell[CellGroupData[{
Cell[209442, 4802, 1486, 43, 67, "Input"],
Cell[210931, 4847, 1098, 22, 29, "Output"],
Cell[212032, 4871, 2892, 60, 230, "Output"]
}, Open  ]],
Cell[214939, 4934, 929, 16, 124, "Text"],
Cell[CellGroupData[{
Cell[215893, 4954, 477, 12, 49, "Input"],
Cell[216373, 4968, 562, 9, 29, "Output"]
}, Open  ]],
Cell[216950, 4980, 2146, 42, 285, "Text"],
Cell[219099, 5024, 391, 10, 32, "Input"],
Cell[219493, 5036, 2256, 47, 308, "Text"],
Cell[CellGroupData[{
Cell[221774, 5087, 2070, 50, 175, "Input"],
Cell[223847, 5139, 607, 9, 29, "Output"]
}, Open  ]],
Cell[224469, 5151, 1419, 28, 170, "Text"],
Cell[CellGroupData[{
Cell[225913, 5183, 1020, 29, 49, "Input"],
Cell[226936, 5214, 540, 8, 29, "Output"]
}, Open  ]],
Cell[227491, 5225, 1499, 27, 193, "Text"],
Cell[228993, 5254, 1932, 48, 157, "Input"],
Cell[230928, 5304, 561, 12, 55, "Text"],
Cell[231492, 5318, 983, 26, 49, "Input"],
Cell[232478, 5346, 1115, 26, 170, "Text"],
Cell[CellGroupData[{
Cell[233618, 5376, 1197, 29, 84, "Input"],
Cell[234818, 5407, 643, 10, 29, "Output"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[235510, 5423, 217, 4, 68, "Chapter"],
Cell[235730, 5429, 4510, 106, 584, "Text"],
Cell[CellGroupData[{
Cell[240265, 5539, 944, 28, 86, "Input"],
Cell[241212, 5569, 584, 12, 29, "Output"]
}, Open  ]],
Cell[241811, 5584, 1195, 28, 147, "Text"],
Cell[CellGroupData[{
Cell[243031, 5616, 1206, 34, 86, "Input"],
Cell[244240, 5652, 1565, 34, 131, "Output"]
}, Open  ]],
Cell[245820, 5689, 2383, 45, 285, "Text"],
Cell[248206, 5736, 1598, 39, 69, "Input"],
Cell[249807, 5777, 814, 16, 78, "Text"],
Cell[CellGroupData[{
Cell[250646, 5797, 1475, 39, 68, "Input"],
Cell[252124, 5838, 29139, 727, 233, "Output"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[281312, 6571, 304, 6, 68, "Chapter"],
Cell[281619, 6579, 3614, 67, 446, "Text"],
Cell[CellGroupData[{
Cell[285258, 6650, 1666, 46, 106, "Input"],
Cell[286927, 6698, 400, 9, 29, "Output"]
}, Open  ]],
Cell[287342, 6710, 5444, 105, 791, "Text"],
Cell[292789, 6817, 905, 29, 88, "Input"],
Cell[293697, 6848, 2783, 58, 377, "Text"],
Cell[296483, 6908, 948, 29, 89, "Input"],
Cell[297434, 6939, 468, 9, 55, "Text"],
Cell[297905, 6950, 803, 24, 69, "Input"],
Cell[298711, 6976, 2859, 56, 446, "Text"],
Cell[CellGroupData[{
Cell[301595, 7036, 1871, 56, 142, "Input"],
Cell[303469, 7094, 584, 11, 29, "Output"]
}, Open  ]],
Cell[304068, 7108, 886, 16, 124, "Text"],
Cell[CellGroupData[{
Cell[304979, 7128, 1533, 52, 48, "Input"],
Cell[306515, 7182, 616, 12, 29, "Output"],
Cell[307134, 7196, 616, 12, 29, "Output"]
}, Open  ]],
Cell[307765, 7211, 1012, 18, 147, "Text"],
Cell[308780, 7231, 847, 25, 69, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[309664, 7261, 463, 8, 68, "Chapter"],
Cell[310130, 7271, 4069, 102, 515, "Text"],
Cell[CellGroupData[{
Cell[314224, 7377, 486, 11, 66, "Input"],
Cell[314713, 7390, 581, 9, 29, "Output"],
Cell[315297, 7401, 1165, 19, 66, "Output"]
}, Open  ]],
Cell[316477, 7423, 2125, 33, 262, "Text"],
Cell[CellGroupData[{
Cell[318627, 7460, 1651, 42, 158, "Input"],
Cell[320281, 7504, 850, 14, 29, "Output"]
}, Open  ]],
Cell[321146, 7521, 1607, 35, 193, "Text"],
Cell[CellGroupData[{
Cell[322778, 7560, 2629, 64, 194, "Input"],
Cell[325410, 7626, 10192, 155, 516, "Output"]
}, Open  ]],
Cell[335617, 7784, 3140, 62, 423, "Text"],
Cell[CellGroupData[{
Cell[338782, 7850, 1358, 33, 85, "Input"],
Cell[340143, 7885, 1887, 38, 48, "Output"],
Cell[342033, 7925, 598, 10, 29, "Output"],
Cell[342634, 7937, 636, 10, 29, "Output"]
}, Open  ]],
Cell[343285, 7950, 817, 14, 78, "Text"],
Cell[CellGroupData[{
Cell[344127, 7968, 1102, 28, 67, "Input"],
Cell[345232, 7998, 675, 12, 29, "Output"]
}, Open  ]],
Cell[345922, 8013, 2028, 32, 262, "Text"],
Cell[CellGroupData[{
Cell[347975, 8049, 1687, 40, 122, "Input"],
Cell[349665, 8091, 2235, 38, 174, "Output"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[351949, 8135, 524, 9, 68, "Chapter"],
Cell[352476, 8146, 5223, 107, 791, "Text"],
Cell[357702, 8255, 1164, 28, 85, "Input"],
Cell[358869, 8285, 1007, 17, 147, "Text"],
Cell[359879, 8304, 1009, 32, 29, "Input"],
Cell[360891, 8338, 772, 17, 78, "Text"],
Cell[361666, 8357, 2969, 74, 177, "Input"],
Cell[364638, 8433, 2583, 52, 377, "Text"],
Cell[367224, 8487, 4828, 116, 250, "Input"],
Cell[372055, 8605, 1165, 21, 147, "Text"],
Cell[373223, 8628, 4036, 93, 230, "Input"]
}, Open  ]],
Cell[CellGroupData[{
Cell[377296, 8726, 440, 8, 68, "Chapter"],
Cell[377739, 8736, 8381, 177, 1159, "Text"]
}, Open  ]]
}, Open  ]]
}
]
*)

(* End of internal cache information *)
